AtomicInteger和AtomicLong都是通过cas死循环更新维护值，在并发量大的情况下，失败率很高，导致不断循环，CPU使用率飙升。
LongAdder在并发量低的情况下，也是通过cas死循环更新维护值，在并发量大的情况下，通过Cell[]数组更新维护值，相当于分段锁，在并发情况下，只能保证最终一致性。如果要求强一致性，还是要使用AtomicLong。
cas存在aba问题，全称Compare and swap，比较寄存器的值与内存的值，如果相同，就把两个值进行交换，但是这个操作不是原子的，当进行比较的时候，可能有其他线程把这个值从a改成b，又改回a，当前线程无法感知到，不知道这个值被修改过。
解决aba问题，可以引入版本号解决，例如AtomicStampedReference。
