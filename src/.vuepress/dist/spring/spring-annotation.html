<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.9" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.38" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/spring/spring-annotation.html"><meta property="og:site_name" content="Java八股文网"><meta property="og:description" content="注解不仅仅是“简化配置”那么简单。每一个常用的Spring注解背后，都隐藏着Spring容器为了处理它而默默执行的复杂机制。对于中高级开发者来说，仅仅会用注解是远远不够的，理解它们“为什么”能工作，以及它们触发了Spring容器的哪些行为，是提升技术内功、高效解决问题、并从容面对高阶面试的必经之路。 接下来，我们将按照功能对Spring的常用注解进行分..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2025-05-01T16:05:51.000Z"><meta property="article:author" content="Mr.Hope"><meta property="article:modified_time" content="2025-05-01T16:05:51.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"","image":[""],"dateModified":"2025-05-01T16:05:51.000Z","author":[{"@type":"Person","name":"Mr.Hope","url":"https://mister-hope.com"}]}</script><title>Java八股文网</title><meta name="description" content="注解不仅仅是“简化配置”那么简单。每一个常用的Spring注解背后，都隐藏着Spring容器为了处理它而默默执行的复杂机制。对于中高级开发者来说，仅仅会用注解是远远不够的，理解它们“为什么”能工作，以及它们触发了Spring容器的哪些行为，是提升技术内功、高效解决问题、并从容面对高阶面试的必经之路。 接下来，我们将按照功能对Spring的常用注解进行分...">
    <link rel="preload" href="/javabaguwen/assets/style-BlxzwH3B.css" as="style"><link rel="stylesheet" href="/javabaguwen/assets/style-BlxzwH3B.css">
    <link rel="modulepreload" href="/javabaguwen/assets/app-CzKZ5RuK.js"><link rel="modulepreload" href="/javabaguwen/assets/spring-annotation.html-DhccIzq7.js"><link rel="modulepreload" href="/javabaguwen/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/javabaguwen/assets/index.html-BIyLuIZF.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/home.html-C5FRllnR.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/rabbitmq-framework.html-BJfTRdzN.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/updating.html-BTqB4lev.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-C8HE3sTb.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-BofRPUP9.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/algo-array.html-CQh2BX_6.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/algo-listnode.html-BvccyswQ.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/algo-other.html-K02tHtJV.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/algo-sort.html-C0ujop87.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/algo-string.html-q9_U9xvR.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/algo-tree.html-fzmi3uQe.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/AQS.html-CYJjvTlb.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/AtomicInteger.html-7TMQuKsp.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/CountDownLatch.html-CYv1LQ1Z.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/CyclicBarrier.html-dCzoFKnI.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/ReentrantLock.html-DT7NPqvu.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/Semaphore.html-Du-7oZ5-.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/Synchronized.html-CLfoofuc.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/Thread.html-DKAwCMmT.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/ThreadLocal.html-DOskLcBZ.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/ThreadPool.html-V9AKjCqz.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/volatile.html-McyFZwId.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-CGtdkXoz.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-DcfeFKU4.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/disable.html-CjEhayv1.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/encrypt.html-DyasH04g.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/layout.html-CLX-uWFx.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/markdown.html-CVZwBvfb.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/page.html-BEnAPjYC.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/dubbo-framework.html-DGnuTtZS.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/jvm-framework.html-wqzu3og7.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-BsR05xgW.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/annotation.html-DRaOvbGf.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/copy.html-nTurp9_0.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/delivery.html-87bW9ZQu.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/exception.html-ElW60mXV.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/generic.html-CKmc6Kja.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/java8.html-DuspJqsS.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/proxy.html-Bj_HftOj.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/reflect.html-CpONb-0n.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/ArrayBlockingQueue.html-CO-2EzLw.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/ArrayList.html-BonMJYMw.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/BlockingQueue合集.html-DI6C5W2f.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/ConcurrentHashMap.html-_TOD-950.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/CopyOnWriteArrayList.html-B5zGDOwU.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/DelayQueue.html-iUAKqX_T.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/HashMap.html-Cc28QPf4.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/LinkedBlockingQueue.html-C3gbP6Hy.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/LinkedHashMap.html-D1iaN7fZ.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/LinkedList.html-s_Gg-gJ-.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/PriorityQueue.html-B75Nhyur.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/Set.html-WDNqLCw9.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/SynchronousQueue.html-D9kHbkxa.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/TreeMap.html-JDD-EDSl.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/kafka-framework.html-t1PB4Ym7.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/kafka-message.html-CJe0pgjk.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/kafka-select.html-DZ5JgX2c.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/MySQL链路追踪.html-BnDBpO2n.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/backup.html-cIr6AxF9.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/dead.html-DDinBR_w.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/engine.html-DCorJ_Si.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/explain.html-BBbXvmoq.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/framework.html-DSt6zGky.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-BJ13k3j_.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/lock.html-hf9PfmVp.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/log.html-CP_B3iV1.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/MVCC.html-DFpZ9Xsd.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/online.html-XNa1bdSw.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/optimize.html-DmAv8Wa2.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/page.html-n1_eFn8N.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/performance.html-10BbqZ0p.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/phantom.html-C71tbTxW.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/push.html-q6XvQohg.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/range.html-BZUxJlnM.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/second.html-B7C_rXBU.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/skip.html-DhiPjR3y.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/slow.html-Cml4t6y_.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/standard.html-BgjOOG7w.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/sync.html-Dl0JIUZG.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/three.html-BV1cBk6B.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/timeout.html-D_C43jRE.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/transaction.html-BhOB1bIO.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/netty-framework.html-B-INaDy8.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/mybatis-framework.html-hn-wmowB.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/ShardingSphere-framework.html-ijRl8ypt.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/RocketMQ-transaction.html-BCvpslaN.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/rocketmq-framwork.html-Bu3WJkdY.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/redis-batch.html-CZkEnRbz.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/redis-bigkey.html-DUhEL8XR.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/redis-cache.html-OtONNZWb.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/redis-cluster.html-DXASisVt.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/redis-data.html-DrT2dBuq.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/redis-fast.html-COH-y8uJ.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/redis-hotkey.html-Bug7S0FM.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/redis-lock.html-BpMAcuRp.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/redis-mq.html-BNQhQCLK.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/redis-persistent.html-wZc4pSik.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/redis-thread.html-7XZWhA7_.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/redis-transaction.html-DFFKtk5_.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springmvc-annotation.html-8TpZm-ME.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springmvc-framework.html-DqY461Gt.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springmvc-work.html-MrZ6RZ0c.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springcloud-eureka.html-DQqATMuM.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springcloud-feign.html-dOnWbHIR.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springcloud-framework.html-pCyUxtT8.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springcloud-gateway.html-6yFi7TZ8.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springcloud-hystrix.html-ikGPNR8A.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springcloud-ribbon.html-3CwdE5RY.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springcloud-select.html-ChKzgBHi.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springcloud-zuul.html-BhCaZOhm.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springboot-annotation.html-CxO4w72H.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springboot-start.html-DXm_zidT.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springboot-starter.html-Dg_Ei0cx.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/springboot-what.html-BzYUyf9C.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/zookeeper-framework.html-DhcA8Ae_.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/spring-bean.html-9HbZMsGo.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/spring-depend.html-CwWmirDv.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/spring-design.html-DPOuT1Sx.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/spring-framework.html-HsSq5DPU.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/spring-ioc-aop.html-BkFkS5_m.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/spring-transaction.html-ClIKZH47.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-C0r6933U.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/baz.html-CA5_i735.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-8CTMKBd3.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/ray.html-BRNlRk6d.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/kafka-controller.html-fbsoqZpr.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/kafka-framework.html-Dra6O8Z5.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/kafka-leader.html-Do79ltBr.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/kafka-message.html-aE5Mz7vy.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/Arthas.html-D0D8wX0z.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/CodeReview.html-r6MmZq89.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/GuavaCache.html-BxqdD_rY.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/git.html-DlT79MnX.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/404.html-CNH5e1PP.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-BZB_9PUz.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-Dpc2uxYQ.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-tzWzwKAt.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-BROoLkQz.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-BJD-pPo-.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-C-kSMRah.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-CwU0YFHN.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-CGuRoTHs.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-InAU6Ddc.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-BhUNVG5k.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-DbJ8HS_0.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-Bi55j3tV.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-D6bkBnce.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-CC0VLLj5.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-B5y_vezN.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-oHslfc13.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-DthGt63M.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-Dr08pODp.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/index.html-BLmvLduy.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/giscus-1zs_z9NH.js" as="script"><link rel="prefetch" href="/javabaguwen/assets/photoswipe.esm-DXWKOczD.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/javabaguwen/"><img class="vp-nav-logo" src="https://theme-hope-assets.vuejs.press/logo.svg" alt><!----><span class="vp-site-name hide-in-pad">Java八股文网</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link nav-link" href="/javabaguwen/" aria-label="项目主页"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>项目主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link nav-link" href="/javabaguwen/home.html" aria-label="Java八股文"><span class="font-icon icon fa-fw fa-sm fas fa-eight" style=""></span>Java八股文<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link nav-link" href="/javabaguwen/interview/" aria-label="面试流程"><span class="font-icon icon fa-fw fa-sm fas fa-interview" style=""></span>面试流程<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link nav-link" href="/javabaguwen/algo/" aria-label="算法"><span class="font-icon icon fa-fw fa-sm fas fa-algo" style=""></span>算法<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link nav-link" href="/javabaguwen/tool/" aria-label="工具"><span class="font-icon icon fa-fw fa-sm fas fa-tool" style=""></span>工具<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link nav-link" href="/javabaguwen/about/" aria-label="关于"><span class="font-icon icon fa-fw fa-sm fas fa-about" style=""></span>关于<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/vuepress-theme-hope/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/javabaguwen/home.html" aria-label="一、前言"><!---->一、前言<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">二、Java基础</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">三、Java进阶</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">四、数据库</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">五、JVM</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">六、框架</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">Spring</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/javabaguwen/spring/spring-framework.html" aria-label="Spring架构设计"><!---->Spring架构设计<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/javabaguwen/spring/spring-bean.html" aria-label="Bean生命周期"><!---->Bean生命周期<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/javabaguwen/spring/spring-design.html" aria-label="Spring用到哪些设计模式"><!---->Spring用到哪些设计模式<!----></a></li><li><a class="route-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/javabaguwen/spring/spring-annotation.html" aria-label="Spring常用注解"><!---->Spring常用注解<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/javabaguwen/spring/spring-transaction.html" aria-label="Spring事务"><!---->Spring事务<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/javabaguwen/spring/spring-ioc-aop.html" aria-label="IOC与AOP区别"><!---->IOC与AOP区别<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/javabaguwen/spring/spring-depend.html" aria-label="Spring循环依赖"><!---->Spring循环依赖<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">SpringBoot</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">SpringMVC</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">SpringCloud</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Dubbo</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Netty</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">ShardingSphere</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">zookeeper</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">mybatis</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">七、消息队列</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!----></h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://mister-hope.com" target="_blank" rel="noopener noreferrer">Mr.Hope</a></span><span property="author" content="Mr.Hope"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2025-04-29T10:53:44.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 28 分钟</span><meta property="timeRequired" content="PT28M"></span><!----><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!--[--><!----><!--]--><div class="vp-toc-header">此页内容<!----><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#深度解析-spring-常用注解-从会用到知其所以然">深度解析 Spring 常用注解：从会用到知其所以然</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#引言-注解-spring的现代化配置基石">引言：注解，Spring的现代化配置基石</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#spring常用注解分类深度解析">Spring常用注解分类深度解析</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#注解的使用建议与思考">注解的使用建议与思考</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#注解如何助你理解spring和应对面试">注解如何助你理解Spring和应对面试</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#总结">总结</a></li><!----><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><p>注解不仅仅是“简化配置”那么简单。每一个常用的Spring注解背后，都隐藏着Spring容器为了处理它而默默执行的复杂机制。对于中高级开发者来说，仅仅会用注解是远远不够的，理解它们“为什么”能工作，以及它们触发了Spring容器的哪些行为，是提升技术内功、高效解决问题、并从容面对高阶面试的必经之路。</p><p>接下来，我们将按照功能对Spring的常用注解进行分类解析，深入探讨它们的功能、用法、背后原理，以及它们与面试常考点的关联。</p><hr><h2 id="深度解析-spring-常用注解-从会用到知其所以然" tabindex="-1"><a class="header-anchor" href="#深度解析-spring-常用注解-从会用到知其所以然"><span>深度解析 Spring 常用注解：从会用到知其所以然</span></a></h2><h3 id="引言-注解-spring的现代化配置基石" tabindex="-1"><a class="header-anchor" href="#引言-注解-spring的现代化配置基石"><span>引言：注解，Spring的现代化配置基石</span></a></h3><p>遥想Spring早期，XML配置是主流，一个简单的应用可能就需要大量的XML文件来定义Bean、配置依赖、声明事务等等，这带来了“配置地狱”的问题。随着Java 5引入注解特性，Spring迅速拥抱了这一变化，逐步推出了基于注解的配置方式，如 <code>@Autowired</code> 用于依赖注入，<code>@Transactional</code> 用于事务管理，<code>@Controller</code> 用于Web层组件标识等。</p><p>注解的引入，带来了革命性的变化：</p><ul><li><strong>简化配置：</strong> 将配置信息与使用它的代码紧密结合，减少了独立的配置文件数量。</li><li><strong>提高开发效率：</strong> 编写代码的同时完成配置，减少了在代码和XML之间切换的开销。</li><li><strong>增强可读性：</strong> 注解直接标注在类、方法或字段上，代码本身就能更直观地表达其在Spring容器中的角色和行为。</li><li><strong>深入理解框架：</strong> 学习注解背后的原理，能帮助我们理解Spring容器是如何扫描、解析、处理这些注解，并最终构建起功能完整的应用的。</li><li><strong>高效准备面试：</strong> 许多Spring的核心面试题都与常用注解紧密相关，理解注解的原理和用法，是回答这些问题的关键。</li></ul><p>本文将聚焦于Spring中最常用、最核心、也是面试中最常考察的注解，按照其功能进行分类，并深入剖析其背后的原理。</p><h3 id="spring常用注解分类深度解析" tabindex="-1"><a class="header-anchor" href="#spring常用注解分类深度解析"><span>Spring常用注解分类深度解析</span></a></h3><p>我们将从IoC容器、配置、AOP、事务、生命周期等多个维度，逐一击破Spring的常用注解。</p><h4 id="_2-1-ioc-容器核心注解" tabindex="-1"><a class="header-anchor" href="#_2-1-ioc-容器核心注解"><span>2.1 IoC 容器核心注解</span></a></h4><p>这些注解主要用于标识组件、管理依赖注入和控制 Bean 的行为。</p><ul><li><p><strong><code>@Component</code>及其派生注解：<code>@Repository</code>, <code>@Service</code>, <code>@Controller</code></strong></p><ul><li><strong>功能与目的：</strong> 标识一个类为Spring容器管理的组件（Bean）。<code>@Repository</code> (<code>@Repository</code>) 用于数据访问层，<code>@Service</code> (<code>@Service</code>) 用于业务逻辑层，<code>@Controller</code> (<code>@Controller</code>) 用于Web层（MVC控制器）。它们都是 <code>@Component</code> 的<strong>元注解</strong>（即注解的注解），Spring 会扫描这些注解标识的类，并将它们注册为 BeanDefinition。</li><li><strong>使用场景与示例：</strong> 应用于类定义上，配合 <code>@ComponentScan</code> 进行自动扫描和注册。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Repository</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserRepositoryImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserRepository</span> <span class="token punctuation">{</span>
    <span class="token comment">// ... // @Repository 还有一个额外功能是能够自动将数据访问相关的特定异常转换为 Spring 的统一 DataAccessException 体系异常</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> 这依赖于 Spring 的 <strong>组件扫描 (Component Scanning)</strong> 机制。当配置了 <code>@ComponentScan</code>（或在 XML 中配置 <code>&lt;context:component-scan&gt;</code>）后，Spring 容器启动时会扫描指定包及其子包下带有 <code>@Component</code> 或其派生注解的类。对于每一个被扫描到的类，Spring 会为其创建一个 <code>BeanDefinition</code>，并将其注册到容器中。</li><li><strong>给开发者的建议：</strong> 优先使用 <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code> 等语义化注解，它们能更清晰地表达组件在架构中的角色。未来 Spring 可能也会基于这些语义化注解提供更多特定功能。</li><li><strong>面试关联：</strong> “<code>@Component</code> 和 <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code> 的区别是什么？” 回答它们是派生关系，并提及 <code>@Repository</code> 的异常转换功能，能体现你对这些注解细微差别的理解。</li></ul></li><li><p><strong><code>@Autowired</code></strong></p><ul><li><strong>功能与目的：</strong> Spring 提供的一种依赖注入注解，用于标记需要Spring容器注入依赖的成员变量、Setter方法或构造器。</li><li><strong>使用场景与示例：</strong><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 字段注入 (不推荐)</span>
<span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>

<span class="token comment">// Setter 方法注入 (推荐)</span>
<span class="token keyword">private</span> <span class="token class-name">UserRepository</span> userRepository<span class="token punctuation">;</span>
<span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserRepository</span><span class="token punctuation">(</span><span class="token class-name">UserRepository</span> userRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>userRepository <span class="token operator">=</span> userRepository<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 构造器注入 (最推荐，尤其是强制依赖)</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">OrderService</span> orderService<span class="token punctuation">;</span>
<span class="token annotation punctuation">@Autowired</span> <span class="token comment">// Spring 4.3+ 如果只有一个构造器，可省略 @Autowired</span>
<span class="token keyword">public</span> <span class="token class-name">OrderServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">OrderService</span> orderService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>orderService <span class="token operator">=</span> orderService<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>推荐构造器注入的原因：</strong> 1. 强制依赖关系清晰；2. 有利于单元测试（无需依赖容器即可实例化对象，并注入 Mock 依赖）；3. 创建的对象是完全初始化的，避免了循环依赖（字段/Setter注入可能导致循环依赖早期暴露“半成品”）。</li></ul></li><li><strong>背后原理浅析：</strong> <code>@Autowired</code> 的处理依赖于 Spring 内置的 <strong><code>AutowiredAnnotationBeanPostProcessor</code></strong>。这是一个 BeanPostProcessor 的实现，它在 Bean 的生命周期中，<strong>属性填充阶段</strong>之后（但在任何初始化回调之前），会检查当前 Bean 中是否有 <code>@Autowired</code>、<code>@Value</code> 或 JSR 330 的 <code>@Inject</code>、<code>@Resource</code> 注解标注的成员或方法。如果发现，它会尝试从容器中查找匹配的 Bean 并注入。 <ul><li><strong>查找过程：</strong> 默认按<strong>类型</strong>查找。如果发现多个同类型的 Bean，会尝试按<strong>名称</strong>匹配（变量名/参数名）。如果仍有多个匹配，会抛出异常，此时需要结合 <code>@Qualifier</code> 或 <code>@Primary</code> 来明确指定。</li></ul></li><li><strong>给开发者的建议：</strong> 优先使用构造器注入处理强制依赖，使用 Setter 注入处理可选依赖。避免使用字段注入，因为它不利于解耦和测试。</li><li><strong>面试关联：</strong> “<code>@Autowired</code> 的注入方式有哪些？它们的优缺点是什么？” “<code>@Autowired</code> 是如何工作的？底层原理是什么？” “如何解决 <code>@Autowired</code> 注入多个同类型 Bean 的问题？” 都是高频面试题。理解 <code>@Autowired</code> 的查找规则和 <code>AutowiredAnnotationBeanPostProcessor</code> 的作用是关键。</li></ul></li><li><p><strong><code>@Qualifier</code></strong></p><ul><li><strong>功能与目的：</strong> 当容器中存在多个同类型的 Bean 时，<code>@Qualifier</code> 用于配合 <code>@Autowired</code> 精确指定需要注入哪一个 Bean。它提供了一个限定符（通常是 Bean 的名称或其他自定义名称）。</li><li><strong>使用场景与示例：</strong><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span><span class="token punctuation">(</span><span class="token string">&quot;smsSender&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SmsSender</span> <span class="token keyword">implements</span> <span class="token class-name">MessageSender</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span><span class="token punctuation">(</span><span class="token string">&quot;emailSender&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmailSender</span> <span class="token keyword">implements</span> <span class="token class-name">MessageSender</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotificationService</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">&quot;emailSender&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 指定注入名为 &quot;emailSender&quot; 的 Bean</span>
    <span class="token keyword">private</span> <span class="token class-name">MessageSender</span> messageSender<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>AutowiredAnnotationBeanPostProcessor</code> 在按类型查找找到多个匹配 Bean 时，会进一步检查是否有 <code>@Qualifier</code> 注解。如果存在，它会根据 <code>@Qualifier</code> 指定的名称或其他属性，在候选 Bean 中找到匹配的唯一一个进行注入。</li><li><strong>面试关联：</strong> “如何解决 <code>@Autowired</code> 注入歧义性问题？” 回答 <code>@Qualifier</code> 和 <code>@Primary</code>，并说明 <code>@Qualifier</code> 的作用。</li></ul></li><li><p><strong><code>@Value</code></strong></p><ul><li><strong>功能与目的：</strong> 注入外部化属性（如配置文件 <code>.properties</code>, <code>.yml</code> 中的值）、操作系统环境变量、系统属性，或者使用 Spring Expression Language (SpEL) 表达式的结果。</li><li><strong>使用场景与示例：</strong><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">&quot;${app.name}&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 注入配置文件中 app.name 的值</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> appName<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">&quot;#{systemProperties[&#39;java.version&#39;]}&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 注入系统属性 java.version</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> javaVersion<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">&quot;#{userService.getUserCount() &gt; 100 ? &#39;Plenty&#39; : &#39;Few&#39;}&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 注入 SpEL 表达式结果</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> userCountStatus<span class="token punctuation">;</span>

    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>@Value</code> 也由 <code>AutowiredAnnotationBeanPostProcessor</code> 处理。它会解析 <code>@Value</code> 中的字符串，如果是 <code>${...}</code> 格式，则从 Spring 的 <code>Environment</code> 中查找对应的属性值；如果是 <code>#{...}</code> 格式，则解析并执行 SpEL 表达式。这个过程发生在属性填充阶段。</li><li><strong>给开发者的建议：</strong> <code>@Value</code> 是外部化配置的好帮手，结合 Spring Boot 的 <code>application.properties</code>/<code>application.yml</code> 和 <code>@PropertySource</code> 使用非常方便。</li><li><strong>面试关联：</strong> “如何在 Spring 中读取配置文件中的属性值？” 回答 <code>@Value</code>，并提及 <code>${}</code> 占位符和 SpEL 表达式。</li></ul></li><li><p><strong><code>@Scope</code></strong></p><ul><li><strong>功能与目的：</strong> 定义 Bean 的作用域，即控制 Bean 实例的生命周期和共享方式。</li><li><strong>常用值：</strong> <code>singleton</code> (默认，单例), <code>prototype</code> (原型，每次获取新实例), <code>request</code> (Web请求生命周期), <code>session</code> (HttpSession 生命周期)。</li><li><strong>使用场景与示例：</strong> 应用于类定义或 <code>@Bean</code> 方法上。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">&quot;prototype&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 声明这是一个原型 Bean</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyPrototypeBean</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">&quot;singleton&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 声明这是一个单例 Bean (默认行为，但可显式声明)</span>
    <span class="token keyword">public</span> <span class="token class-name">MySingletonBean</span> <span class="token function">mySingletonBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>@Scope</code> 信息存储在 Bean 的 <code>BeanDefinition</code> 中。Spring 容器在创建 Bean 实例时，会根据 <code>BeanDefinition</code> 中的 scope 信息决定是返回已有的单例实例，还是创建一个新的原型实例，或者委托给其他 Scope 管理器（如 Request/Session Scope）来获取实例。</li><li><strong>面试关联：</strong> “Spring Bean 有哪些作用域？默认是什么？原型 Bean 和单例 Bean 的生命周期有什么区别？” 理解 <code>@Scope</code> 的不同值及其对 Bean 生命周期管理的影响至关重要。</li></ul></li><li><p><strong><code>@Lazy</code></strong></p><ul><li><strong>功能与目的：</strong> 控制单例 Bean 是否延迟加载。默认情况下，单例 Bean 在容器启动时就会被创建和初始化。标注 <code>@Lazy</code> 后，该 Bean 只会在第一次被使用（被其他 Bean 引用或通过 <code>getBean()</code> 获取）时才创建。</li><li><strong>使用场景与示例：</strong> 应用于类定义或 <code>@Bean</code> 方法上。对于启动时不需要立即使用的 Bean，或者初始化开销较大的 Bean，可以使用 <code>@Lazy</code> 优化启动速度。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@Lazy</span> <span class="token comment">// 这个 Service 只在第一次被注入或获取时才创建</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LargeResourceService</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>@Lazy</code> 信息也存储在 <code>BeanDefinition</code> 中。容器在初始化所有非延迟加载的单例 Bean 时，会跳过标记为 <code>@Lazy</code> 的 Bean。当有其他 Bean 依赖它或代码请求它时，容器才会触发其完整的创建和初始化流程。</li><li><strong>面试关联：</strong> “如何控制 Spring Bean 的加载时机？” 回答 <code>@Lazy</code>，并说明其作用和使用场景。</li></ul></li><li><p><strong><code>@Primary</code></strong></p><ul><li><strong>功能与目的：</strong> 当容器中存在多个同类型的 Bean 时，<code>@Primary</code> 用于指定其中一个 Bean 作为首选（Primary）的注入候选。当使用 <code>@Autowired</code> 按类型注入时，如果存在多个候选 Bean，Spring 会优先选择被 <code>@Primary</code> 标注的那个，而无需使用 <code>@Qualifier</code>。</li><li><strong>使用场景与示例：</strong> 当某个接口有多个实现，其中一个实现是“默认”或“常用”的。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MessageSender</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SmsSender</span> <span class="token keyword">implements</span> <span class="token class-name">MessageSender</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@Primary</span> <span class="token comment">// 优先选择 EmailSender 进行注入</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmailSender</span> <span class="token keyword">implements</span> <span class="token class-name">MessageSender</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotificationService</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span> <span class="token comment">// 此时会自动注入 EmailSender</span>
    <span class="token keyword">private</span> <span class="token class-name">MessageSender</span> messageSender<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>AutowiredAnnotationBeanPostProcessor</code> 在按类型查找并找到多个匹配 Bean 时，会检查这些候选 Bean 是否有 <code>@Primary</code> 标注。如果只有一个被标注，则选择它；如果多个被标注或都没有标注，则回退到按名称匹配或其他规则，如果仍无法唯一确定，则抛出异常（此时需要 <code>@Qualifier</code>）。</li><li><strong>面试关联：</strong> “如何解决 <code>@Autowired</code> 注入歧义性问题？” 回答 <code>@Primary</code> 和 <code>@Qualifier</code>，并说明 <code>@Primary</code> 作为默认优先级的用法。</li></ul></li></ul><h4 id="_2-2-配置类相关注解-javaconfig" tabindex="-1"><a class="header-anchor" href="#_2-2-配置类相关注解-javaconfig"><span>2.2 配置类相关注解 (JavaConfig)</span></a></h4><p>这些注解用于定义基于 Java 类的配置方式，是 Spring 推荐的配置风格。</p><ul><li><p><strong><code>@Configuration</code></strong></p><ul><li><strong>功能与目的：</strong> 标识一个类为 Spring 的配置类。该类通常包含用 <code>@Bean</code> 标注的方法，用于定义 Bean。</li><li><strong>使用场景与示例：</strong><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">&quot;com.example.service&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 扫描 service 包下的组件</span>
<span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span><span class="token string">&quot;classpath:application.properties&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 加载属性文件</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Bean</span> <span class="token comment">// 定义一个 Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">UserService</span> <span class="token function">userService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span> <span class="token comment">// Bean 之间可以直接调用方法来表达依赖</span>
    <span class="token keyword">public</span> <span class="token class-name">UserController</span> <span class="token function">userController</span><span class="token punctuation">(</span><span class="token class-name">UserService</span> userService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">UserController</span> controller <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        controller<span class="token punctuation">.</span><span class="token function">setUserService</span><span class="token punctuation">(</span>userService<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> controller<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>@Configuration</code> 类会被 Spring 进行增强（CGLIB 代理）。当你在一个 <code>@Configuration</code> 类中调用另一个 <code>@Bean</code> 方法时（如上面 <code>userController</code> 方法中调用 <code>userService()</code>），实际调用的是代理对象的方法。代理对象会拦截这个调用，并从容器的 Bean 缓存中查找或创建 <code>userService</code> 单例 Bean，而不是每次都执行 <code>userService()</code> 方法创建新的实例。这就是 <code>@Configuration</code> 的 <strong>Full 模式</strong>。如果 <code>@Configuration</code> 没有被 Spring 代理（例如直接作为普通类通过 <code>@Import</code> 导入，或者 <code>proxyBeanMethods = false</code>），则处于 <strong>Lite 模式</strong>，此时内部调用 <code>@Bean</code> 方法会直接执行方法体，每次返回新实例。</li><li><strong>给开发者的建议：</strong> 通常情况下保持 <code>@Configuration</code> 的 Full 模式（默认行为），这保证了 <code>@Bean</code> 方法之间调用时的单例语义。只有在明确不需要这种特性且追求极致启动速度时，才考虑 Lite 模式。</li><li><strong>面试关联：</strong> “<code>@Configuration</code> 注解有什么特殊之处？” “<code>@Configuration</code> 的 Full 模式和 Lite 模式有什么区别？” “为什么在 <code>@Configuration</code> 类中调用 <code>@Bean</code> 方法不会创建多个实例？” 理解 <code>@Configuration</code> 的 CGLIB 代理和其如何保证单例语义是核心考点。</li></ul></li><li><p><strong><code>@Bean</code></strong></p><ul><li><strong>功能与目的：</strong> 标注在 <code>@Configuration</code> 类的方法上，表示该方法的返回值应该被注册为 Spring 容器中的一个 Bean。方法名默认作为 Bean 的名称。</li><li><strong>使用场景与示例：</strong> 用于配置第三方库的对象，或者一些复杂的对象的创建过程。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataSourceConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;myDataSource&quot;</span><span class="token punctuation">,</span> initMethod <span class="token operator">=</span> <span class="token string">&quot;init&quot;</span><span class="token punctuation">,</span> destroyMethod <span class="token operator">=</span> <span class="token string">&quot;close&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 指定 Bean 名称和生命周期方法</span>
    <span class="token keyword">public</span> <span class="token class-name">DataSource</span> <span class="token function">dataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 配置并返回 DataSource 实例</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyCustomDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> Spring 在解析 <code>@Configuration</code> 类时，会找到所有 <code>@Bean</code> 方法，并为它们的返回值创建 <code>BeanDefinition</code>。<code>name</code> 属性可以指定 Bean 的名称。<code>initMethod</code> 和 <code>destroyMethod</code> 属性指定的方法名会被存储在 <code>BeanDefinition</code> 中，并在 Bean 的生命周期对应阶段被调用（关联 Bean 生命周期文章）。</li><li><strong>面试关联：</strong> “如何在 Java Config 中定义一个 Bean？” 回答 <code>@Bean</code>。 “如何指定 <code>@Bean</code> 的名称或生命周期方法？” 回答 <code>@Bean</code> 的属性。</li></ul></li><li><p><strong><code>@ComponentScan</code></strong></p><ul><li><strong>功能与目的：</strong> 开启 Spring 的组件扫描功能，用于自动查找和注册带有 <code>@Component</code> 或其派生注解的类作为 Bean。</li><li><strong>使用场景与示例：</strong> 通常应用于 <code>@Configuration</code> 类上，指定需要扫描的基础包。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;com.example.service&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;com.example.controller&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 扫描多个包</span>
<span class="token comment">// @ComponentScan(basePackageClasses = AppConfig.class) // 或者指定一个类的包作为扫描基础包</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> Spring 容器启动时，会处理 <code>@ComponentScan</code> 注解，根据其属性确定扫描范围。然后在指定的包下查找符合条件的类（带有 <code>@Component</code> 等注解），并为这些类创建并注册 <code>BeanDefinition</code>。这是实现依赖注入“自动化”的第一步。</li><li><strong>面试关联：</strong> “Spring 是如何自动发现并注册 Bean 的？” 回答 <code>@ComponentScan</code> 和 <code>@Component</code> 及其派生注解，说明扫描过程。</li></ul></li><li><p><strong><code>@Import</code></strong></p><ul><li><strong>功能与目的：</strong> 将一个或多个 <code>@Configuration</code> 类、普通的类（作为 Bean）、<code>ImportSelector</code> 或 <code>ImportBeanDefinitionRegistrar</code> 导入到当前的 <code>@Configuration</code> 类中。</li><li><strong>使用场景与示例：</strong> 组织模块化的配置，或者通过编程方式动态注册 Bean。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ServiceConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">DaoConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">MyRegistrar</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 导入其他配置类或 Registrar</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RootConfig</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> Spring 在处理 <code>@Configuration</code> 类时，如果遇到 <code>@Import</code>，会递归地处理被导入的类。如果是 <code>@Configuration</code> 类，则继续解析其内部的 <code>@Bean</code> 方法和 <code>@ComponentScan</code> 等。如果是普通类，则将其注册为 Bean。<code>ImportSelector</code> 和 <code>ImportBeanDefinitionRegistrar</code> 是更高级的扩展点，允许根据条件或编程逻辑动态决定需要导入哪些 Bean 定义。</li><li><strong>面试关联：</strong> “如何在 Java Config 中组合多个配置类？” 回答 <code>@Import</code>，并可以提及它导入不同类型对象的能力。</li></ul></li></ul><h4 id="_2-3-aop-相关注解" tabindex="-1"><a class="header-anchor" href="#_2-3-aop-相关注解"><span>2.3 AOP 相关注解</span></a></h4><p>这些注解用于在代码中定义切面，实现面向切面编程。</p><ul><li><p><strong><code>@EnableAspectJAutoProxy</code></strong></p><ul><li><strong>功能与目的：</strong> 激活基于 AspectJ 的 <code>@Aspect</code> 注解的 AOP 支持。Spring 会自动为符合条件的 Bean 创建代理。</li><li><strong>使用场景与示例：</strong> 应用于 <code>@Configuration</code> 类上。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@EnableAspectJAutoProxy</span> <span class="token comment">// 开启 AOP 自动代理</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AopConfig</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>@EnableAspectJAutoProxy</code> 会向 Spring 容器中注册一个重要的 BeanPostProcessor：<code>AnnotationAwareAspectJAutoProxyCreator</code>。这个后置处理器负责扫描容器中的 Bean，查找带有 <code>@Aspect</code> 注解的类（切面），解析切面中的切点 (<code>@Pointcut</code>) 和通知 (<code>@Before</code>, <code>@Around</code> 等)。然后，它会在 Bean 的生命周期中（<code>postProcessAfterInitialization</code> 阶段），判断哪些业务 Bean 需要被这些切面“织入”增强。如果需要，它会为这些业务 Bean 创建代理对象（使用 JDK 动态代理或 CGLIB ），并返回代理对象。</li><li><strong>面试关联：</strong> “如何在 Spring 中启用基于注解的 AOP？” 回答 <code>@EnableAspectJAutoProxy</code>。 “Spring AOP 的实现原理是什么？” 回答 <code>@EnableAspectJAutoProxy</code> 注册的 BeanPostProcessor，它在 Bean 生命周期中创建代理对象（关联代理模式和 Bean 生命周期）。</li></ul></li><li><p><strong><code>@Aspect</code>, <code>@Pointcut</code>, 通知注解 (<code>@Before</code>, <code>@AfterReturning</code>, <code>@AfterThrowing</code>, <code>@After</code>, <code>@Around</code>)</strong></p><ul><li><strong>功能与目的：</strong> 组合使用来定义一个切面。<code>@Aspect</code> 标识一个类是切面。<code>@Pointcut</code> 定义切点，即在哪些连接点（Joinpoint，如方法执行）应用通知。通知注解定义在切面方法上，指定在切点匹配的连接点上执行的增强逻辑以及执行时机。</li><li><strong>使用场景与示例：</strong><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Aspect</span> <span class="token comment">// 标识这是一个切面</span>
<span class="token annotation punctuation">@Component</span> <span class="token comment">// 将切面类也注册为 Bean</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingAspect</span> <span class="token punctuation">{</span>

    <span class="token comment">// 定义一个切点：匹配 com.example.service 包下所有类的所有公共方法</span>
    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">&quot;execution(public * com.example.service.*.*(..))&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">serviceMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">&quot;serviceMethods()&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 在 serviceMethods 切点匹配的方法执行前执行</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logBefore</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Executing: &quot;</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span>pointcut <span class="token operator">=</span> <span class="token string">&quot;serviceMethods()&quot;</span><span class="token punctuation">,</span> returning <span class="token operator">=</span> <span class="token string">&quot;result&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 在 serviceMethods 切点匹配的方法成功返回后执行</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logAfterReturning</span><span class="token punctuation">(</span><span class="token class-name">Object</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Method returned: &quot;</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">&quot;serviceMethods()&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 环绕通知，可以完全控制方法的执行</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">logAround</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Around before: &quot;</span> <span class="token operator">+</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行目标方法</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Around after: &quot;</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ... 其他通知类型 @AfterThrowing, @After</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>@Aspect</code> 类被 <code>AnnotationAwareAspectJAutoProxyCreator</code> 识别后，其内部的 <code>@Pointcut</code> 定义会被解析为切点表达式，通知方法会被包装成相应的通知（Advice）对象。当需要为业务 Bean 创建代理时，这些切点和通知会被织入到代理逻辑中。</li><li><strong>给开发者的建议：</strong> <code>@Around</code> 通知功能最强大，但也最容易出错，因为它完全控制了目标方法的调用，需要小心处理 <code>proceed()</code> 调用和返回值/异常。对于简单的前置/后置处理，优先使用 <code>@Before</code>, <code>@AfterReturning</code>, <code>@AfterThrowing</code>, <code>@After</code>。</li><li><strong>面试关联：</strong> “Spring AOP 有哪些通知类型？它们的执行顺序是什么？” “如何定义一个切点？” 熟练使用这些注解并理解不同通知类型的执行时机是基础。</li></ul></li></ul><h4 id="_2-4-事务管理注解" tabindex="-1"><a class="header-anchor" href="#_2-4-事务管理注解"><span>2.4 事务管理注解</span></a></h4><p>这些注解用于声明式事务管理，极大地简化了事务边界的控制。</p><ul><li><p><strong><code>@EnableTransactionManagement</code></strong></p><ul><li><strong>功能与目的：</strong> 激活 Spring 的声明式事务管理功能，通常配合 <code>@Transactional</code> 使用。</li><li><strong>使用场景与示例：</strong> 应用于 <code>@Configuration</code> 类上。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@EnableTransactionManagement</span> <span class="token comment">// 启用事务管理</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionConfig</span> <span class="token punctuation">{</span>
    <span class="token comment">// ... 配置 DataSource 和 PlatformTransactionManager Bean</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>@EnableTransactionManagement</code> 会导入 Spring 事务模块所需的关键 Bean，其中最重要的是一个用于处理 <code>@Transactional</code> 注解的 <strong>AOP 切面或 Advisor</strong>。这个 Advisor 也是一个 BeanPostProcessor，它会为带有 <code>@Transactional</code> 注解的类或方法所在的 Bean 创建事务代理。</li><li><strong>面试关联：</strong> “如何在 Spring 中启用声明式事务？” 回答 <code>@EnableTransactionManagement</code> 和 <code>@Transactional</code>。</li></ul></li><li><p><strong><code>@Transactional</code></strong></p><ul><li><strong>功能与目的：</strong> 应用于类或方法上，声明该类中所有公共方法或该方法需要在事务环境中执行。Spring 会在这些方法执行前开启事务，执行后根据情况提交或回滚事务。</li><li><strong>使用场景与示例：</strong> 应用于 Service 层的方法是常见做法。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccountService</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Transactional</span> <span class="token comment">// 整个方法将在一个事务中执行</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Long</span> fromUserId<span class="token punctuation">,</span> <span class="token class-name">Long</span> toUserId<span class="token punctuation">,</span> <span class="token class-name">BigDecimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 扣款操作</span>
        userRepository<span class="token punctuation">.</span><span class="token function">decreaseBalance</span><span class="token punctuation">(</span>fromUserId<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 转入操作</span>
        userRepository<span class="token punctuation">.</span><span class="token function">increaseBalance</span><span class="token punctuation">(</span>toUserId<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果上面任何一步抛出运行时异常，事务会自动回滚</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>readOnly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">SUPPORTS</span><span class="token punctuation">)</span> <span class="token comment">// 只读事务，支持当前事务（非强制）</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">findUserById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 查询操作</span>
        <span class="token keyword">return</span> userRepository<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRES_NEW</span><span class="token punctuation">,</span> rollbackFor <span class="token operator">=</span> <span class="token class-name">CustomException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 新事务，只对 CustomException 回滚</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createUserAndLog</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CustomException</span> <span class="token punctuation">{</span>
        userRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
           logService<span class="token punctuation">.</span><span class="token function">logOperation</span><span class="token punctuation">(</span><span class="token string">&quot;Create User&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 如果 logService 抛出其他异常，这个事务仍然提交，只对 CustomException 回滚</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">CustomException</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token punctuation">(</span><span class="token class-name">CustomException</span><span class="token punctuation">)</span>e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>@Transactional</code> 是通过 <strong>AOP 代理</strong>实现的。如上所述，当一个 Bean 被 <code>@Transactional</code> 标注时，Spring 的事务 AOP 切面会为其创建一个代理对象。客户端调用方法时，实际上是调用代理对象的方法。代理对象在调用目标方法前后，会根据 <code>@Transactional</code> 注解的属性（如 <code>propagation</code>, <code>isolation</code>, <code>readOnly</code>, <code>rollbackFor</code> 等），通过配置的 <code>PlatformTransactionManager</code> 来开启、管理、提交或回滚事务。 <ul><li><strong>核心属性解析 (面试重点)：</strong><ul><li><code>propagation</code> (传播行为)：定义了事务方法在调用另一个事务方法时如何相互作用。常见的有 <code>REQUIRED</code> (默认，支持当前事务，没有则新建), <code>REQUIRES_NEW</code> (总是开启新事务), <code>SUPPORTS</code> (支持当前事务，没有则非事务运行), <code>NOT_SUPPORTED</code> (总是非事务运行), <code>NEVER</code> (不能在事务中运行), <code>MANDATORY</code> (必须在事务中运行), <code>NESTED</code> (嵌套事务)。理解 REQUIRED 和 REQUIRES_NEW 的区别是高频考点。</li><li><code>isolation</code> (隔离级别)：定义一个事务可能受其他并发事务影响的程度。常见的有 <code>DEFAULT</code> (使用数据库默认), <code>READ_UNCOMMITTED</code>, <code>READ_COMMITTED</code>, <code>REPEATABLE_READ</code>, <code>SERIALIZABLE</code>。</li><li><code>readOnly</code>：如果为 <code>true</code>，表示这是一个只读事务，有助于数据库进行优化。</li><li><code>rollbackFor</code>/<code>noRollbackFor</code>：指定遇到哪些异常需要/不需要回滚。默认只对运行时异常 (RuntimeException及其子类) 和 Error 回滚。</li></ul></li></ul></li><li><strong>给开发者的建议：</strong> 优先应用于 Service 层的方法上，因为它通常是业务逻辑的边界。理解并合理设置 <code>propagation</code> 和 <code>rollbackFor</code> 是避免事务陷阱的关键。注意 <code>@Transactional</code> 应用于类上时，只对其公共方法生效；应用于方法上则只对该方法生效。同一个类内部方法互相调用，如果通过 <code>this</code> 调用，事务注解可能失效（因为绕过了代理对象），需要注入自身代理对象来解决。</li><li><strong>面试关联：</strong> “<code>@Transactional</code> 注解如何使用？有哪些常用属性？请解释事务传播行为。” “<code>@Transactional</code> 注解失效的场景有哪些？如何解决？” 这是关于 Spring 事务管理的核心面试题，务必熟练掌握。</li></ul></li></ul><h4 id="_2-5-生命周期相关注解-jsr-250标准-spring支持" tabindex="-1"><a class="header-anchor" href="#_2-5-生命周期相关注解-jsr-250标准-spring支持"><span>2.5 生命周期相关注解 (JSR-250标准，Spring支持)</span></a></h4><p>这些注解不是 Spring 独有的，而是 JSR-250 (Common Annotations for the Java TM Platform) 标准的一部分，但 Spring 完全支持它们，并将其集成到 Bean 的生命周期中。</p><ul><li><p><strong><code>@PostConstruct</code></strong></p><ul><li><strong>功能与目的：</strong> 标注在 Bean 的某个方法上，表示该方法在 Bean 的所有属性被设置完毕后，以及 Bean 实现了任何 Spring 特定的初始化接口（如 <code>InitializingBean</code>）或自定义 <code>init-method</code> <strong>之前</strong>被调用。通常用于执行 Bean 初始化后的清理/准备工作，例如资源加载、缓存初始化等。</li><li><strong>使用场景与示例：</strong><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Config</span> config<span class="token punctuation">;</span> <span class="token comment">// 已通过 @Autowired 注入</span>

    <span class="token annotation punctuation">@PostConstruct</span> <span class="token comment">// 在 config 被注入后执行</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用 config 进行初始化操作，如加载数据到缓存</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;MyService is initializing with config: &quot;</span> <span class="token operator">+</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>@PostConstruct</code> 注解由 Spring 内置的 <strong><code>CommonAnnotationBeanPostProcessor</code></strong> 处理。这是一个 BeanPostProcessor，它在 Bean 的生命周期中的初始化阶段，会查找带有 <code>@PostConstruct</code> 注解的方法并执行它们。它的执行顺序在 BeanPostProcessor 的 <code>postProcessBeforeInitialization</code> 之后，用户自定义初始化方法（<code>InitializingBean.afterPropertiesSet()</code> 和 <code>init-method</code>）之前。</li><li><strong>给开发者的建议：</strong> <code>@PostConstruct</code> 是执行 Bean 初始化逻辑的最推荐方式，因为它基于标准注解，与 Spring 耦合度低。</li><li><strong>面试关联：</strong> “Spring Bean 的初始化阶段有哪些回调方式？它们的执行顺序是怎样的？” 回答 <code>@PostConstruct</code>，<code>InitializingBean.afterPropertiesSet()</code>，<code>init-method</code>，并说明 <code>@PostConstruct</code> 的执行时机（关联 Bean 生命周期文章）。“<code>@PostConstruct</code> 注解的作用是什么？它与 <code>init-method</code> 有什么区别？”</li></ul></li><li><p><strong><code>@PreDestroy</code></strong></p><ul><li><strong>功能与目的：</strong> 标注在 Bean 的某个方法上，表示该方法在 Bean 被销毁之前被调用（仅对单例 Bean 有效）。通常用于执行 Bean 关闭前的清理工作，例如释放资源、关闭连接等。</li><li><strong>使用场景与示例：</strong><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyResource</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Connection</span> connection<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@PostConstruct</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 建立连接</span>
        connection <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@PreDestroy</span> <span class="token comment">// 在 Bean 销毁前关闭连接</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>connection <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>@PreDestroy</code> 也由 <code>CommonAnnotationBeanPostProcessor</code> 处理。它在 Spring 容器关闭时，对于注册的单例 Bean，会查找并执行带有 <code>@PreDestroy</code> 注解的方法。它的执行顺序在用户自定义销毁方法（<code>DisposableBean.destroy()</code> 和 <code>destroy-method</code>）之前。注意，原型 (Prototype) 作用域的 Bean，Spring 不管理其销毁，<code>@PreDestroy</code> 不会对其生效。</li><li><strong>给开发者的建议：</strong> <code>@PreDestroy</code> 是执行 Bean 销毁前清理逻辑的最推荐方式，原因同 <code>@PostConstruct</code>。</li><li><strong>面试关联：</strong> “Spring Bean 的销毁阶段有哪些回调方式？它们的执行顺序是怎样的？” 回答 <code>@PreDestroy</code>，<code>DisposableBean.destroy()</code>，<code>destroy-method</code>，并说明 <code>@PreDestroy</code> 的执行时机（关联 Bean 生命周期文章）。提及原型 Bean 的销毁不受 Spring 管理。</li></ul></li></ul><h4 id="_2-6-环境与profile相关注解" tabindex="-1"><a class="header-anchor" href="#_2-6-环境与profile相关注解"><span>2.6 环境与Profile相关注解</span></a></h4><p>这些注解提供了基于不同环境（开发、测试、生产等）和外部属性进行条件化配置的能力。</p><ul><li><p><strong><code>@Profile</code></strong></p><ul><li><strong>功能与目的：</strong> 条件化地注册 Bean 或 <code>@Configuration</code> 类。只有当指定的 profile 被激活时，被 <code>@Profile</code> 标注的 Bean 或配置类才会被注册到容器中。</li><li><strong>使用场景与示例：</strong> 根据不同的部署环境使用不同的数据库配置、外部服务连接等。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// Dev 环境下的 DataSource 配置</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@Profile</span><span class="token punctuation">(</span><span class="token string">&quot;dev&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 只在 &quot;dev&quot; profile 激活时生效</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DevDataSourceConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span> <span class="token class-name">DataSource</span> <span class="token function">dataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Prod 环境下的 DataSource 配置</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@Profile</span><span class="token punctuation">(</span><span class="token string">&quot;prod&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 只在 &quot;prod&quot; profile 激活时生效</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProdDataSourceConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span> <span class="token class-name">DataSource</span> <span class="token function">dataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@Profile</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;dev&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 在 &quot;dev&quot; 或 &quot;test&quot; profile 激活时生效</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MockEmailService</span> <span class="token keyword">implements</span> <span class="token class-name">EmailService</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>@Profile</code> 信息被存储在 <code>BeanDefinition</code> 中。Spring 容器在加载和处理 <code>BeanDefinition</code> 时，会检查当前激活的 profile (<code>Environment.getActiveProfiles()</code>) 是否与 <code>@Profile</code> 指定的 profile 匹配。只有匹配的 <code>BeanDefinition</code> 才会被保留并用于后续的 Bean 创建过程。</li><li><strong>给开发者的建议：</strong> 合理利用 <code>@Profile</code> 可以使不同环境的配置和 Bean 管理变得非常清晰和灵活。可以通过启动参数 (<code>-Dspring.profiles.active=dev</code>) 或环境变量等方式激活 profile。</li><li><strong>面试关联：</strong> “如何在 Spring 中实现不同环境的配置切换？” 回答 <code>@Profile</code>，并说明其作用和如何激活 profile。</li></ul></li><li><p><strong><code>@PropertySource</code></strong></p><ul><li><strong>功能与目的：</strong> 将指定的属性文件（如 <code>.properties</code> 文件）加载到 Spring 的 <code>Environment</code> 中，使得可以通过 <code>@Value</code> 或 <code>Environment</code> 对象访问其中的属性。</li><li><strong>使用场景与示例：</strong> 加载自定义的配置文件。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span><span class="token string">&quot;classpath:custom.properties&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 加载 classpath 下的 custom.properties</span>
<span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;file:/opt/config/app.properties&quot;</span><span class="token punctuation">,</span> ignoreResourceNotFound <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 尝试加载外部文件，找不到不报错</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
    <span class="token comment">// ... 现在可以通过 @Value(&quot;${some.custom.property}&quot;) 访问 custom.properties 中的属性</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>@PropertySource</code> 注解由 Spring 内置的 <strong><code>ConfigurationClassPostProcessor</code></strong> (一个 BeanFactoryPostProcessor) 处理。它在 BeanDefinition 加载完成后，Bean 实例化之前，解析 <code>@PropertySource</code> 注解指定的资源位置，加载属性文件，并将这些属性源添加到容器的 <code>Environment</code> 对象中。</li><li><strong>面试关联：</strong> “如何在 Spring 中加载外部属性文件？” 回答 <code>@PropertySource</code> 和 <code>@Value</code>。</li></ul></li><li><p><strong><code>@Autowired Environment</code></strong></p><ul><li><strong>功能与目的：</strong> 通过 <code>@Autowired</code> 将 Spring 的 <code>Environment</code> 对象注入到 Bean 中，允许以编程方式访问属性和当前激活的 profile。</li><li><strong>使用场景与示例：</strong> 需要在代码中根据 profile 或属性值进行不同的逻辑判断。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FeatureToggler</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">Environment</span> env<span class="token punctuation">;</span> <span class="token comment">// 注入 Environment 对象</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">performAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 检查当前激活的 profile</span>
        <span class="token keyword">boolean</span> isProd <span class="token operator">=</span> env<span class="token punctuation">.</span><span class="token function">acceptsProfiles</span><span class="token punctuation">(</span><span class="token class-name">Profiles</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">&quot;prod&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取属性值</span>
        <span class="token class-name">String</span> featureFlag <span class="token operator">=</span> env<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">&quot;feature.enabled&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;false&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第二个参数是默认值</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>isProd <span class="token operator">&amp;&amp;</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>featureFlag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 在生产环境且功能开启时执行逻辑</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Executing feature in production.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Feature is disabled or not in production.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>背后原理浅析：</strong> <code>Environment</code> 对象本身就是一个 Bean 注册到容器中，通过 <code>@Autowired</code> 即可像注入普通 Bean 一样注入它。</li><li><strong>面试关联：</strong> “如何在 Spring 中获取当前激活的 profile？”或“如何在 Bean 中以编程方式获取属性值？” 回答注入 <code>Environment</code> 对象。</li></ul></li></ul><h4 id="_2-7-spring-mvc-web-相关注解-简要提及" tabindex="-1"><a class="header-anchor" href="#_2-7-spring-mvc-web-相关注解-简要提及"><span>2.7 Spring MVC/Web 相关注解 (简要提及)</span></a></h4><p>这些注解主要用于构建 Web 层，虽然种类繁多，但核心思想也是通过注解简化 Web 请求的处理配置。</p><ul><li><strong><code>@RestController</code>:</strong> 复合注解，等同于 <code>@Controller</code> + <code>@ResponseBody</code>。标识这是一个用于构建 RESTful Web 服务的控制器，方法的返回值会直接作为响应体，而不是跳转视图。</li><li><strong><code>@RequestMapping</code> 及派生注解 (<code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, <code>@PatchMapping</code>)</strong>: 映射 Web 请求到特定的处理器方法。派生注解是 <code>@RequestMapping</code> 的便捷变体，用于指定 HTTP 方法。</li><li><strong><code>@RequestBody</code></strong>: 标注在方法参数上，表示将 HTTP 请求体的内容绑定到该参数，通常用于接收 JSON 或 XML 数据。</li><li><strong><code>@ResponseBody</code></strong>: 标注在方法上或类上（通过 <code>@RestController</code>），表示该方法的返回值直接作为 HTTP 响应体，而不是通过视图解析器处理。</li><li><strong><code>@RequestParam</code></strong>: 标注在方法参数上，用于获取请求参数（Query Parameter）。</li><li><strong><code>@PathVariable</code></strong>: 标注在方法参数上，用于获取 URL 路径中的变量。</li></ul><p>这些注解的应用原理通常涉及 Spring MVC 的 <code>DispatcherServlet</code>、各种 HandlerMapping、HandlerAdapter、ArgumentResolver 等组件，它们读取这些注解信息来确定如何处理请求、调用哪个方法、以及如何解析参数和处理返回值。虽然具体机制不同于 IoC 容器的 BeanPostProcessor，但它们同样体现了 Spring 通过注解驱动行为的设计思想。</p><h3 id="注解的使用建议与思考" tabindex="-1"><a class="header-anchor" href="#注解的使用建议与思考"><span>注解的使用建议与思考</span></a></h3><ul><li><strong>注解 vs XML：</strong> 注解使得配置更加分散（与代码混在一起），XML 配置则更加集中。对于大型项目或需要频繁变动的配置，集中式的 XML 可能有其优势。但总体而言，注解因其便捷性和与代码的紧密性，已成为主流。</li><li><strong>过度使用：</strong> 虽然注解很方便，但也应避免在所有地方都使用 Spring 特定的注解，特别是那些与核心业务逻辑无关的类。这可能会增加代码与 Spring 框架的耦合度，不利于在非 Spring 环境下复用或单元测试。遵循“配置类使用配置注解，业务组件使用少量核心注解（如<code>@Service</code>, <code>@Autowired</code>）”的原则。</li><li><strong>统一风格：</strong> 在团队内部统一使用注解（如 <code>@Autowired</code> 统一使用构造器注入），或者统一使用 XML，或者混合使用时明确边界，避免配置方式混乱。</li></ul><h3 id="注解如何助你理解spring和应对面试" tabindex="-1"><a class="header-anchor" href="#注解如何助你理解spring和应对面试"><span>注解如何助你理解Spring和应对面试</span></a></h3><p>理解这些常用注解及其背后的原理，是成为一名优秀 Spring 开发者的必经之路，也是通过 Spring 高阶面试的敲门砖。面试官通过考察你对注解的理解，能够判断：</p><ul><li><strong>你对 Spring 核心功能的掌握程度：</strong> 你是否知道如何使用 <code>@Autowired</code>、<code>@Transactional</code> 等核心功能？</li><li><strong>你对 Spring 内部机制的理解深度：</strong> 你是否知道 <code>@Autowired</code>、<code>@PostConstruct</code>、<code>@Transactional</code> 等是如何被 Spring 容器识别并处理的？是否知道 BeanPostProcessor 的作用？是否理解 AOP 代理和 <code>@Transactional</code> 的关系？是否理解 <code>@Configuration</code> 的特殊处理？</li><li><strong>你的实战经验和问题解决能力：</strong> 你是否知道如何解决 <code>@Autowired</code> 冲突、事务失效等实际问题？</li><li><strong>你对最佳实践的了解：</strong> 你是否知道 <code>@Autowired</code> 不同注入方式的优劣？</li></ul><p><strong>面试常考问题示例（再次强调与注解的关联）：</strong></p><ul><li><code>@Autowired</code> 的注入方式？原理？如何解决冲突？ (<code>@Autowired</code>, <code>AutowiredAnnotationBeanPostProcessor</code>, <code>@Qualifier</code>, <code>@Primary</code>)</li><li><code>@Component</code> 和 <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 的区别？ (<code>@Component</code> 派生，扫描)</li><li><code>@Transactional</code> 如何使用？属性？传播行为？失效场景？原理？ (<code>@Transactional</code>, <code>@EnableTransactionManagement</code>, AOP 代理，属性解析)</li><li>Spring Bean 的生命周期回调注解？顺序？ (<code>@PostConstruct</code>, <code>@PreDestroy</code>, <code>CommonAnnotationBeanPostProcessor</code>, Bean 生命周期)</li><li>JavaConfig 中 <code>@Configuration</code> 和 <code>@Bean</code> 的作用？ <code>@Configuration</code> 的特殊处理？ (<code>@Configuration</code>, <code>@Bean</code>, CGLIB 代理)</li><li>如何实现条件化 Bean 配置？ (<code>@Profile</code>)</li><li>如何启用注解驱动的 AOP 或事务？ (<code>@EnableAspectJAutoProxy</code>, <code>@EnableTransactionManagement</code>, BeanPostProcessor)</li></ul><p>当你能清晰地结合注解、底层原理（如 BeanPostProcessor）和 Spring 机制来回答这些问题时，无疑能展现出你的技术深度和实力。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>Spring 注解极大地提升了 Java 企业级应用的开发效率和代码的可读性。从 IoC 容器的核心注解（<code>@Autowired</code>, <code>@Component</code> 等）到配置类注解（<code>@Configuration</code>, <code>@Bean</code>），再到 AOP、事务、生命周期和环境相关的注解，它们覆盖了 Spring 框架的方方面面。</p><p>会使用这些注解是 Spring 开发者的基本功，但理解其<strong>背后原理</strong>，知道 Spring 如何通过 <strong>BeanPostProcessor</strong> 等扩展点识别和处理这些注解，理解它们触发的 <strong>Bean 生命周期回调</strong>、<strong>AOP 代理</strong>、<strong>事务管理</strong>等机制，才是真正掌握 Spring 的标志。</p></div><!--[--><!----><!--]--><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a href="https://github.com/vuepress-theme-hope/vuepress-theme-hope/edit/main/src/spring/spring-annotation.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link vp-meta-label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><!----></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: oointer@163.com">Yideng</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link nav-link prev" href="/javabaguwen/spring/spring-design.html" aria-label="Spring用到哪些设计模式"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->Spring用到哪些设计模式</div></a><a class="route-link nav-link next" href="/javabaguwen/spring/spring-transaction.html" aria-label="Spring事务"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">Spring事务<!----></div></a></nav><div id="vp-comment" class="giscus-wrapper input-top" style="display:block;"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" preserveAspectRatio="xMidYMid" viewBox="0 0 100 100"><circle cx="28" cy="75" r="11" fill="currentColor"><animate attributeName="fill-opacity" begin="0s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></circle><path fill="none" stroke="#88baf0" stroke-width="10" d="M28 47a28 28 0 0 1 28 28"><animate attributeName="stroke-opacity" begin="0.1s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></path><path fill="none" stroke="#88baf0" stroke-width="10" d="M28 25a50 50 0 0 1 50 50"><animate attributeName="stroke-opacity" begin="0.2s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></path></svg></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">默认页脚</div><div class="vp-copyright">Copyright © 2025 Mr.Hope </div></footer></div><!--]--><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/javabaguwen/assets/app-CzKZ5RuK.js" defer></script>
  </body>
</html>
