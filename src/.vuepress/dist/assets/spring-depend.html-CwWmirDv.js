import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,e as t,o as s}from"./app-CzKZ5RuK.js";const i={};function r(a,n){return s(),o("div",null,n[0]||(n[0]=[t(`<p>今天我们来聊聊一个既常见又有点让人头疼的问题：Spring框架中的循环依赖。这个问题不仅在实际开发中偶尔会碰到，更是面试官考察你对Spring IoC容器底层机制理解深度的绝佳切入点。</p><p>理解Spring如何处理（以及在什么情况下不处理）循环依赖，是理解Spring Bean生命周期、Bean创建过程以及其内部缓存机制的关键。</p><hr><h2 id="深度解析-spring-循环依赖问题-原理、解决与避坑" tabindex="-1"><a class="header-anchor" href="#深度解析-spring-循环依赖问题-原理、解决与避坑"><span>深度解析 Spring 循环依赖问题：原理、解决与避坑</span></a></h2><h3 id="引言-什么是循环依赖-为何它是个问题" tabindex="-1"><a class="header-anchor" href="#引言-什么是循环依赖-为何它是个问题"><span>引言：什么是循环依赖，为何它是个问题？</span></a></h3><p>在软件开发中，依赖是对象之间协作的基础。通常，我们希望依赖关系是单向的，形成一个有向无环图（DAG）。然而，在复杂的系统中，我们有时会不小心引入<strong>循环依赖</strong>：</p><ul><li>Bean A 依赖于 Bean B</li><li>Bean B 又依赖于 Bean A</li></ul><p>最直接的例子就是：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceA</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">ServiceB</span> serviceB<span class="token punctuation">;</span> <span class="token comment">// A 依赖 B</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceB</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">ServiceA</span> serviceA<span class="token punctuation">;</span> <span class="token comment">// B 依赖 A</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，为什么循环依赖在传统的对象创建过程中是个问题呢？</p><h3 id="ioc-容器为何-惧怕-循环依赖" tabindex="-1"><a class="header-anchor" href="#ioc-容器为何-惧怕-循环依赖"><span>IoC 容器为何“惧怕”循环依赖？</span></a></h3><p>我们回顾一下 Spring Bean 的标准创建流程（简化版，聚焦与依赖相关的阶段）：</p><ol><li><strong>实例化 (Instantiation)：</strong> Spring 容器找到 Bean A 的 <code>BeanDefinition</code>，通过反射调用构造器创建 Bean A 的原始实例（一个“空壳”对象）。</li><li><strong>属性填充 (Populate Properties)：</strong> Spring 容器根据 Bean A 的 <code>BeanDefinition</code> 中的属性信息，为 Bean A 的属性注入依赖。此时，容器发现 Bean A 需要注入 Bean B。</li><li><strong>依赖解析：</strong> 为了注入 Bean B，Spring 容器需要先创建 Bean B。于是，容器会暂停创建 Bean A 的过程，转而去创建 Bean B。</li><li><strong>创建 Bean B：</strong> 重复步骤 1 和 2： <ul><li>实例化 Bean B，创建 Bean B 的原始实例。</li><li>属性填充 Bean B。此时，容器发现 Bean B 需要注入 Bean A。</li></ul></li><li><strong>再次依赖解析：</strong> 为了注入 Bean A，Spring 容器需要先创建 Bean A。但是，此时 Bean A 正在第 2 步等待 Bean B 的创建！</li></ol><p>这就形成了一个死锁：A 等待 B，B 等待 A。如果没有特殊的处理机制，这个过程就会无限循环下去，最终导致堆栈溢出或者容器无法启动，并抛出类似 <code>BeanCurrentlyInCreationException</code> 的异常。</p><h3 id="spring-对单例循环依赖的解决方案" tabindex="-1"><a class="header-anchor" href="#spring-对单例循环依赖的解决方案"><span>Spring 对单例循环依赖的解决方案</span></a></h3><p>值得庆幸的是，Spring IoC 容器有能力解决<strong>单例 (Singleton)</strong> Bean 的循环依赖问题。这得益于 Spring 在 Bean 创建过程中引入的<strong>三级缓存</strong>和<strong>早期暴露</strong>机制。</p><p>Spring 解决单例循环依赖的核心思想是：在创建单例 Bean 的过程中，不等它完全完成所有步骤（实例化、属性填充、初始化），就提前将一个**“半成品”**的 Bean 实例暴露出来，供其他 Bean 引用。当依赖方需要这个 Bean 时，如果发现它正在创建中并且已被早期暴露，就先使用这个半成品，等依赖方自己创建完成后，再回来继续完成这个半成品的创建过程。</p><p>这背后的关键就是 Spring 维护的三个用于存放单例 Bean 的 Map 类型的缓存：</p><ol><li><strong><code>singletonObjects</code> (一级缓存 / 终态缓存)：</strong> 存放<strong>完全创建好且初始化完成</strong>的单例 Bean。这是我们通常 <code>getBean()</code> 直接拿到的最终对象。</li><li><strong><code>earlySingletonObjects</code> (二级缓存 / 早期曝光对象缓存)：</strong> 存放<strong>实例化完成但尚未进行属性填充和初始化</strong>的单例 Bean 实例。这些 Bean 可能已经被 AOP 代理等后置处理器早期处理过，也可能是原始实例。这个 Map 存放的是可以直接提供给其他 Bean 引用的对象（可能是原始对象，也可能是早期代理对象）。</li><li><strong><code>singletonFactories</code> (三级缓存 / 早期曝光对象工厂缓存)：</strong> 存放 Bean 的 <strong>ObjectFactory</strong>。这个 ObjectFactory 是一个匿名内部类，它能生产出早期暴露的 Bean 实例（可能是原始实例，也可能是应用了部分 BeanPostProcessor 的早期代理对象）。这个缓存的目的是为了解决<strong>代理对象在循环依赖中如何被早期暴露</strong>的问题（例如 AOP 代理）。</li></ol><p><strong>Spring 解决单例循环依赖的过程分步解析 (以 A 依赖 B，B 依赖 A 为例)：</strong></p><ol><li>Spring 创建 A：查找 A 的 <code>BeanDefinition</code>。</li><li>实例化 A：通过构造器创建 Bean A 的原始实例 <code>instanceA</code>。此时 <code>instanceA</code> 只是个空壳，属性未填充。</li><li><strong>早期暴露 A (放入三级缓存)：</strong> 将创建一个 <code>ObjectFactory</code>，该工厂能够生产出 <code>instanceA</code> (或其早期代理)，然后将 <code>ObjectFactory</code> 放入 <code>singletonFactories</code> 中。此时 A 的创建过程暂停，等待填充属性。</li><li>Spring 创建 B：查找 B 的 <code>BeanDefinition</code>。</li><li>实例化 B：通过构造器创建 Bean B 的原始实例 <code>instanceB</code>。</li><li>属性填充 B：Spring 发现 Bean B 需要注入 Bean A。容器尝试从缓存中获取 A。</li><li><strong>查找 A (从缓存中获取)：</strong> 容器首先查找一级缓存 <code>singletonObjects</code> (A 未完成，不在)。然后查找二级缓存 <code>earlySingletonObjects</code> (A 尚未暴露到这里)。最后查找三级缓存 <code>singletonFactories</code>。找到 A 对应的 <code>ObjectFactory</code>。</li><li><strong>获取早期 A 实例 (从三级缓存通过工厂获取)：</strong> 调用 <code>ObjectFactory.getObject()</code> 方法。这个工厂会生产出早期曝光的 Bean A 实例。<strong>如果 A 需要被 AOP 代理，并且相关的 BeanPostProcessor 已经准备好在早期创建代理，这里获取到的可能是 Bean A 的早期代理对象，而不是原始实例。</strong> 将获取到的早期 A 实例放入二级缓存 <code>earlySingletonObjects</code> 中，同时从三级缓存 <code>singletonFactories</code> 中移除对应的工厂。</li><li><strong>注入 A 到 B：</strong> 将从二级缓存获取的早期 A 实例注入到 <code>instanceB</code> 的属性中。</li><li>初始化 B：<code>instanceB</code> 完成属性填充后，进行初始化过程（Aware 接口回调，BeanPostProcessor#before，自定义 init 方法，BeanPostProcessor#after）。</li><li>B 创建完成：将完全初始化好的 <code>instanceB</code> 放入一级缓存 <code>singletonObjects</code> 中，同时从二级缓存 <code>earlySingletonObjects</code> 中移除 <code>instanceB</code>。此时 Bean B 可用了。</li><li>回到 A 的创建过程：继续属性填充 A。现在 A 需要注入 B，容器从一级缓存 <code>singletonObjects</code> 中获取已经创建好的 <code>instanceB</code>。</li><li>注入 B 到 A：将 <code>instanceB</code> 注入到 <code>instanceA</code> 的属性中。</li><li>初始化 A：<code>instanceA</code> 完成属性填充后，进行初始化过程。<strong>注意：如果 Bean A 在步骤 8 被早期代理了，这里 Spring 会确保最终放入一级缓存的是完整的代理对象。如果在步骤 8 暴露的是原始实例，但 Bean A 在初始化阶段需要被 AOP 代理，Spring 会在 <code>BeanPostProcessor#postProcessAfterInitialization</code> 阶段创建代理，并用代理对象替换原始对象放入一级缓存。三级缓存的存在，尤其是在有 AOP 场景下早期暴露的是代理还是原始对象，是为了处理复杂的代理织入顺序问题。</strong></li><li>A 创建完成：将完全初始化好的 <code>instanceA</code> (或其最终代理对象) 放入一级缓存 <code>singletonObjects</code> 中，同时从二级缓存 <code>earlySingletonObjects</code> 中移除 <code>instanceA</code>。</li></ol><p>至此，A 和 B 都成功创建并相互引用了。三级缓存的核心作用在于，当检测到循环依赖时，能够提前暴露一个对象工厂，该工厂可以<strong>生产出早期暴露的对象</strong>，打破了创建过程的僵局。二级缓存只是一个临时中转站，用于存放通过三级缓存工厂生产出来的早期对象。</p><h3 id="spring-无法解决循环依赖的场景" tabindex="-1"><a class="header-anchor" href="#spring-无法解决循环依赖的场景"><span>Spring 无法解决循环依赖的场景</span></a></h3><p>虽然 Spring 解决了单例属性注入的循环依赖，但以下场景的循环依赖它是无法解决的：</p><ol><li><p><strong>原型 (Prototype) 作用域的循环依赖：</strong></p><ul><li><strong>原因：</strong> 对于原型 Bean，Spring 不会缓存其创建过程中的任何状态。每次获取原型 Bean 都会是一个全新的实例。当创建 A (prototype) 需要 B (prototype)，转去创建 B (prototype) 又需要 A (prototype) 时，会再次走创建流程，形成无限循环，没有缓存可以打破僵局。</li><li><strong>表现：</strong> 通常会导致 <code>StackOverflowError</code> 或 <code>BeanCurrentlyInCreationException</code>。</li></ul></li><li><p><strong>构造器注入 (Constructor Injection) 的循环依赖：</strong></p><ul><li><strong>原因：</strong> Spring 解决循环依赖的机制依赖于 Bean 在<strong>实例化之后、属性填充之前</strong>将“半成品”放入缓存。而构造器注入的依赖是在<strong>实例化阶段</strong>就需要满足的。当 Spring 尝试实例化 A 并解析其构造器参数 B 时，会立即尝试创建 B；创建 B 实例化并解析其构造器参数 A 时，又会尝试创建 A。此时 A 甚至还没完成实例化，根本没有机会被放入三级缓存进行早期暴露。</li><li><strong>表现：</strong> <code>BeanCurrentlyInCreationException</code>。</li><li><strong>规避方法：</strong> 将循环依赖的注入方式改为 Setter 注入或字段注入；或者在其中一个 Bean 上使用 <code>@Lazy</code> 注解，延迟依赖 Bean 的创建和注入，打破循环；或者从设计上重构，消除循环依赖。</li></ul></li></ol><h3 id="理解循环依赖对开发者的意义" tabindex="-1"><a class="header-anchor" href="#理解循环依赖对开发者的意义"><span>理解循环依赖对开发者的意义</span></a></h3><p>理解 Spring 如何处理循环依赖及其背后的三级缓存机制，不仅仅是为了应对面试，它能帮助我们：</p><ul><li><strong>深入理解 IoC 容器的工作原理：</strong> 这是 Spring 最核心也最复杂的机制之一。</li><li><strong>掌握 Bean 的生命周期细节：</strong> 知道“早期暴露”发生在生命周期的哪个阶段，以及它如何影响后续步骤（特别是 AOP）。</li><li><strong>理解 Spring 缓存的作用：</strong> 明确一级、二级、三级缓存各自的用途。</li><li><strong>排查 BeanCreationException 等问题：</strong> 当出现循环依赖错误时，能够识别原因（是原型？是构造器注入？），并知道如何规避或解决。</li><li><strong>编写更合理的设计：</strong> 意识到循环依赖通常是设计上可以优化的地方，考虑是否可以通过引入第三方服务、监听器或更合理的职责划分来消除循环依赖。</li></ul><h3 id="spring-循环依赖为何是面试热点" tabindex="-1"><a class="header-anchor" href="#spring-循环依赖为何是面试热点"><span>Spring 循环依赖为何是面试热点</span></a></h3><p>这是一个能迅速区分候选人对 Spring 理解深度的问题。面试官通过循环依赖，可以考察：</p><ul><li><strong>你是否了解 Spring Bean 的创建流程和生命周期。</strong></li><li><strong>你是否知道 Spring 如何解决单例循环依赖（三级缓存是关键）。</strong></li><li><strong>你是否理解 Spring 解决循环依赖的限制（原型、构造器注入）。</strong></li><li><strong>你是否理解 Spring 内部缓存机制。</strong></li><li><strong>你是否理解 AOP 在循环依赖场景下的复杂性（早期暴露的是原始对象还是代理）。</strong></li><li><strong>你是否知道如何规避或解决循环依赖问题。</strong></li></ul><h3 id="面试问题示例与深度解析" tabindex="-1"><a class="header-anchor" href="#面试问题示例与深度解析"><span>面试问题示例与深度解析</span></a></h3><p>以下是一些常见的 Spring 循环依赖面试问题，以及结合我们上面内容可以给出的深度回答要点：</p><ol><li><strong>请解释什么是 Spring 的循环依赖？</strong><ul><li><strong>要点：</strong> 定义 A 依赖 B，B 依赖 A 的场景。解释它如何干扰正常的 Bean 创建流程（实例化 -&gt; 属性填充 -&gt; 初始化），导致相互等待。</li></ul></li><li><strong>Spring 如何解决单例 Bean 的循环依赖？请详细解释其原理。</strong><ul><li><strong>要点：</strong> 回答 Spring 通过<strong>三级缓存</strong>和<strong>早期暴露</strong>解决。<strong>详细解释</strong>三级缓存 (<code>singletonObjects</code>, <code>earlySingletonObjects</code>, <code>singletonFactories</code>) 各自的作用。<strong>分步描述</strong> A 和 B 的创建过程中，A 如何实例化后将工厂放入三级缓存，B 如何从三级缓存获取早期 A 实例并注入，然后各自完成后续步骤。这是核心，务必讲清楚三级缓存如何协同工作。</li></ul></li><li><strong>Spring 的三级缓存分别是什么？它们在解决循环依赖中有什么作用？</strong><ul><li><strong>要点：</strong> 明确说出三个 Map 的名称。<code>singletonObjects</code> (终态 Bean)，<code>earlySingletonObjects</code> (早期暴露的 Bean 实例，可能是代理)，<code>singletonFactories</code> (早期暴露 Bean 的工厂)。强调 <code>singletonFactories</code> 存放工厂，这个工厂能够生产早期对象，是打破循环的关键。</li></ul></li><li><strong>Spring 无法解决哪些类型的循环依赖？为什么？</strong><ul><li><strong>要点：</strong> 1) 原型作用域的 Bean，原因：不缓存状态。 2) 构造器注入的循环依赖，原因：依赖需要在实例化前满足，对象还没机会放到三级缓存。</li></ul></li><li><strong>如果我的 Bean 是通过构造器注入导致循环依赖，有什么解决办法？</strong><ul><li><strong>要点：</strong> 1) 改为 Setter 注入或字段注入。 2) 在其中一个 Bean 的依赖字段上使用 <code>@Lazy</code> 注解。 3) 重构代码设计，消除循环依赖。</li></ul></li><li><strong>在有 AOP 的情况下，Spring 如何处理循环依赖？早期暴露的是原始对象还是代理对象？</strong><ul><li><strong>要点：</strong> 解释三级缓存尤其重要。在获取早期 A 实例时 (步骤 8)，如果 A 需要被代理，三级缓存中的 ObjectFactory 可能会根据需要提前应用 AOP 代理，早期暴露的是<strong>代理对象</strong>。这是为了确保 B 注入的是代理对象，从而使得 B 调用 A 的方法时能触发 A 的 AOP 逻辑。最终放入一级缓存的也是完整的代理对象。 (这是一个加分项，体现对 AOP 与循环依赖结合的理解)。</li></ul></li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>循环依赖是 Spring IoC 容器在管理 Bean 依赖关系时可能遇到的复杂问题。Spring 通过其巧妙设计的三级缓存和早期暴露机制，成功解决了<strong>单例 Bean 之间通过 Setter 或字段注入</strong>导致的循环依赖。</p><p>理解这个解决方案的核心——<strong>三级缓存各自的作用及其在 Bean 创建过程中的流转</strong>——是掌握 Spring IoC 容器底层原理的标志。同时，也要清楚 Spring <strong>无法解决原型 Bean 和构造器注入</strong>导致的循环依赖，并知道如何通过调整注入方式或引入 <code>@Lazy</code> 来规避这些问题。</p>`,37)]))}const p=e(i,[["render",r],["__file","spring-depend.html.vue"]]),g=JSON.parse('{"path":"/spring/spring-depend.html","title":"","lang":"zh-CN","frontmatter":{"description":"今天我们来聊聊一个既常见又有点让人头疼的问题：Spring框架中的循环依赖。这个问题不仅在实际开发中偶尔会碰到，更是面试官考察你对Spring IoC容器底层机制理解深度的绝佳切入点。 理解Spring如何处理（以及在什么情况下不处理）循环依赖，是理解Spring Bean生命周期、Bean创建过程以及其内部缓存机制的关键。 深度解析 Spring 循...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/spring/spring-depend.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"今天我们来聊聊一个既常见又有点让人头疼的问题：Spring框架中的循环依赖。这个问题不仅在实际开发中偶尔会碰到，更是面试官考察你对Spring IoC容器底层机制理解深度的绝佳切入点。 理解Spring如何处理（以及在什么情况下不处理）循环依赖，是理解Spring Bean生命周期、Bean创建过程以及其内部缓存机制的关键。 深度解析 Spring 循..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-01T16:05:51.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-05-01T16:05:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-01T16:05:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"深度解析 Spring 循环依赖问题：原理、解决与避坑","slug":"深度解析-spring-循环依赖问题-原理、解决与避坑","link":"#深度解析-spring-循环依赖问题-原理、解决与避坑","children":[{"level":3,"title":"引言：什么是循环依赖，为何它是个问题？","slug":"引言-什么是循环依赖-为何它是个问题","link":"#引言-什么是循环依赖-为何它是个问题","children":[]},{"level":3,"title":"IoC 容器为何“惧怕”循环依赖？","slug":"ioc-容器为何-惧怕-循环依赖","link":"#ioc-容器为何-惧怕-循环依赖","children":[]},{"level":3,"title":"Spring 对单例循环依赖的解决方案","slug":"spring-对单例循环依赖的解决方案","link":"#spring-对单例循环依赖的解决方案","children":[]},{"level":3,"title":"Spring 无法解决循环依赖的场景","slug":"spring-无法解决循环依赖的场景","link":"#spring-无法解决循环依赖的场景","children":[]},{"level":3,"title":"理解循环依赖对开发者的意义","slug":"理解循环依赖对开发者的意义","link":"#理解循环依赖对开发者的意义","children":[]},{"level":3,"title":"Spring 循环依赖为何是面试热点","slug":"spring-循环依赖为何是面试热点","link":"#spring-循环依赖为何是面试热点","children":[]},{"level":3,"title":"面试问题示例与深度解析","slug":"面试问题示例与深度解析","link":"#面试问题示例与深度解析","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1745924024000,"updatedTime":1746115551000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":2}]},"readingTime":{"minutes":11.88,"words":3563},"filePathRelative":"spring/spring-depend.md","localizedDate":"2025年4月29日","autoDesc":true}');export{p as comp,g as data};
