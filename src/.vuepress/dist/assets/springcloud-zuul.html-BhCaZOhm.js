import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,e as t,o as a}from"./app-CzKZ5RuK.js";const o={};function l(i,n){return a(),e("div",null,n[0]||(n[0]=[t(`<p>在微服务架构中，API 网关扮演着至关重要的角色，它是外部世界访问内部服务的唯一入口。在 Spring Cloud 生态的早期，Netflix Zuul 是构建 API 网关的主流选择。它以其灵活的过滤器机制，帮助开发者实现了请求路由、认证、限流等多种功能。</p><p>理解 Zuul 的架构和工作原理，特别是其过滤器机制，对于理解微服务网关如何处理请求、如何实现各种横切关注点以及如何从 Zuul 迁移到更现代的网关解决方案（如 Spring Cloud Gateway）都非常有价值。同时，Zuul 的过滤器生命周期是面试中常考的经典问题。</p><p><strong>（需要注意的是，我们今天主要讨论的是 Spring Cloud Netflix Zuul 1.x 版本，它是基于 Servlet 的阻塞式网关，目前 Netflix 官方和 Spring Cloud 社区都已将其置于维护模式，不再积极开发新功能，并推荐使用 Spring Cloud Gateway 作为新的网关解决方案。但 Zuul 1.x 在现有系统中仍广泛存在，且其过滤器设计思想是理解网关模式的重要案例，因此深入理解它仍然具有重要的历史和面试价值。）</strong></p><p>今天，就让我们一起深度剖析 Spring Cloud Netflix Zuul 1.x，看看这个基于过滤器的网关是如何工作的。</p><hr><h2 id="深度解析-spring-cloud-netflix-zuul-基于过滤器的-api-网关" tabindex="-1"><a class="header-anchor" href="#深度解析-spring-cloud-netflix-zuul-基于过滤器的-api-网关"><span>深度解析 Spring Cloud Netflix Zuul：基于过滤器的 API 网关</span></a></h2><h3 id="引言-api-网关的必要性与-zuul-的定位" tabindex="-1"><a class="header-anchor" href="#引言-api-网关的必要性与-zuul-的定位"><span>引言：API 网关的必要性与 Zuul 的定位</span></a></h3><p>正如我们在 API 网关那篇文章中提到的，API 网关是微服务架构对外暴露的关键组件，它解决了客户端直接调用多个后端服务带来的复杂性问题。</p><p>Netflix Zuul 是由 Netflix 开发并开源的一个 API 网关项目。Spring Cloud Netflix 项目对其进行了集成，使其成为 Spring Cloud 生态中早期的 API 网关解决方案。</p><ul><li><strong>定位：</strong> Zuul 1.x 是一个基于 <strong>Servlet</strong> 的 API 网关，核心是其<strong>过滤器 (Filter)</strong> 机制。</li><li><strong>目标：</strong> 提供可编程的方式来路由请求，并实现请求在路由前后的各种过滤操作。</li></ul><p>理解 Zuul 的架构和使用方式，能让你：</p><ul><li>掌握基于过滤器的网关实现原理。</li><li>理解 Zuul 的核心：过滤器及其生命周期。</li><li>了解 Zuul 1.x 的阻塞式架构特点及其在高并发下的局限性。</li><li>为从 Zuul 迁移到 Gateway 提供理论基础。</li><li>自信应对面试中关于 API 网关和 Zuul 过滤器机制的提问。</li></ul><p>接下来，我们将深入 Zuul 1.x 的架构、核心概念和请求处理流程，并结合 Spring Cloud 讲解其使用方式。</p><h3 id="zuul-1-x-的架构设计与核心概念-重点" tabindex="-1"><a class="header-anchor" href="#zuul-1-x-的架构设计与核心概念-重点"><span>Zuul 1.x 的架构设计与核心概念 (重点)</span></a></h3><p>Zuul 1.x 的架构相对简单，其核心在于其<strong>过滤器引擎</strong>和<strong>过滤器生命周期</strong>。</p><ol><li><p><strong>核心基石：Servlet 阻塞式架构 (Blocking Architecture)</strong></p><ul><li>Zuul 1.x 是构建在传统的 Java Servlet 之上的。这意味着每个进入 Zuul 的请求都会由 Servlet 容器（如 Tomcat）分配一个线程来处理。</li><li>在处理请求转发到后端服务并等待响应的过程中，<strong>这个线程会一直被阻塞</strong>，直到收到后端服务的响应。</li><li><strong>高并发下的问题：</strong> 在高并发场景下，大量的请求可能导致 Servlet 容器的线程资源迅速耗尽，新的请求将无法被处理，从而影响网关的吞吐量和响应能力。这是 Zuul 1.x 最大的局限性，也是 Spring Cloud Gateway (响应式非阻塞) 出现的重要原因。</li></ul></li><li><p><strong>过滤器 (ZuulFilter)：</strong></p><ul><li><strong>定义：</strong> <code>com.netflix.zuul.ZuulFilter</code> 是 Zuul 的核心抽象。开发者通过实现这个接口来定义各种过滤器，实现请求拦截、路由、修改请求/响应等逻辑。</li><li><strong>核心方法：</strong> 实现 <code>ZuulFilter</code> 需要重写以下关键方法： <ul><li><code>filterType()</code>: 过滤器的类型，定义了过滤器的生命周期（<code>pre</code>, <code>routing</code>, <code>post</code>, <code>error</code>）。</li><li><code>filterOrder()</code>: 同一类型的过滤器的执行顺序。</li><li><code>shouldFilter()</code>: 判断当前请求是否应该执行该过滤器。</li><li><code>run()</code>: 过滤器的具体逻辑实现。</li></ul></li></ul></li><li><p><strong>过滤器生命周期 (Types) - 重点：</strong></p><ul><li>Zuul 内置了一个过滤器管理器，它会根据过滤器的 <code>filterType()</code> 将过滤器组织到不同的生命周期阶段。一个请求在 Zuul 中会顺序经过这些阶段的过滤器链： <ul><li><strong><code>pre</code> 过滤器：</strong> 在请求被路由到后端服务<strong>之前</strong>执行。 <ul><li><strong>执行时机：</strong> 请求进入 Zuul 后，最先执行的过滤器类型。</li><li><strong>典型应用场景：</strong> 认证、授权、参数校验、日志记录、流量控制、向请求头添加信息等。</li></ul></li><li><strong><code>routing</code> 过滤器：</strong> 负责将请求路由到后端服务。 <ul><li><strong>执行时机：</strong> 在 <code>pre</code> 过滤器执行完毕后执行。</li><li><strong>典型应用场景：</strong> 使用 <code>RibbonRoutingFilter</code> (默认) 结合 Ribbon 和服务发现将请求转发到服务实例，或者使用 <code>SimpleHostRoutingFilter</code> 将请求转发到具体的 URL。</li></ul></li><li><strong><code>post</code> 过滤器：</strong> 在请求被路由到后端服务并收到响应<strong>之后</strong>执行。 <ul><li><strong>执行时机：</strong> 在 <code>routing</code> 过滤器成功执行后执行。</li><li><strong>典型应用场景：</strong> 向响应头添加信息、记录响应日志、对响应体进行处理或转换等。</li></ul></li><li><strong><code>error</code> 过滤器：</strong> 在任何其他阶段发生错误时执行。 <ul><li><strong>执行时机：</strong> 当 <code>pre</code>, <code>routing</code>, <code>post</code> 过滤器在执行过程中抛出异常时，会被 <code>error</code> 过滤器捕获并处理。</li><li><strong>典型应用场景：</strong> 统一异常处理、返回错误响应、记录错误信息等。</li></ul></li></ul></li><li><strong>执行顺序：</strong> 请求总是先经过 <code>pre</code> 过滤器链，然后是 <code>routing</code> 过滤器链（通常只有一个主要的路由过滤器），如果路由成功则进入 <code>post</code> 过滤器链。如果在任何阶段发生异常，会中断当前阶段后续过滤器的执行，转而执行 <code>error</code> 过滤器链。</li></ul></li><li><p><strong>请求上下文 (<code>RequestContext</code>)：</strong></p><ul><li><strong>定义：</strong> <code>com.netflix.zuul.context.RequestContext</code> 是一个线程本地 (ThreadLocal) 的数据结构，用于在同一个请求的整个处理过程中（跨越不同的过滤器）共享数据。</li><li><strong>作用：</strong> 过滤器可以通过 <code>RequestContext.getCurrentContext()</code> 获取当前请求的上下文，并在其中存储或读取请求、响应、状态、异常、自定义属性等信息。例如，<code>pre</code> 过滤器可以将认证信息放入上下文供后续过滤器使用，<code>routing</code> 过滤器可以将响应信息放入上下文供 <code>post</code> 过滤器处理。</li></ul></li><li><p><strong>过滤器管理与执行流程：</strong></p><ul><li>Zuul 有一个 <code>ZuulServlet</code>，它是整个流程的入口。<code>ZuulServlet</code> 内部有一个 <code>FilterProcessor</code>，负责加载、编译和执行过滤器。</li><li>过滤器可以动态加载和刷新。</li></ul></li></ol><h3 id="zuul-工作流程-基于过滤器的请求处理详细" tabindex="-1"><a class="header-anchor" href="#zuul-工作流程-基于过滤器的请求处理详细"><span>Zuul 工作流程 (基于过滤器的请求处理详细)</span></a></h3><p>结合过滤器生命周期，一个请求在 Zuul 1.x 中的处理流程如下：</p><ol><li><strong>请求到达 <code>ZuulServlet</code>：</strong> 客户端请求进入 Zuul 应用，由 Servlet 容器分配一个线程处理。</li><li><strong><code>FilterProcessor</code> 执行 <code>pre</code> 过滤器链：</strong> <code>ZuulServlet</code> 将请求交给 <code>FilterProcessor</code>。<code>FilterProcessor</code> 找到所有类型为 <code>pre</code> 的过滤器，并按照 <code>filterOrder</code> 的顺序依次执行它们的 <code>shouldFilter()</code> 和 <code>run()</code> 方法。 <ul><li><strong>典型操作：</strong> 认证、限流、参数检查、添加请求头等。</li><li><strong>如果某个 <code>pre</code> 过滤器抛出异常：</strong> 中断 <code>pre</code> 阶段后续过滤器的执行，转到步骤 5 (执行 <code>error</code> 过滤器)。</li><li><strong>如果某个 <code>pre</code> 过滤器的 <code>shouldFilter()</code> 返回 <code>false</code>：</strong> 跳过该过滤器的 <code>run()</code> 方法。</li><li><strong>如果某个 <code>pre</code> 过滤器在 <code>run()</code> 中设置了 <code>RequestContext.setSendZuulResponse(false)</code>：</strong> 中断后续所有阶段的过滤器执行，直接返回响应（通常用于认证失败等情况）。</li></ul></li><li><strong><code>FilterProcessor</code> 执行 <code>routing</code> 过滤器链：</strong> 如果 <code>pre</code> 阶段没有中断请求，<code>FilterProcessor</code> 找到所有类型为 <code>routing</code> 的过滤器，按顺序执行。通常只有一个主要的 <code>routing</code> 过滤器生效。 <ul><li><strong>典型操作：</strong> 根据路由规则（服务名称或 URL），使用 Ribbon 或其他方式将请求发送到后端服务，并<strong>阻塞等待</strong>后端服务的响应。<code>RibbonRoutingFilter</code> 是默认的 <code>routing</code> 过滤器，它会使用 Ribbon 进行负载均衡和服务调用。</li><li><strong>如果 <code>routing</code> 过滤器抛出异常或后端服务调用失败/超时：</strong> 中断 <code>routing</code> 阶段后续过滤器的执行，转到步骤 5 (执行 <code>error</code> 过滤器)。</li></ul></li><li><strong><code>FilterProcessor</code> 执行 <code>post</code> 过滤器链：</strong> 如果 <code>routing</code> 过滤器成功获取到后端服务的响应，<code>FilterProcessor</code> 找到所有类型为 <code>post</code> 的过滤器，按顺序执行。 <ul><li><strong>典型操作：</strong> 修改响应头、修改响应体、记录响应日志等。</li><li><strong>如果某个 <code>post</code> 过滤器抛出异常：</strong> 中断 <code>post</code> 阶段后续过滤器的执行，转到步骤 5 (执行 <code>error</code> 过滤器)。</li></ul></li><li><strong><code>FilterProcessor</code> 执行 <code>error</code> 过滤器链：</strong> 如果在 <code>pre</code>, <code>routing</code>, <code>post</code> 阶段发生异常，请求会进入 <code>error</code> 过滤器链。 <ul><li><strong>典型操作：</strong> 统一异常处理，生成错误响应。</li></ul></li><li><strong>返回响应：</strong> 所有过滤器执行完毕后，最终的响应（由某个过滤器生成，或者由 <code>routing</code> 过滤器获取的响应经过 <code>post</code> 过滤器处理）返回给客户端。</li></ol><p><strong>Zuul 1.x 工作流程图示 (文字版):</strong></p><p>客户端请求 -&gt; <code>ZuulServlet</code> -&gt; <code>FilterProcessor</code> -&gt; 执行 <code>pre</code> 过滤器链 (认证, 限流, 修改请求头...) -&gt; (如果 <code>pre</code> 未中断) 执行 <code>routing</code> 过滤器链 (如 <code>RibbonRoutingFilter</code> 调用后端服务, <strong>阻塞等待响应</strong>) -&gt; (如果 <code>routing</code> 成功) 执行 <code>post</code> 过滤器链 (修改响应头, 记录日志...) -&gt; 返回响应给客户端</p><p><strong>异常流程 (插入):</strong></p><p>任何阶段抛出异常 -&gt; 中断当前阶段后续过滤器 -&gt; 转到 执行 <code>error</code> 过滤器链 (统一异常处理) -&gt; 返回错误响应给客户端</p><h3 id="zuul-与其他-spring-cloud-组件集成" tabindex="-1"><a class="header-anchor" href="#zuul-与其他-spring-cloud-组件集成"><span>Zuul 与其他 Spring Cloud 组件集成</span></a></h3><p>Spring Cloud Netflix 对 Zuul 进行了深度集成，特别是与 Eureka、Ribbon 和 Hystrix：</p><ul><li><strong>服务发现与负载均衡 (Ribbon)：</strong> 当使用 <code>serviceId</code> (服务名称) 进行路由时，Zuul 的默认 <code>RibbonRoutingFilter</code> 会自动使用 Ribbon 进行客户端负载均衡。Ribbon 则从服务发现组件（如 Eureka）获取服务实例列表。<code>@EnableZuulProxy</code> 注解会自动配置这些集成。</li><li><strong>断路器 (Hystrix)：</strong> <code>@EnableZuulProxy</code> 也会自动启用 Hystrix。Zuul 的某些过滤器（特别是 <code>routing</code> 过滤器）会被 Hystrix Command 包装。这意味着对下游服务的调用如果失败或超时，会触发 Hystrix 的断路器和降级逻辑，提高网关对下游服务故障的容忍能力。</li></ul><h3 id="spring-cloud-集成-zuul-的使用方式" tabindex="-1"><a class="header-anchor" href="#spring-cloud-集成-zuul-的使用方式"><span>Spring Cloud 集成 Zuul 的使用方式</span></a></h3><p>在 Spring Cloud 中使用 Zuul 1.x：</p><ol><li><strong>创建 Spring Boot 项目：</strong> 标准 Spring Boot 应用。</li><li><strong>添加依赖：</strong> 在 <code>pom.xml</code> 或 <code>build.gradle</code> 中添加 Spring Cloud Zuul Starter。<div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-zuul<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>启用 Zuul：</strong> 在 Spring Boot 应用的启动类上添加 <code>@EnableZuulProxy</code> 注解。这个注解会开启 Zuul 的功能，并自动配置一些默认的过滤器（包括与 Ribbon、Hystrix 集成的过滤器）。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@EnableZuulProxy</span> <span class="token comment">// 启用 Zuul 网关功能</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZuulGatewayApplication</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">ZuulGatewayApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>配置路由：</strong> 主要通过配置文件 (<code>application.yml</code> 推荐) 来定义路由规则。<div class="language-yaml line-numbers-mode" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token comment"># application.yml for Spring Cloud Zuul Gateway</span>
<span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span> <span class="token comment"># 网关端口</span>

<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">serviceUrl</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8761/eureka/ <span class="token comment"># 指向 Eureka Server</span>

<span class="token key atrule">zuul</span><span class="token punctuation">:</span>
  <span class="token key atrule">routes</span><span class="token punctuation">:</span>
    <span class="token comment"># 使用服务 ID 进行路由 (会结合 Ribbon 和 Eureka)</span>
    <span class="token key atrule">user-service</span><span class="token punctuation">:</span> <span class="token comment"># 路由 ID，也是服务 ID</span>
      <span class="token key atrule">path</span><span class="token punctuation">:</span> /user/<span class="token important">**</span> <span class="token comment"># 外部请求路径前缀</span>
      <span class="token comment"># 外部请求 /user/** 会被路由到名为 user-service 的服务</span>
      <span class="token comment"># 例如：GET /user/123 -&gt; GET http://user-service-instance-ip:port/123</span>

    <span class="token comment"># 也可以使用 URL 进行路由 (不会经过 Ribbon 和 Eureka)</span>
    <span class="token comment"># static-route:</span>
    <span class="token comment">#   path: /static/**</span>
    <span class="token comment">#   url: http://localhost:8081/static # 转发到固定 URL</span>

    <span class="token comment"># 可以忽略服务 ID，只使用 path 和 url 进行更灵活的路由</span>
    <span class="token comment"># my-route:</span>
    <span class="token comment">#   path: /myapi/**</span>
    <span class="token comment">#   url: http://some.external.api.com/</span>
    <span class="token comment">#   stripPrefix: false # 默认会剥离 path 前缀，这里设置为 false 不剥离</span>

  <span class="token comment"># 忽略服务，不对这些服务进行路由 (保护敏感服务)</span>
  <span class="token key atrule">ignored-services</span><span class="token punctuation">:</span> payment<span class="token punctuation">-</span>service <span class="token comment"># 不对 payment-service 进行路由</span>

  <span class="token comment"># 配置敏感头，这些头信息不会被传递到下游服务</span>
  <span class="token key atrule">sensitive-headers</span><span class="token punctuation">:</span> Cookie<span class="token punctuation">,</span>Set<span class="token punctuation">-</span>Cookie <span class="token comment"># 默认敏感头，可以覆盖或清空</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>自定义 Zuul Filter：</strong> 实现 <code>ZuulFilter</code> 接口，将实现类注册为 Spring Bean。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span> <span class="token comment">// 将自定义 Filter 注册为 Spring Bean</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthPreFilter</span> <span class="token keyword">extends</span> <span class="token class-name">ZuulFilter</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">filterType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;pre&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 定义为 pre 过滤器</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">filterOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 定义执行顺序，越小越先执行</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 根据 RequestContext 判断是否应该执行该过滤器</span>
        <span class="token comment">// 例如：return RequestContext.getCurrentContext().getRequest().getRequestURI().startsWith(&quot;/user/&quot;);</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 对所有请求生效</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ZuulException</span> <span class="token punctuation">{</span>
        <span class="token class-name">RequestContext</span> context <span class="token operator">=</span> <span class="token class-name">RequestContext</span><span class="token punctuation">.</span><span class="token function">getCurrentContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">HttpServletRequest</span> request <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;AuthPreFilter: Intercepting request &quot;</span> <span class="token operator">+</span> request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> request<span class="token punctuation">.</span><span class="token function">getRequestURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 示例：检查请求头是否有 token</span>
        <span class="token class-name">String</span> token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Authorization&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 设置 Response 状态，中断后续流程</span>
            context<span class="token punctuation">.</span><span class="token function">setSendZuulResponse</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不再向后端服务转发请求</span>
            context<span class="token punctuation">.</span><span class="token function">setResponseStatusCode</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回 401 Unauthorized</span>
            context<span class="token punctuation">.</span><span class="token function">setResponseBody</span><span class="token punctuation">(</span><span class="token string">&quot;Unauthorized&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 可以设置 context.setRouteHost(...) 来路由到错误服务</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// run 方法返回 null</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将 token 信息放入 RequestContext 供后续过滤器或下游服务使用 (如果需要)</span>
        <span class="token comment">// context.put(&quot;authToken&quot;, token);</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 继续执行后续过滤器</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="zuul-1-x-的局限性与维护状态-重要提示" tabindex="-1"><a class="header-anchor" href="#zuul-1-x-的局限性与维护状态-重要提示"><span>Zuul 1.x 的局限性与维护状态 (重要提示)</span></a></h3><p>如前所述，Zuul 1.x 是基于 Servlet 的<strong>阻塞式</strong>网关。其最大的局限性在于：</p><ul><li><strong>性能瓶颈：</strong> 在高并发、长连接场景下，线程阻塞导致资源消耗高，吞吐量和响应能力受限。</li><li><strong>功能受限：</strong> 对于一些响应式特性、HTTP/2、WebSocket 的支持不够友好。</li><li><strong>配置模型相对简单：</strong> 过滤器虽然灵活，但管理和组织大量过滤器可能变得复杂。</li></ul><p>鉴于这些局限性，Netflix 官方已停止对 Zuul 1.x 的积极开发，并转向了 Zuul 2.x (基于 Netty 的响应式版本，但未在 Spring Cloud 中广泛集成)。Spring Cloud 社区也推出了基于 Spring WebFlux 的<strong>Spring Cloud Gateway</strong>作为官方推荐的继任者。</p><h3 id="spring-cloud-gateway-vs-spring-cloud-netflix-zuul-对比-回顾" tabindex="-1"><a class="header-anchor" href="#spring-cloud-gateway-vs-spring-cloud-netflix-zuul-对比-回顾"><span>Spring Cloud Gateway vs Spring Cloud Netflix Zuul 对比 (回顾)</span></a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">Spring Cloud Netflix Zuul 1.x</th><th style="text-align:left;">Spring Cloud Gateway</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>基础框架</strong></td><td style="text-align:left;">Servlet 阻塞式</td><td style="text-align:left;">Spring WebFlux 响应式非阻塞</td></tr><tr><td style="text-align:left;"><strong>性能</strong></td><td style="text-align:left;">高并发下易有性能瓶颈</td><td style="text-align:left;">高并发下性能更优</td></tr><tr><td style="text-align:left;"><strong>编程模型</strong></td><td style="text-align:left;">同步阻塞</td><td style="text-align:left;">异步响应式</td></tr><tr><td style="text-align:left;"><strong>配置方式</strong></td><td style="text-align:left;">过滤器生命周期 + RequestContext</td><td style="text-align:left;">Route, Predicate, Filter</td></tr><tr><td style="text-align:left;"><strong>HTTP/2</strong></td><td style="text-align:left;">支持有限</td><td style="text-align:left;">更好支持</td></tr><tr><td style="text-align:left;"><strong>维护状态</strong></td><td style="text-align:left;"><strong>维护模式</strong></td><td style="text-align:left;"><strong>积极开发</strong></td></tr></tbody></table><h3 id="理解-zuul-架构与使用方式的价值" tabindex="-1"><a class="header-anchor" href="#理解-zuul-架构与使用方式的价值"><span>理解 Zuul 架构与使用方式的价值</span></a></h3><ul><li><strong>理解网关模式的演进：</strong> 掌握 Zuul 的过滤器机制，有助于理解 API 网关如何实现功能，并为学习更现代的网关（如 Gateway）打下基础。</li><li><strong>排查旧系统问题：</strong> 很多现有的 Spring Cloud 项目仍在使用 Zuul，理解其原理是排查这些系统中网关问题的关键。</li><li><strong>对比学习响应式网关：</strong> 通过对比 Zuul (阻塞) 和 Gateway (响应式)，能更深刻理解响应式编程在高并发 I/O 场景下的优势。</li><li><strong>面试高分项：</strong> Zuul 的过滤器生命周期是经典考点，用来考察候选人对网关工作原理的理解。</li></ul><h3 id="zuul-为何是面试热点" tabindex="-1"><a class="header-anchor" href="#zuul-为何是面试热点"><span>Zuul 为何是面试热点</span></a></h3><p>尽管 Zuul 1.x 已进入维护模式，但它作为早期广泛使用的 API 网关，以及其经典的过滤器机制，使其在面试中仍保持较高的出现频率，常常被用来：</p><ul><li><strong>考察你对 API 网关基本概念的理解。</strong></li><li><strong>通过过滤器生命周期考察你对网关请求处理流程的掌握。</strong></li><li><strong>作为对比对象，突出 Spring Cloud Gateway 响应式优势，考察你对新技术的理解。</strong></li><li><strong>确认你是否具备维护现有 Zuul 系统的能力。</strong></li></ul><h3 id="面试问题示例与深度解析" tabindex="-1"><a class="header-anchor" href="#面试问题示例与深度解析"><span>面试问题示例与深度解析</span></a></h3><ul><li><strong>什么是 API 网关？在微服务架构中为什么需要 API 网关？</strong> (定义，列举作用)</li><li><strong>请描述一下 Spring Cloud Netflix Zuul 1.x 的架构。它的核心是什么？</strong> (回答基于 Servlet 的阻塞式网关，核心是过滤器机制)</li><li><strong>请解释一下 Zuul 过滤器的生命周期（类型）。它们分别在哪个阶段执行？典型的应用场景是什么？</strong> (<strong>核心！</strong> 回答 <code>pre</code>, <code>routing</code>, <code>post</code>, <code>error</code> 四种类型，详细解释执行时机和示例场景)</li><li><strong>Zuul 过滤器是如何实现数据共享的？</strong> (通过 <code>RequestContext</code>，它是线程本地的)</li><li><strong>请描述一下 Zuul 处理一个请求的流程。</strong> (<strong>核心！</strong> 回答请求 -&gt; Servlet -&gt; 过滤器链执行 (按 <code>pre</code> -&gt; <code>routing</code> -&gt; <code>post</code> 或 <code>error</code> 顺序)，说明各类型过滤器在流程中的作用)</li><li><strong>Zuul 如何实现服务发现和负载均衡？</strong> (通过 <code>serviceId</code> 路由，默认 <code>RibbonRoutingFilter</code> 结合 Ribbon 和 Eureka)</li><li><strong>Zuul 如何集成断路器？</strong> (Zuul 的路由过滤器被 Hystrix Command 包装)</li><li><strong>Spring Cloud Netflix Zuul 1.x 的局限性是什么？为什么推荐使用 Spring Cloud Gateway？</strong> (回答阻塞式架构，高并发性能瓶颈；推荐 Gateway 因为它是响应式非阻塞的，性能更优)</li><li><strong>如何自定义一个 Zuul Filter？需要实现哪些方法？</strong> (实现 <code>ZuulFilter</code> 接口，重写 <code>filterType</code>, <code>filterOrder</code>, <code>shouldFilter</code>, <code>run</code>)</li><li><strong>Zuul 的 <code>shouldFilter()</code> 方法和 <code>run()</code> 方法分别起什么作用？</strong> (<code>shouldFilter</code> 决定是否执行 <code>run</code>，<code>run</code> 实现具体过滤逻辑)</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>Spring Cloud Netflix Zuul 1.x 作为 Spring Cloud 生态中早期的 API 网关解决方案，凭借其灵活的过滤器机制，为微服务提供了请求路由和各种横切关注点处理的能力。其核心在于<strong>过滤器</strong>和<strong>过滤器生命周期</strong>（<code>pre</code>, <code>routing</code>, <code>post</code>, <code>error</code>）。</p><p>理解 Zuul 的架构（特别是其<strong>阻塞式</strong>特性）、过滤器的工作原理和生命周期、以及请求在过滤器链中的流转过程，是掌握基于过滤器网关的关键。尽管 Zuul 1.x 已进入维护模式并有其局限性，但理解它对于排查现有系统问题和学习更先进的响应式网关（如 Spring Cloud Gateway）都非常有价值。</p>`,45)]))}const u=s(o,[["render",l],["__file","springcloud-zuul.html.vue"]]),r=JSON.parse('{"path":"/springcloud/springcloud-zuul.html","title":"","lang":"zh-CN","frontmatter":{"description":"在微服务架构中，API 网关扮演着至关重要的角色，它是外部世界访问内部服务的唯一入口。在 Spring Cloud 生态的早期，Netflix Zuul 是构建 API 网关的主流选择。它以其灵活的过滤器机制，帮助开发者实现了请求路由、认证、限流等多种功能。 理解 Zuul 的架构和工作原理，特别是其过滤器机制，对于理解微服务网关如何处理请求、如何实现...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/springcloud/springcloud-zuul.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"在微服务架构中，API 网关扮演着至关重要的角色，它是外部世界访问内部服务的唯一入口。在 Spring Cloud 生态的早期，Netflix Zuul 是构建 API 网关的主流选择。它以其灵活的过滤器机制，帮助开发者实现了请求路由、认证、限流等多种功能。 理解 Zuul 的架构和工作原理，特别是其过滤器机制，对于理解微服务网关如何处理请求、如何实现..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-01T16:05:51.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-05-01T16:05:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-01T16:05:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"深度解析 Spring Cloud Netflix Zuul：基于过滤器的 API 网关","slug":"深度解析-spring-cloud-netflix-zuul-基于过滤器的-api-网关","link":"#深度解析-spring-cloud-netflix-zuul-基于过滤器的-api-网关","children":[{"level":3,"title":"引言：API 网关的必要性与 Zuul 的定位","slug":"引言-api-网关的必要性与-zuul-的定位","link":"#引言-api-网关的必要性与-zuul-的定位","children":[]},{"level":3,"title":"Zuul 1.x 的架构设计与核心概念 (重点)","slug":"zuul-1-x-的架构设计与核心概念-重点","link":"#zuul-1-x-的架构设计与核心概念-重点","children":[]},{"level":3,"title":"Zuul 工作流程 (基于过滤器的请求处理详细)","slug":"zuul-工作流程-基于过滤器的请求处理详细","link":"#zuul-工作流程-基于过滤器的请求处理详细","children":[]},{"level":3,"title":"Zuul 与其他 Spring Cloud 组件集成","slug":"zuul-与其他-spring-cloud-组件集成","link":"#zuul-与其他-spring-cloud-组件集成","children":[]},{"level":3,"title":"Spring Cloud 集成 Zuul 的使用方式","slug":"spring-cloud-集成-zuul-的使用方式","link":"#spring-cloud-集成-zuul-的使用方式","children":[]},{"level":3,"title":"Zuul 1.x 的局限性与维护状态 (重要提示)","slug":"zuul-1-x-的局限性与维护状态-重要提示","link":"#zuul-1-x-的局限性与维护状态-重要提示","children":[]},{"level":3,"title":"Spring Cloud Gateway vs Spring Cloud Netflix Zuul 对比 (回顾)","slug":"spring-cloud-gateway-vs-spring-cloud-netflix-zuul-对比-回顾","link":"#spring-cloud-gateway-vs-spring-cloud-netflix-zuul-对比-回顾","children":[]},{"level":3,"title":"理解 Zuul 架构与使用方式的价值","slug":"理解-zuul-架构与使用方式的价值","link":"#理解-zuul-架构与使用方式的价值","children":[]},{"level":3,"title":"Zuul 为何是面试热点","slug":"zuul-为何是面试热点","link":"#zuul-为何是面试热点","children":[]},{"level":3,"title":"面试问题示例与深度解析","slug":"面试问题示例与深度解析","link":"#面试问题示例与深度解析","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1745924024000,"updatedTime":1746115551000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":2}]},"readingTime":{"minutes":15,"words":4499},"filePathRelative":"springcloud/springcloud-zuul.md","localizedDate":"2025年4月29日","autoDesc":true}');export{u as comp,r as data};
