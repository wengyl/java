import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e,o as t}from"./app-CzKZ5RuK.js";const p={};function o(c,n){return t(),a("div",null,n[0]||(n[0]=[e(`<h1 id="死锁现象" tabindex="-1"><a class="header-anchor" href="#死锁现象"><span>死锁现象</span></a></h1><p>线上MySQL死锁了，我赶紧登录线上系统，查看业务日志。 <img src="https://javabaguwen.com/img/死锁1.png" alt="image-20220608112347888.png" loading="lazy"> 能清楚看到是这条insert语句发生了死锁。 MySQL如果检测到两个事务发生了死锁，会回滚其中一个事务，让另一个事务执行成功。很明显，我们这条insert语句被回滚了。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">&#39;张三&#39;</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是我们怎么排查这个问题呢？ 到底跟哪条SQL产生了死锁？</p><h1 id="死锁日志" tabindex="-1"><a class="header-anchor" href="#死锁日志"><span>死锁日志</span></a></h1><p>好在MySQL记录了最近一次的死锁日志，可以用命令行工具查看：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">show</span> <span class="token keyword">engine</span> <span class="token keyword">innodb</span> <span class="token keyword">status</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://javabaguwen.com/img/死锁2.png" alt="死锁日志.png" loading="lazy"> 在死锁日志中，可以清楚地看到这两条insert语句产生了死锁，最终事务2被会回滚，事务1执行成功。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 事务1</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">&#39;张三&#39;</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment"># 事务2</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">&#39;李四&#39;</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两条insert语句，怎么看也不像能产生死锁，我们来还原一下事发过程。</p><h1 id="排查过程" tabindex="-1"><a class="header-anchor" href="#排查过程"><span>排查过程</span></a></h1><p>先看一下对应的Java代码：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> <span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> userResult <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectByIdForUpdate</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果userId不存在，就插入数据，否则更新</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>userResult <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        userMapper<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>业务逻辑代码很简单，如果userId不存在，就插入数据，否则更新user对象数据。 从死锁日志中，我们看到有两条insert语句，很明显userId=5和userId=6的数据都不存在。 所以对应的SQL执行过程，可能就是这样的： <img src="https://javabaguwen.com/img/死锁3.png" alt="image-20220608174554212.png" loading="lazy"> 先用for update加上排他锁，防止其他事务修改当前数据，然后再insert数据，最后发生了死锁，事务2被回滚。 两个事务分别在两个主键ID上面加锁，为什么会产生死锁呢？</p><h1 id="底层原理" tabindex="-1"><a class="header-anchor" href="#底层原理"><span>底层原理</span></a></h1><p>如果看过上篇文章，就会明白。 当id=5存在这条数据时，MySQL就会加<strong>Record Locks（记录锁）</strong>，意思就是只在id=5这一条记录上加锁。 当id=5这条记录不存在时，就会锁定一个范围 假设表中的记录是这样的：</p><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>王二</td><td>1</td></tr><tr><td>10</td><td>一灯</td><td>10</td></tr></tbody></table><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">5</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这条select语句锁定范围就是 <strong>(1, 10]</strong>。 最后两个事务的执行过程就变成了： <img src="https://javabaguwen.com/img/死锁4.png" alt="image-20220608180913949.png" loading="lazy"> 通过这个示例看到，两个事务都可以先后锁定 <strong>(1, 10]</strong> 这个范围，说明MySQL默认加的临键锁的范围是可以交叉的。 那怎么解决这个死锁问题呢？ 我能想到的解决办法就是，把这两个语句select和insert，合并成一条语句：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">&#39;张三&#39;</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>
	<span class="token keyword">on</span> <span class="token keyword">duplicate</span> <span class="token keyword">key</span> <span class="token keyword">update</span> name<span class="token operator">=</span><span class="token string">&#39;张三&#39;</span><span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>大家有什么好办法吗？ 这个死锁情况，还是挺常见的，赶紧回去翻一下项目代码有没有这样的问题。</p>`,21)]))}const r=s(p,[["render",o],["__file","dead.html.vue"]]),u=JSON.parse('{"path":"/mysql/dead.html","title":"死锁现象","lang":"zh-CN","frontmatter":{"description":"死锁现象 线上MySQL死锁了，我赶紧登录线上系统，查看业务日志。 image-20220608112347888.png 能清楚看到是这条insert语句发生了死锁。 MySQL如果检测到两个事务发生了死锁，会回滚其中一个事务，让另一个事务执行成功。很明显，我们这条insert语句被回滚了。 但是我们怎么排查这个问题呢？ 到底跟哪条SQL产生了死锁？...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/mysql/dead.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:title","content":"死锁现象"}],["meta",{"property":"og:description","content":"死锁现象 线上MySQL死锁了，我赶紧登录线上系统，查看业务日志。 image-20220608112347888.png 能清楚看到是这条insert语句发生了死锁。 MySQL如果检测到两个事务发生了死锁，会回滚其中一个事务，让另一个事务执行成功。很明显，我们这条insert语句被回滚了。 但是我们怎么排查这个问题呢？ 到底跟哪条SQL产生了死锁？..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javabaguwen.com/img/%E6%AD%BB%E9%94%811.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-29T06:25:28.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-04-29T06:25:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"死锁现象\\",\\"image\\":[\\"https://javabaguwen.com/img/%E6%AD%BB%E9%94%811.png\\",\\"https://javabaguwen.com/img/%E6%AD%BB%E9%94%812.png\\",\\"https://javabaguwen.com/img/%E6%AD%BB%E9%94%813.png\\",\\"https://javabaguwen.com/img/%E6%AD%BB%E9%94%814.png\\"],\\"dateModified\\":\\"2025-04-29T06:25:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1745907928000,"updatedTime":1745907928000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":1}]},"readingTime":{"minutes":2.55,"words":766},"filePathRelative":"mysql/dead.md","localizedDate":"2025年4月29日","autoDesc":true}');export{r as comp,u as data};
