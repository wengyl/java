import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,e as a,o as r}from"./app-CzKZ5RuK.js";const s={};function i(o,e){return r(),n("div",null,e[0]||(e[0]=[a('<p><strong>面试官：</strong> 我看你的简历上写着<strong>精通MySQL</strong>，问你个简单的问题，<strong>MySQL联合索引</strong>有什么特性？</p><blockquote><p>心想，这还不简单，这不是问到我手心里了吗？ 听我给你背一遍八股文！</p></blockquote><p><strong>我：</strong> <strong>MySQL联合索引</strong>遵循最左前缀匹配原则，即最左优先，查询的时候会优先匹配最左边的索引。 例如当我们在**(a,b,c)**三个字段上创建联合索引时，实际上是创建了三个索引，分别是(a)、(a,b)、(a,b,c)。 查询条件中包含这些索引的时候，查询就会用到索引。例如下面的查询条件，就可以用到索引：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>select * from table_name where a=?;\nselect * from table_name where a=? and b=?;\nselect * from table_name where a=? and b=? and c=?;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其他查询条件不包含这些索引的查询语句，就不会用到索引，例如：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>select * from table_name where b=?;\nselect * from table_name where c=?;\nselect * from table_name where b=? and c=?;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果查询条件包含(a,c)，也会用到索引，相当于用到了(a)索引。</p><p><strong>面试官：</strong> 小伙子，你的八股文背的挺熟啊。 <strong>我：</strong> 也没有辣，我只是平常热爱学习知识，经常做一些总结汇总，所以就脱口而出了。 <strong>面试官：</strong> 别开染坊了，我再问你，<strong>MySQL联合索引</strong>一定遵循最左前缀匹配原则吗？</p><blockquote><p>我擦，这把我问的不自信了。</p></blockquote><p><strong>我：</strong> 嗯……，<strong>MySQL联合索引</strong>可能有时候不遵循最左前缀匹配原则。 <strong>面试官：</strong> 什么时候遵循？什么时候不遵循？ <strong>我：</strong> 可能是晴天遵循，下雨了就不遵循了，每个月那几天不舒服的时候也不遵循了…… <strong>面试官：</strong> 好吧，今天面试就到这了，你先回去等通知，有后续消息会联系你的。</p><blockquote><p>我擦，这叫什么问题啊？ 什么遵循不遵循？ 难道是面试官跟我背的八股文不是同一套？</p></blockquote><p>回去到MySQL官网上翻了一下，才发现面试官想问的是<strong>索引跳跃扫描（Index Skip Scan）</strong>。 MySQL8.0版本开始增加了<strong>索引跳跃扫描</strong>的功能，当第一列索引的唯一值较少时，即使where条件没有第一列索引，查询的时候也可以用到联合索引。 造点数据验证一下，先创建一张用户表：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>CREATE TABLE `user` (\n  `id` int NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  `name` varchar(255) NOT NULL COMMENT &#39;姓名&#39;,\n  `gender` tinyint NOT NULL COMMENT &#39;性别&#39;,\n  PRIMARY KEY (`id`),\n  KEY `idx_gender_name` (`gender`,`name`)\n) ENGINE=InnoDB COMMENT=&#39;用户表&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在性别和姓名两个字段上(<code>gender</code>,<code>name</code>)建立联合索引，性别字段只有两个枚举值。 执行SQL查询验证一下：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>explain select * from user where name=&#39;一灯&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://javabaguwen.com/img/索引跳跃.png" alt="image-20220803213714714.png" loading="lazy"> 虽然SQL查询条件只有name字段，但是从执行计划中看到依然是用了联合索引。 并且Extra列中显示增加了<strong>Using index for skip scan</strong>，表示用到了<strong>索引跳跃扫描</strong>的优化逻辑。 具体优化方式，就是匹配的时候遇到第一列索引就跳过，直接匹配第二列索引的值，这样就可以用到联合索引了。 其实我们优化一下SQL，把第一列的所有枚举值加到where条件中，也可以用到联合索引：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>select * from user where gender in (0,1) and name=&#39;一灯&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>看来还是需要经常更新自己的知识体系，一不留神就out了！</p>',18)]))}const c=t(s,[["render",i],["__file","skip.html.vue"]]),m=JSON.parse('{"path":"/mysql/skip.html","title":"","lang":"zh-CN","frontmatter":{"description":"面试官： 我看你的简历上写着精通MySQL，问你个简单的问题，MySQL联合索引有什么特性？ 心想，这还不简单，这不是问到我手心里了吗？ 听我给你背一遍八股文！ 我： MySQL联合索引遵循最左前缀匹配原则，即最左优先，查询的时候会优先匹配最左边的索引。 例如当我们在**(a,b,c)**三个字段上创建联合索引时，实际上是创建了三个索引，分别是(a)、...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/mysql/skip.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"面试官： 我看你的简历上写着精通MySQL，问你个简单的问题，MySQL联合索引有什么特性？ 心想，这还不简单，这不是问到我手心里了吗？ 听我给你背一遍八股文！ 我： MySQL联合索引遵循最左前缀匹配原则，即最左优先，查询的时候会优先匹配最左边的索引。 例如当我们在**(a,b,c)**三个字段上创建联合索引时，实际上是创建了三个索引，分别是(a)、..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javabaguwen.com/img/%E7%B4%A2%E5%BC%95%E8%B7%B3%E8%B7%83.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-29T06:25:28.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-04-29T06:25:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://javabaguwen.com/img/%E7%B4%A2%E5%BC%95%E8%B7%B3%E8%B7%83.png\\"],\\"dateModified\\":\\"2025-04-29T06:25:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1745907928000,"updatedTime":1745907928000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":1}]},"readingTime":{"minutes":2.92,"words":875},"filePathRelative":"mysql/skip.md","localizedDate":"2025年4月29日","autoDesc":true}');export{c as comp,m as data};
