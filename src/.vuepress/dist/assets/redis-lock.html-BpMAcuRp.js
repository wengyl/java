import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e,o}from"./app-CzKZ5RuK.js";const t={};function l(c,n){return o(),a("div",null,n[0]||(n[0]=[e(`<h2 id="基于redis实现分布式锁的正确姿势" tabindex="-1"><a class="header-anchor" href="#基于redis实现分布式锁的正确姿势"><span>基于Redis实现分布式锁的正确姿势</span></a></h2><p>在单体应用时代，Java并发编程中的 <code>synchronized</code> 关键字或 <code>ReentrantLock</code> 能够轻松解决多线程对共享资源的互斥访问。然而，随着系统演进到分布式架构，当同一资源（例如数据库中的一行记录、有限的商品库存）可能被部署在不同服务器、不同进程中的多个线程同时访问时，传统的 JVM 内置锁就失去了作用。此时，我们就需要一个<strong>分布式锁</strong>来协调跨进程、跨主机的访问。</p><p>分布式锁需要满足一系列严苛的特性，而利用Redis实现分布式锁因其高性能、简单易用且具备原子命令等特性而成为一种常见的选择。但“看起来简单”往往是最大的陷阱，基于Redis实现一个<strong>正确可靠</strong>的分布式锁并非简单地 <code>SETNX</code> 和 <code>DEL</code> 即可。本文将带你深入理解分布式锁应具备的特性，剖析基于Redis实现的演进过程，学习正确的实现方式，并了解更复杂的场景（如故障转移）如何处理。</p><h3 id="一、-引言-为什么需要分布式锁" tabindex="-1"><a class="header-anchor" href="#一、-引言-为什么需要分布式锁"><span>一、 引言： 为什么需要分布式锁？</span></a></h3><p>想象一个场景：多个部署在不同服务器上的服务实例，需要同时修改数据库中某个商品的库存。如果不加控制，它们可能同时读取到库存为10，然后都执行减1操作，最终库存变成了9，而不是正确的8。分布式锁就是为了解决这种<strong>分布式环境下的并发控制问题</strong>，确保在任何时刻，对某个共享资源的访问都是互斥的。</p><p>为什么考虑Redis实现分布式锁？</p><ul><li><strong>速度快：</strong> Redis是内存数据库，读写性能极高。</li><li><strong>原子命令：</strong> Redis提供了许多原子性的命令（如 <code>SETNX</code>, <code>SET</code> 的扩展参数，Lua脚本），这是实现分布式锁的基础。</li><li><strong>广泛使用：</strong> 大多数互联网应用已经部署了Redis，无需额外引入其他复杂组件。</li></ul><p>但是，分布式环境的复杂性（网络延迟、部分节点故障、客户端崩溃）使得实现一个正确可靠的分布式锁充满挑战。</p><h3 id="二、-分布式锁应满足的特性" tabindex="-1"><a class="header-anchor" href="#二、-分布式锁应满足的特性"><span>二、 分布式锁应满足的特性</span></a></h3><p>一个<strong>正确可靠</strong>的分布式锁至少应满足以下几个特性：</p><ol><li><strong>互斥性 (Mutual Exclusion):</strong> 在任何时刻，<strong>只有一个客户端</strong>能够成功获取锁。</li><li><strong>避免死锁 (Deadlock Prevention):</strong> 即使持有锁的客户端崩溃、进程被杀死或网络中断，未能正常释放锁，锁最终也能被释放，不无限期地阻塞其他客户端。通常通过为锁设置<strong>过期时间</strong>来实现。</li><li><strong>容错性 (Fault Tolerance):</strong> 只要分布式锁服务（Redis节点）的大多数是可用的，客户端就能够获取和释放锁。这对于基于多个Redis节点实现的锁服务（如Redlock）很重要。</li><li><strong>(关键!) 解铃还须系铃人 (&quot;Release Only My Own Lock&quot;):</strong> <strong>持有锁的客户端必须只能释放自己持有的锁，不能释放由其他客户端持有的锁。</strong> 这是防止误删的关键。</li></ol><h3 id="三、-基于redis的实现演进-从幼稚到正确" tabindex="-1"><a class="header-anchor" href="#三、-基于redis的实现演进-从幼稚到正确"><span>三、 基于Redis的实现演进：从幼稚到正确</span></a></h3><p>我们将通过几个尝试，一步步揭示如何实现一个正确的Redis分布式锁。</p><ul><li><p><strong>幼稚方案1：<code>SETNX key 1</code> + <code>DEL key</code></strong></p><ul><li><strong>加锁：</strong> 客户端尝试执行 <code>SETNX lock_key 1</code>。如果返回1，表示之前Key不存在，成功获取锁。如果返回0，表示Key已存在，获取锁失败。</li><li><strong>解锁：</strong> 客户端执行完业务逻辑后，执行 <code>DEL lock_key</code> 释放锁。</li><li><strong>问题：</strong> <strong>严重缺陷在于没有过期时间！</strong> 如果客户端在 <code>SETNX</code> 成功获取锁后，但在执行 <code>DEL</code> 命令之前崩溃或网络中断，<code>lock_key</code> 将永远存在于Redis中，导致<strong>死锁</strong>，其他客户端再也无法获取该锁。</li></ul></li><li><p><strong>幼稚方案2：<code>SETNX key 1</code> + <code>EXPIRE key seconds</code> + <code>DEL key</code></strong></p><ul><li><strong>加锁：</strong><ol><li>客户端执行 <code>SETNX lock_key 1</code>。</li><li>如果返回1（获取锁成功），再执行 <code>EXPIRE lock_key seconds</code> 为锁设置过期时间。</li></ol></li><li><strong>解锁：</strong> 同方案1，执行 <code>DEL lock_key</code>。</li><li><strong>问题：</strong> 解决了死锁问题（至少有过期时间兜底），但引入了<strong>原子性问题！</strong> <code>SETNX</code> 和 <code>EXPIRE</code> 是两个分开的命令。如果在客户端执行完 <code>SETNX</code> 成功获取锁后，但在执行 <code>EXPIRE</code> 命令之前<strong>发生崩溃或网络中断</strong>，Key 虽然被设置了，但没有设置过期时间，仍然会导致<strong>死锁</strong>。</li></ul></li><li><p><strong>正确实现 (单实例 Redis)：<code>SET key unique_value NX EX seconds</code> + Lua脚本释放锁</strong></p><ul><li><p>Redis 2.6.12 版本引入了 <code>SET</code> 命令的扩展参数，允许在一个命令中同时设置 Key、值、NX/XX 条件和过期时间。这为实现原子性的加锁操作提供了基础。</p></li><li><p><strong>原子加锁：</strong> 客户端执行以下命令尝试获取锁：</p><div class="language-redis line-numbers-mode" data-ext="redis" data-title="redis"><pre class="language-redis"><code>SET lock_key unique_value NX EX seconds
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>lock_key</code>: 用作锁的Key名。</li><li><code>unique_value</code>: 一个<strong>唯一的值</strong>，用来标识当前锁的持有者。例如，可以使用一个UUID、客户端ID与当前时间戳的组合等。这个值是实现“解铃还须系铃人”的关键。</li><li><code>NX</code>: 只在 <code>lock_key</code> <strong>不存在 (Not eXists)</strong> 时执行 SET 操作。如果 Key 已存在（锁已被其他客户端持有），则 SET 失败，返回 null。这保证了<strong>互斥性</strong>，只有一个客户端能成功设置 Key。</li><li><code>EX seconds</code>: 设置 Key 的过期时间（秒）。保证<strong>避免死锁</strong>。</li><li><strong>这两个条件 (<code>NX</code> 和 <code>EX</code>) 是原子地执行的。</strong> 成功获取锁时，Key 会被原子地设置并带有过期时间，解决了方案2的原子性问题。</li></ul></li><li><p><strong>锁的值 (<code>unique_value</code>) 的重要性：</strong> 必须为锁设置一个唯一的值。这个值的作用在于，释放锁时需要验证当前 Key 的 Value 是否等于自己在加锁时设置的唯一值，以此来确认当前持有的锁是否还是自己加的锁（防止锁过期后被其他客户端获取，然后自己误删）。</p></li><li><p><strong>安全释放锁：</strong> <strong>不能简单地使用 <code>DEL lock_key</code>。</strong></p><ul><li><strong>错误场景重现：</strong> 客户端 A 获取锁成功 (<code>SET lock_key unique_value_A NX EX 10</code>)。客户端 A 业务处理耗时15秒。10秒后，锁自动过期并被 Redis 删除。客户端 B 在第11秒尝试加锁，成功获取锁 (<code>SET lock_key unique_value_B NX EX 10</code>)。第15秒，客户端 A 的业务处理完成，执行 <code>DEL lock_key</code> 释放锁。此时 <code>lock_key</code> 的 Value 是 <code>unique_value_B</code>，但客户端 A 会直接删除 Key，误删了客户端 B 持有的锁，破坏了互斥性！</li><li><strong>使用 Lua 脚本原子释放锁：</strong> 为了实现安全的释放锁，需要<strong>原子地</strong>完成“判断锁是否归我所有，是则删除”的操作。Redis 执行 Lua 脚本是原子性的，可以将判断和删除逻辑封装在一个 Lua 脚本中。<div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code><span class="token comment">-- keys[1]: 锁的key名 (lock_key)</span>
<span class="token comment">-- ARGV[1]: 客户端加锁时设置的唯一值 (unique_value)</span>
<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;get&#39;</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">then</span>
    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;del&#39;</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>这个脚本的功能是：获取 Key 的当前值，如果等于传入的唯一值，就执行 <code>DEL</code> 并返回1（表示成功删除）；否则返回0（表示未删除，锁不是自己的或已过期）。客户端执行完业务逻辑后，调用这个 Lua 脚本来释放锁。</li><li><strong>Java客户端实现：</strong> 使用 Jedis 或 Lettuce 等客户端执行 <code>SET lockKey uniqueValue &quot;NX&quot; &quot;EX&quot; seconds</code> 进行加锁，使用 <code>jedis.eval(luaScript, keys, args)</code> 执行 Lua 脚本进行解锁。</li></ul></li><li><p><strong>锁的过期时间：</strong> 如何选择合适的过期时间是个挑战。太短可能导致任务未执行完锁就过期；太长可能增加死锁风险。如果任务执行时间不确定且可能超过锁过期时间，需要实现<strong>锁续期</strong>机制。</p></li><li><p><strong>锁续期 (Watchdog)：</strong> 实现锁续期的思路是，获取锁成功的客户端启动一个<strong>后台线程（Watchdog）</strong>，定期检查锁是否仍然由当前客户端持有（通过检查 Key 的 Value 是否仍是自己的唯一值），如果持有，就重新设置 Key 的过期时间（例如，每次续期为新的过期时间）。这是一个权衡，续期频率太高增加 Redis 压力，太低可能续期失败。</p></li></ul></li></ul><h3 id="四、-考虑故障转移-redlock算法" tabindex="-1"><a class="header-anchor" href="#四、-考虑故障转移-redlock算法"><span>四、 考虑故障转移：Redlock算法</span></a></h3><p>上述单实例实现是正确的，但在 Redis <strong>单实例</strong>（即使是 Master-Replica 架构，但如果 Master 宕机且使用了异步复制，锁数据可能未同步到 Replica，Replica 晋升后锁就丢失了）发生故障时，可能导致锁丢失，从而多个客户端同时获取锁，破坏互斥性。为了解决<strong>多节点故障下的分布式锁容错性</strong>，Redis 作者 Antirez 提出了 <strong>Redlock</strong> 算法。</p><ul><li><strong>Redlock算法：</strong><ul><li><strong>原理：</strong> Redlock 算法不依赖于某个单一的 Redis 实例或主从架构，而是在<strong>多个独立、不互通</strong>的 Redis 主节点上（例如 $N$ 个，通常取 $N \\ge 5$）尝试同时获取锁。</li><li><strong>加锁过程：</strong><ol><li>客户端获取当前<strong>精确时间</strong> $T_1$。</li><li>客户端尝试向 $N$ 个独立的 Redis Master <strong>并行</strong>发送 <code>SET key unique_value NX EX timeout</code> 命令。这里的 <code>timeout</code> 要设置得非常小（例如50-100毫秒），用于快速失败，避免长时间等待宕机节点。</li><li>客户端记录获取所有锁的时间 $T_2$。</li><li>客户端检查： <ul><li>是否在<strong>大多数 (Majority)</strong> Redis 实例上成功获取锁（即至少 $N/2 + 1$ 个）。</li><li>获取锁的总耗时 ($T_2 - T_1$) 是否小于锁设定的<strong>有效时间</strong>（这是一个预设的值，比如30秒，且要大于所有节点的 <code>timeout</code>）。</li></ul></li><li><strong>如果两个条件都满足</strong>，客户端认为成功获取锁。锁的实际有效时间等于设定的有效时间减去获取锁的总耗时（用来扣除网络延迟和时钟漂移的影响）。</li><li><strong>如果任一条件不满足</strong>，客户端立即向所有已尝试获取锁的 Redis 实例发送 <code>DEL key</code> 命令，释放可能获取到的部分锁。</li></ol></li><li><strong>为什么是大多数？</strong> 解释在分布式系统中，如果能获得大多数节点的同意，就可以在一定程度上容忍少数节点故障或网络分区，保证锁的唯一性。</li><li><strong>释放锁：</strong> 客户端向所有 $N$ 个 Redis 实例发送 <code>DEL key</code> 命令，无论之前是否在该实例成功获取锁。</li><li><strong>优劣：</strong><ul><li><strong>优点：</strong> 针对独立节点故障设计，提高了分布式锁的容错性和可用性。</li><li><strong>缺点：</strong> 实现复杂，需要部署和管理多个独立的 Redis 实例。关于其安全性存在一些争议，特别是对系统时钟同步的依赖问题。性能开销相对较大（需要并行访问多个节点）。</li></ul></li><li><strong>面试关联点：</strong> Redlock 是分布式锁的高阶话题。需要解释其设计目的、加锁步骤、如何通过多数派保证在部分节点故障下锁的唯一性，以及其优缺点和争议。</li></ul></li></ul><h3 id="五、-redis分布式锁-vs-zookeeper-etcd分布式锁" tabindex="-1"><a class="header-anchor" href="#五、-redis分布式锁-vs-zookeeper-etcd分布式锁"><span>五、 Redis分布式锁 vs Zookeeper/Etcd分布式锁</span></a></h3><ul><li><strong>基于 Redis 的锁：</strong><ul><li><strong>优点：</strong> 性能高，实现相对简单（特别是单实例正确实现），复用现有 Redis 基础设施。</li><li><strong>缺点：</strong> 单实例有单点故障风险，Redlock 相对复杂且有争议，不如 ZK/Etcd 在实现公平锁、可重入锁、监听锁状态变化等方面原生支持好。</li></ul></li><li><strong>基于 Zookeeper/Etcd 的锁：</strong><ul><li><strong>优点：</strong> 依赖于 ZK/Etcd 的强一致性和 Watch 机制、临时节点等特性，更容易实现可靠、功能丰富的分布式锁（如公平锁、可重入锁）。</li><li><strong>缺点：</strong> 读写延迟通常高于 Redis，需要额外部署和维护 ZK/Etcd 集群。</li></ul></li></ul><p><strong>结论：</strong> 对于大多数业务场景，<strong>基于高可用 Redis 架构（Sentinel 或 Cluster）的单实例正确实现</strong>（原子加锁 + Lua 安全释放 + Watchdog 续期）已经足够可靠，且性能最优。Redlock 适用于对锁服务容错性要求极高，且能接受其复杂性和争议的场景。对于需要复杂锁特性（如公平锁、可重入锁）或已依赖 ZK/Etcd 集群的场景，基于 ZK/Etcd 的锁是更好的选择。</p><h3 id="六、-潜在问题与最佳实践" tabindex="-1"><a class="header-anchor" href="#六、-潜在问题与最佳实践"><span>六、 潜在问题与最佳实践</span></a></h3><ul><li><strong>回顾并强调的坑：</strong> <code>SETNX</code> 无过期、<code>SETNX</code> + <code>EXPIRE</code> 非原子、<code>DEL</code> 不安全（未验证锁持有者）。这些是绝对要避免的错误。</li><li><strong>锁过期时间过短（无续期）：</strong> 如果任务执行时间不确定或可能较长，<strong>必须实现锁续期机制</strong>（Watchdog）来避免锁在任务执行过程中过期。</li><li><strong>Redlock 的争议与时钟同步问题：</strong> 了解 Redlock 的争议，意识到其对系统时钟同步有一定依赖，在极端情况下可能存在问题。</li><li><strong>JVM 暂停影响锁续期：</strong> 如果客户端 JVM 发生长时间 GC 暂停，可能导致 Watchdog 线程无法及时续期，锁过期后被其他客户端获取。</li><li><strong>网络分区：</strong> 复杂的网络分区可能影响客户端与 Redis 节点的通信，导致锁获取或释放失败。</li><li><strong>最佳实践：</strong><ul><li><strong>始终使用 <code>SET key unique_value NX EX seconds</code> 原子加锁。</strong></li><li><strong>始终使用 Lua 脚本进行原子且安全的释放锁（检查唯一值）。</strong></li><li><strong>为长时间运行的任务实现锁续期机制 (Watchdog)。</strong></li><li>选择合适的锁过期时间，并考虑网络延迟。</li><li><strong>强烈推荐使用成熟的分布式锁库：</strong> 例如 Java 的 <strong>Redisson</strong> 库。Redisson 内置了上述<strong>单实例正确实现</strong>（包括原子加锁、Lua 脚本释放、Watchdog 锁续期）以及 <strong>Redlock 算法</strong>的实现，并提供了 <code>RLock</code> 接口，支持可重入锁、公平锁等高级特性，极大地简化了开发并降低了出错的可能性。<strong>面试中提到使用 Redisson 等库，并理解其原理，会是很大的加分项。</strong></li><li><strong>理解单实例 vs Redlock 的权衡，根据业务对可靠性的真实需求进行选择。</strong></li></ul></li></ul><h3 id="七、-java库-redisson-简介" tabindex="-1"><a class="header-anchor" href="#七、-java库-redisson-简介"><span>七、 Java库 Redisson 简介</span></a></h3><p>Redisson 是一个功能丰富的 Redis 客户端，提供了分布式对象和服务。其中最重要的就是分布式锁 <code>RLock</code>。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// Redisson 分布式锁使用示例</span>
<span class="token class-name">Config</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 配置单机、Sentinel 或 Cluster</span>
config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">&quot;redis://127.0.0.1:6379&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// config.useClusterServers().addNodeAddress(...);</span>

<span class="token class-name">RedissonClient</span> redisson <span class="token operator">=</span> <span class="token class-name">Redisson</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">RLock</span> lock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">&quot;myDistributedLock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取一个锁对象</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 尝试获取锁，最多等待 100 秒，锁自动过期时间 10 秒</span>
    <span class="token comment">// Redisson 内置 Watchdog 续期，默认锁过期时间 30 秒，到期前会自动续期</span>
    <span class="token keyword">boolean</span> isLocked <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>isLocked<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 成功获取锁，执行业务逻辑</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;成功获取锁，执行业务逻辑...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ... 业务代码 ...</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟业务执行 5 秒，Watchdog 会自动续期</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取锁失败</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;获取锁失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;获取锁过程中被中断&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">isHeldByCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 确保只释放自己持有的锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;释放锁&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

redisson<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Redisson 内部实现了复杂的 <code>SET NX EX</code> 加锁、Lua 脚本解锁、Watchdog 锁续期以及 Redlock 算法等逻辑，极大地简化了分布式锁的使用。</p><h3 id="八、-面试官视角-分布式锁的考察点" tabindex="-1"><a class="header-anchor" href="#八、-面试官视角-分布式锁的考察点"><span>八、 面试官视角：分布式锁的考察点</span></a></h3><p>分布式锁是面试中考察候选人是否具备解决复杂并发和分布式问题能力的“试金石”。面试官希望通过这个问题：</p><ul><li>考察你对分布式系统理论（互斥、死锁、容错）的理解。</li><li>考察你对Redis底层特性（原子命令、Lua、过期时间）的掌握。</li><li>考察你分析问题和解决问题的思路（从简单到复杂，识别错误并改进）。</li><li>考察你对常见分布式组件（Redis vs ZK）优劣的认知。</li><li>考察你是否了解并使用过业界成熟的解决方案（如 Redisson）。</li></ul><p>面试中常会让你手写或口述基于Redis实现分布式锁的流程，然后逐步追问各种异常场景（客户端崩溃、网络中断、锁过期、Redis宕机）下的表现和如何优化。</p><h3 id="九、-总结" tabindex="-1"><a class="header-anchor" href="#九、-总结"><span>九、 总结</span></a></h3><p>分布式锁是分布式系统中协调共享资源访问的关键机制。利用 Redis 实现分布式锁因其高性能和原子操作而成为热门选择，但实现一个<strong>正确可靠</strong>的 Redis 分布式锁并非易事。</p><p>正确的实现姿势是：采用 <strong><code>SET key unique_value NX EX seconds</code> 原子命令进行加锁</strong>，并使用<strong>包含唯一值判断的 Lua 脚本进行原子释放锁</strong>，同时为长时间运行的任务实现<strong>锁续期 (Watchdog)</strong> 机制，避免锁在任务执行过程中过期。</p><p>为了应对 Redis 节点故障导致的锁丢失风险，可以考虑更复杂的 <strong>Redlock 算法</strong>，在多个独立 Redis 节点上尝试获取锁，通过多数派原则保证锁的唯一性，但这会增加实现的复杂性。</p><p>对于大多数 Java 应用，使用<strong>基于高可用 Redis 架构（Sentinel/Cluster）的单实例正确实现</strong>，并辅以 <strong>Watchdog 续期</strong>，通过 <strong>Redisson</strong> 等成熟的分布式锁库来简化开发，是性能与可靠性的良好平衡。</p><hr>`,36)]))}const d=s(t,[["render",l],["__file","redis-lock.html.vue"]]),r=JSON.parse('{"path":"/redis/redis-lock.html","title":"","lang":"zh-CN","frontmatter":{"description":"基于Redis实现分布式锁的正确姿势 在单体应用时代，Java并发编程中的 synchronized 关键字或 ReentrantLock 能够轻松解决多线程对共享资源的互斥访问。然而，随着系统演进到分布式架构，当同一资源（例如数据库中的一行记录、有限的商品库存）可能被部署在不同服务器、不同进程中的多个线程同时访问时，传统的 JVM 内置锁就失去了作用...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/redis/redis-lock.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"基于Redis实现分布式锁的正确姿势 在单体应用时代，Java并发编程中的 synchronized 关键字或 ReentrantLock 能够轻松解决多线程对共享资源的互斥访问。然而，随着系统演进到分布式架构，当同一资源（例如数据库中的一行记录、有限的商品库存）可能被部署在不同服务器、不同进程中的多个线程同时访问时，传统的 JVM 内置锁就失去了作用..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-01T16:05:51.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-05-01T16:05:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-01T16:05:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"基于Redis实现分布式锁的正确姿势","slug":"基于redis实现分布式锁的正确姿势","link":"#基于redis实现分布式锁的正确姿势","children":[{"level":3,"title":"一、 引言： 为什么需要分布式锁？","slug":"一、-引言-为什么需要分布式锁","link":"#一、-引言-为什么需要分布式锁","children":[]},{"level":3,"title":"二、 分布式锁应满足的特性","slug":"二、-分布式锁应满足的特性","link":"#二、-分布式锁应满足的特性","children":[]},{"level":3,"title":"三、 基于Redis的实现演进：从幼稚到正确","slug":"三、-基于redis的实现演进-从幼稚到正确","link":"#三、-基于redis的实现演进-从幼稚到正确","children":[]},{"level":3,"title":"四、 考虑故障转移：Redlock算法","slug":"四、-考虑故障转移-redlock算法","link":"#四、-考虑故障转移-redlock算法","children":[]},{"level":3,"title":"五、 Redis分布式锁 vs Zookeeper/Etcd分布式锁","slug":"五、-redis分布式锁-vs-zookeeper-etcd分布式锁","link":"#五、-redis分布式锁-vs-zookeeper-etcd分布式锁","children":[]},{"level":3,"title":"六、 潜在问题与最佳实践","slug":"六、-潜在问题与最佳实践","link":"#六、-潜在问题与最佳实践","children":[]},{"level":3,"title":"七、 Java库 Redisson 简介","slug":"七、-java库-redisson-简介","link":"#七、-java库-redisson-简介","children":[]},{"level":3,"title":"八、 面试官视角：分布式锁的考察点","slug":"八、-面试官视角-分布式锁的考察点","link":"#八、-面试官视角-分布式锁的考察点","children":[]},{"level":3,"title":"九、 总结","slug":"九、-总结","link":"#九、-总结","children":[]}]}],"git":{"createdTime":1745924024000,"updatedTime":1746115551000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":2}]},"readingTime":{"minutes":14.53,"words":4358},"filePathRelative":"redis/redis-lock.md","localizedDate":"2025年4月29日","autoDesc":true}');export{d as comp,r as data};
