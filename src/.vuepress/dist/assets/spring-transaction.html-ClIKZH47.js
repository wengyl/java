import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,e as o,o as e}from"./app-CzKZ5RuK.js";const t={};function c(i,n){return e(),s("div",null,n[0]||(n[0]=[o(`<p>事务（Transaction）是保障数据一致性的基石。在复杂的业务场景下，一个完整的业务操作往往涉及对多个数据资源的访问和修改。如果这些操作中的任何一步失败，我们希望之前已经成功的步骤能够被撤销，就像这些操作从未发生过一样，从而保证数据的完整性和一致性。</p><hr><h2 id="深度解析-spring-事务管理-保障数据一致性的艺术" tabindex="-1"><a class="header-anchor" href="#深度解析-spring-事务管理-保障数据一致性的艺术"><span>深度解析 Spring 事务管理：保障数据一致性的艺术</span></a></h2><h3 id="引言-事务-保障数据一致性的基石" tabindex="-1"><a class="header-anchor" href="#引言-事务-保障数据一致性的基石"><span>引言：事务，保障数据一致性的基石</span></a></h3><p>想象一个最经典的场景：银行转账。需要从账户A扣款，并向账户B加款。这两个操作必须作为一个<strong>不可分割的整体</strong>来执行。如果在A扣款成功后，向B加款失败了（比如网络问题或账户B异常），但A的扣款却没有撤销，那么系统的数据就处于不一致的状态。</p><p>这就是事务要解决的核心问题。事务具有以下著名的ACID特性：</p><ul><li><strong>原子性 (Atomicity)：</strong> 事务是一个不可分割的最小工作单元。要么所有操作都成功，要么所有操作都失败并回滚到事务开始前的状态。如同化学中的原子，不可再分。</li><li><strong>一致性 (Consistency)：</strong> 事务必须使数据库从一个一致性状态变换到另一个一致性状态。在事务开始之前和结束之后，数据库的完整性约束没有被破坏。</li><li><strong>隔离性 (Isolation)：</strong> 多个并发事务之间是相互隔离的，互不影响。一个事务的中间状态对其他事务是不可见的。这防止了脏读、不可重复读、幻读等问题。</li><li><strong>持久性 (Durability)：</strong> 事务一旦提交，其结果就是永久性的，即使系统发生故障也不会丢失。</li></ul><p>在传统的 Java EE 开发中，管理事务往往需要侵入到业务代码中，手动获取连接、开启事务、提交或回滚事务、处理异常、关闭连接等，代码冗余且与业务逻辑耦合紧密。</p><p>Spring 框架的事务管理正是为了解决这些痛点而生。它提供了一套统一的抽象层，让我们可以用标准化、简洁的方式来管理事务，而无需关心底层是 JDBC、JPA、Hibernate 还是 JTA 等不同的事务 API。</p><p>Spring 提供了两种主要的事务管理方式：<strong>编程式事务</strong>和<strong>声明式事务</strong>。</p><h3 id="spring-事务管理概述" tabindex="-1"><a class="header-anchor" href="#spring-事务管理概述"><span>Spring 事务管理概述</span></a></h3><p>Spring 事务管理的核心在于其<strong>事务抽象层</strong>。通过 <code>org.springframework.transaction.PlatformTransactionManager</code> 接口，Spring屏蔽了底层数据访问技术的事务细节。无论你使用的是 JDBC、各种 ORM 框架，甚至是 JTA 这种分布式事务规范，Spring 都能通过对应的 <code>PlatformTransactionManager</code> 实现类来统一管理事务操作。</p><ol><li><p><strong>编程式事务管理：</strong> 开发者需要在代码中手动调用事务管理 API 来控制事务的开始、提交和回滚。Spring 提供了 <code>PlatformTransactionManager</code> 接口供直接使用，或者更推荐使用 <code>TransactionTemplate</code> 类来简化编程式事务的样板代码。</p><ul><li><strong>优点：</strong> 灵活性高，可以对事务进行更精细的控制。</li><li><strong>缺点：</strong> 事务管理代码与业务逻辑耦合，增加了代码的侵入性和冗余。</li></ul></li><li><p><strong>声明式事务管理：</strong> 这是 Spring 推荐的主流方式。开发者只需通过配置（XML 或 注解）来声明事务的属性（如应用范围、传播行为、隔离级别等），具体的事务管理（开启、提交、回滚）由 Spring 容器在运行时通过 AOP 来完成，业务逻辑代码无需关心事务细节。</p><ul><li><strong>优点：</strong> 将事务管理与业务逻辑彻底分离，代码更简洁、更专注于业务实现，提高了可维护性。</li><li><strong>缺点：</strong> 相较于编程式事务，灵活性稍弱，对于复杂的事务场景可能需要仔细配置。</li></ul></li></ol><p>在绝大多数应用中，声明式事务因其带来的巨大便利性而成为首选。我们将重点深入探讨声明式事务，特别是 <code>@Transactional</code> 注解。</p><h3 id="声明式事务管理-transactional-的魔力" tabindex="-1"><a class="header-anchor" href="#声明式事务管理-transactional-的魔力"><span>声明式事务管理：<code>@Transactional</code> 的魔力</span></a></h3><p>声明式事务的核心是配置，而基于注解的声明式事务的核心就是 <code>@Transactional</code> 注解。</p><h4 id="启用声明式事务" tabindex="-1"><a class="header-anchor" href="#启用声明式事务"><span>启用声明式事务</span></a></h4><p>要使用基于 <code>@Transactional</code> 注解的声明式事务，只需要在你的 Spring 配置类上添加 <code>@EnableTransactionManagement</code> 注解：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@EnableTransactionManagement</span> <span class="token comment">// 启用 Spring 的声明式事务管理</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionConfig</span> <span class="token punctuation">{</span>

    <span class="token comment">// 需要配置一个 PlatformTransactionManager Bean</span>
    <span class="token comment">// 例如，对于 JDBC/MyBatis</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">DataSourceTransactionManager</span> <span class="token function">transactionManager</span><span class="token punctuation">(</span><span class="token class-name">DataSource</span> dataSource<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DataSourceTransactionManager</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 对于 JPA</span>
    <span class="token comment">// @Bean</span>
    <span class="token comment">// public JpaTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {</span>
    <span class="token comment">//     JpaTransactionManager transactionManager = new JpaTransactionManager();</span>
    <span class="token comment">//     transactionManager.setEntityManagerFactory(entityManagerFactory);</span>
    <span class="token comment">//     return transactionManager;</span>
    <span class="token comment">// }</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你使用 XML 配置，则使用 <code>&lt;tx:annotation-driven/&gt;</code> 标签。</p><p><code>@EnableTransactionManagement</code> 的作用是导入 Spring 事务管理所需的后置处理器和其他基础设施 Bean，其中最重要的是一个能够解析 <code>@Transactional</code> 注解并创建事务代理的 BeanPostProcessor。</p><h4 id="transactional-注解详解" tabindex="-1"><a class="header-anchor" href="#transactional-注解详解"><span><code>@Transactional</code> 注解详解</span></a></h4><p><code>@Transactional</code> 注解可以应用于类或方法上。应用于类上时，表示该类中所有公共方法都将默认继承该注解的事务设置；应用于方法上时，会覆盖类级别的设置。</p><p>它提供了丰富的属性来控制事务的行为：</p><ul><li><p><strong><code>propagation</code> (传播行为)：</strong> <strong>这是 <code>@Transactional</code> 最复杂也是最重要的属性，面试必考。</strong> 它定义了事务方法在调用另一个事务方法时如何相互作用，即如何跨越方法调用边界“传播”事务。</p><ul><li><p><strong><code>REQUIRED</code> (默认)：</strong> 这是最常用的传播行为。</p><ul><li>如果当前存在事务，则加入该事务。</li><li>如果当前不存在事务，则新建一个事务。</li><li><strong>场景：</strong> 大多数简单的CRUD操作或业务逻辑方法，它们应该在一个已有的事务中执行，或者如果没事务，就开启自己的事务。就像方法调用时，事务来了就“接力”用，没来就自己“开一个”。</li></ul></li><li><p><strong><code>REQUIRES_NEW</code>：</strong> 总是新建一个事务。</p><ul><li>如果当前存在事务，则暂停（suspend）当前事务，新建一个独立的新事务。</li><li>新事务有自己的独立的提交和回滚。外部事务的回滚不会影响新事务的提交（当然，如果外部事务回滚，通常意味着整个操作失败，新事务的操作结果也可能被间接影响，但这取决于业务逻辑，从事务层面说，新事务的提交是独立的）。</li><li><strong>场景：</strong> 某些需要独立提交或回滚的子操作，即使外部事务失败，这个子操作也要记录下来（比如记录日志）。例如，在一个大事务中，调用一个记录操作日志的方法，这个日志记录应该独立于大事务提交，无论大事务是否回滚，日志都应该被保存。</li><li><strong>与 REQUIRED 的核心区别：</strong> <code>REQUIRED</code> 共享同一个物理事务连接和上下文，回滚时会影响调用方；<code>REQUIRES_NEW</code> 使用独立的物理事务连接，回滚互不影响（除了外部回滚可能导致新事务结果被丢弃）。就像 REQUIRED 是在同一个房间里继续工作，REQUIRES_NEW 是跑到另一个房间单独完成任务，完成后再回原房间。</li></ul></li><li><p><strong><code>SUPPORTS</code>：</strong> 支持当前事务。</p><ul><li>如果当前存在事务，则加入该事务。</li><li>如果当前不存在事务，则以非事务方式执行。</li><li><strong>场景：</strong> 某些只读操作，它们可以在事务中执行以保证数据一致性，但即使没有事务也不会报错，只是可能读到不一致的数据。</li></ul></li><li><p><strong><code>NOT_SUPPORTED</code>：</strong> 总是以非事务方式执行。</p><ul><li>如果当前存在事务，则暂停当前事务，以非事务方式执行。</li><li><strong>场景：</strong> 某些不需要事务支持的操作，且不希望影响或被外部事务影响（比如发送邮件、调用外部接口）。</li></ul></li><li><p><strong><code>NEVER</code>：</strong> 总是以非事务方式执行。</p><ul><li>如果当前存在事务，则抛出异常。</li><li><strong>场景：</strong> 明确禁止在事务环境中执行的操作。</li></ul></li><li><p><strong><code>MANDATORY</code>：</strong> 必须在事务中执行。</p><ul><li>如果当前存在事务，则加入该事务。</li><li>如果当前不存在事务，则抛出异常。</li><li><strong>场景：</strong> 某些操作<strong>必须</strong>作为大事务的一部分来执行，独立执行没有意义或可能出错。</li></ul></li><li><p><strong><code>NESTED</code>：</strong> 嵌套事务。</p><ul><li>如果当前存在事务，则嵌套在当前事务中执行，通过数据库的 Savepoint 实现。嵌套事务的回滚只会回滚到当前 Savepoint，不影响外部事务。但外部事务的回滚会回滚包括嵌套事务在内的所有操作。</li><li>如果当前不存在事务，则行为与 <code>REQUIRED</code> 一致（新建一个事务）。</li><li><strong>与 REQUIRES_NEW 的区别：</strong> <code>REQUIRES_NEW</code> 是完全独立的新事务；<code>NESTED</code> 是在外部事务内部创建的一个“检查点”，回滚范围受限但不是完全独立。它依赖于底层数据源是否支持 Savepoint。</li></ul></li></ul></li><li><p><strong><code>isolation</code> (隔离级别)：</strong> 控制事务的隔离程度，旨在解决并发事务引起的问题。</p><ul><li><code>DEFAULT</code>: 使用底层数据库默认的隔离级别。</li><li><code>READ_UNCOMMITTED</code> (读未提交)：最低级别，可能发生脏读、不可重复读、幻读。</li><li><code>READ_COMMITTED</code> (读已提交)：解决脏读。可能发生不可重复读、幻读。</li><li><code>REPEATABLE_READ</code> (可重复读)：解决脏读、不可重复读。可能发生幻读。(MySQL默认)</li><li><code>SERIALIZABLE</code> (串行化)：最高级别，解决所有问题，但并发性能最低。</li><li><strong>建议：</strong> 大多数情况下使用 <code>DEFAULT</code>，让数据库来决定。除非有明确的需求且理解风险，不要随意调整隔离级别。</li></ul></li><li><p><strong><code>readOnly</code>：</strong> <code>boolean</code> 类型，默认为 <code>false</code>。设置为 <code>true</code> 时，表示该事务只进行读操作，不进行任何修改。某些数据库或ORM框架可能基于此进行优化（如不分配写锁，或者路由到只读副本）。</p><ul><li><strong>建议：</strong> 对于纯查询的方法，将其设置为 <code>readOnly=true</code> 是一种良好的实践。</li></ul></li><li><p><strong><code>timeout</code>：</strong> <code>int</code> 类型，以秒为单位，默认为底层事务系统的默认值。设置事务的超时时间，超过该时间事务会自动回滚。</p><ul><li><strong>建议：</strong> 对于可能长时间运行的事务，可以设置超时，防止资源长时间占用。</li></ul></li><li><p><strong><code>rollbackFor</code> / <code>noRollbackFor</code>：</strong> <code>Class[]</code> 类型，用于指定哪些异常应该/不应该触发事务回滚。</p><ul><li>默认情况下，Spring 声明式事务只对 <strong>运行时异常 (RuntimeException 及其子类)</strong> 和 <strong>Error</strong> 进行回滚。 Checked Exception (非 RuntimeException) 不会触发回滚。</li><li><strong><code>rollbackFor = {CustomException.class}</code>：</strong> 指定遇到 <code>CustomException</code>（即使是 Checked Exception）时进行回滚。</li><li><strong><code>noRollbackFor = {BusinessException.class}</code>：</strong> 指定遇到 <code>BusinessException</code>（即使是 RuntimeException 的子类）时也不回滚。</li><li><strong>场景：</strong> 当你的业务逻辑会抛出自定义的 Checked Exception，并且希望它触发回滚时，需要使用 <code>rollbackFor</code>。当某个运行时异常是预期内的业务逻辑，不应导致回滚时，使用 <code>noRollbackFor</code>。</li></ul></li></ul><h4 id="transactional-注解的优先级" tabindex="-1"><a class="header-anchor" href="#transactional-注解的优先级"><span><code>@Transactional</code> 注解的优先级</span></a></h4><p>如果 <code>@Transactional</code> 同时标注在类和方法上，<strong>方法上的注解会覆盖类上的注解设置</strong>。如果没有在方法上标注，则继承类上的设置。</p><h4 id="transactional-的实现原理-机制解析" tabindex="-1"><a class="header-anchor" href="#transactional-的实现原理-机制解析"><span><code>@Transactional</code> 的实现原理 (机制解析)</span></a></h4><p>理解 <code>@Transactional</code> 注解背后的实现原理，能帮助你更好地使用它并解决常见问题。</p><p>Spring 的声明式事务是基于 <strong>AOP (面向切面编程)</strong> 实现的（关联设计模式中的<strong>代理模式</strong>和之前的<strong>注解</strong>、<strong>Bean生命周期</strong>文章）。</p><p><strong>整个过程是这样的：</strong></p><ol><li><strong>启用机制：</strong> 你通过 <code>@EnableTransactionManagement</code> 注解（或 XML 配置）启用了 Spring 的声明式事务支持。</li><li><strong>注册 BeanPostProcessor：</strong> <code>@EnableTransactionManagement</code> 会向 Spring IoC 容器注册一个或多个 BeanPostProcessor（后置处理器），其中一个关键的就是负责处理事务注解的处理器。</li><li><strong>Bean 生命周期拦截：</strong> 在 Bean 的生命周期中，当一个 Bean 实例被创建并完成属性填充之后，这些 BeanPostProcessor 会介入 (<code>postProcessAfterInitialization</code> 阶段)。</li><li><strong>检查 <code>@Transactional</code>：</strong> 事务后置处理器会检查当前正在处理的 Bean 类及其公共方法上是否带有 <code>@Transactional</code> 注解。</li><li><strong>创建事务代理：</strong> 如果发现 <code>@Transactional</code> 注解，Spring 会为这个原始 Bean 创建一个 <strong>事务代理对象</strong>。这个代理对象会根据配置（目标类是否实现接口）使用 <strong>JDK 动态代理</strong> 或 <strong>CGLIB 代理</strong>。</li><li><strong>织入事务逻辑：</strong> 事务相关的切面 (Advisor) 和通知 (Advice)，其中最重要的是 <strong><code>TransactionInterceptor</code> (事务拦截器)</strong>，会被“织入”到代理对象中。</li><li><strong>代理拦截调用：</strong> 当外部代码调用这个 Bean 被 <code>@Transactional</code> 标注的方法时，实际调用的是 Spring 生成的<strong>代理对象</strong>的方法。</li><li><strong>事务拦截器工作：</strong> 代理对象拦截到方法调用后，会将控制权转交给 <code>TransactionInterceptor</code>。<code>TransactionInterceptor</code> 会读取被调用方法上的 <code>@Transactional</code> 注解属性，获取配置好的 <code>PlatformTransactionManager</code> Bean，然后开始执行事务管理逻辑： <ul><li>根据传播行为判断是加入现有事务、新建事务还是暂停事务等。</li><li>调用 <code>PlatformTransactionManager.getTransaction()</code> 开启事务或获取现有事务。</li><li>将数据源连接、Hibernate Session 等资源绑定到当前线程（利用 <code>TransactionSynchronizationManager</code>）。</li><li>调用原始 Bean 的业务方法。</li><li>方法执行完成后，根据方法是否正常返回或抛出异常（并结合 <code>@Transactional</code> 的 <code>rollbackFor</code>/<code>noRollbackFor</code> 规则）来决定是调用 <code>PlatformTransactionManager.commit()</code> 还是 <code>PlatformTransactionManager.rollback()</code>。</li><li>最后解绑线程资源。</li></ul></li></ol><p>所以，当你调用一个带有 <code>@Transactional</code> 注解的方法时，它已经不再是你原始对象的方法，而是被代理对象层层包装过的。</p><h3 id="spring-事务管理中的常见问题与陷阱" tabindex="-1"><a class="header-anchor" href="#spring-事务管理中的常见问题与陷阱"><span>Spring 事务管理中的常见问题与陷阱</span></a></h3><p>理解了 <code>@Transactional</code> 是通过 AOP 代理实现的，很多常见问题就迎刃而解了。</p><ol><li><p><strong>内部方法调用 (Self-invocation) 失效：</strong></p><ul><li><strong>场景：</strong> 在同一个类 <code>MyService</code> 中，方法 <code>methodA()</code> 没有 <code>@Transactional</code> 注解，但它调用了同类中带有 <code>@Transactional</code> 注解的 <code>methodB()</code>。</li><li><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>  <span class="token annotation punctuation">@Service</span>
  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>
      <span class="token comment">// ... 注入 UserRepository</span>

      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 没有事务注解</span>
          <span class="token comment">// ... 一些操作</span>
          <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 内部调用 methodB</span>
          <span class="token comment">// ... 一些操作</span>
      <span class="token punctuation">}</span>

      <span class="token annotation punctuation">@Transactional</span> <span class="token comment">// 期望这里有事务</span>
      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 数据操作 ...</span>
          <span class="token comment">// 如果这里出错，可能 methodA 的操作不会回滚</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>原因：</strong> 当外部代码调用 <code>methodA()</code> 时，是通过 <code>MyService</code> 的<strong>代理对象</strong>调用的。<code>methodA()</code> 方法本身没有事务，所以代理对象直接进入 <code>methodA()</code> 的方法体。在 <code>methodA()</code> 内部调用 <code>methodB()</code> 时，使用的是 <code>this.methodB()</code>。这里的 <code>this</code> 指的是原始的 <code>MyService</code> 对象，而不是 Spring 创建的那个代理对象。因此，对 <code>methodB()</code> 的调用绕过了事务代理，<code>@Transactional</code> 注解自然就失效了。</li><li><strong>解决办法：</strong><ul><li><strong>分离方法到不同类：</strong> 将 <code>methodB()</code> 移动到另一个 Service 类中，然后通过 <code>@Autowired</code> 注入这个新的 Service 类，再调用其 <code>methodB()</code> 方法。此时因为调用的是另一个 Bean 的方法，会通过 Spring 容器中的代理对象进行调用。</li><li><strong>注入自身代理对象：</strong> 在 <code>MyService</code> 类中注入自身的代理对象，通过代理对象来调用 <code>methodB()</code>。可以通过 <code>AopContext.currentProxy()</code> 获取当前代理，或者注入 <code>ApplicationContext</code> 后再 <code>getBean()</code> 获取自身。需要额外配置或开启 AOP Exposure。</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>
     <span class="token comment">// ...</span>
     <span class="token annotation punctuation">@Autowired</span>
     <span class="token keyword">private</span> <span class="token class-name">MyService</span> self<span class="token punctuation">;</span> <span class="token comment">// 注入自身代理 (需要 AOP Exposure 配置)</span>

     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// ...</span>
         self<span class="token punctuation">.</span><span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过代理调用 methodB</span>
         <span class="token comment">// ...</span>
     <span class="token punctuation">}</span>
     <span class="token annotation punctuation">@Transactional</span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong><code>private</code>, <code>protected</code>, <code>package-private</code> 方法上的 <code>@Transactional</code> 失效：</strong></p><ul><li><strong>原因：</strong> Spring AOP 默认的代理机制（无论是 JDK 动态代理还是 CGLIB）主要是针对<strong>公共方法</strong>进行拦截。非公共方法无法被代理对象拦截到，因此 <code>@Transactional</code> 注解不会生效。CGLIB 可以代理非 final 的非公共方法，但 Spring 的事务代理默认配置可能只拦截公共方法，且即使能代理，其他非 Spring AOP 的 AspectJ 编译时织入也需要注意非公共方法的处理。</li><li><strong>解决办法：</strong> 确保 <code>@Transactional</code> 注解应用于公共方法。如果必须在非公共方法上应用事务，可能需要考虑使用 AspectJ 的编译时织入或加载时织入，但这会增加项目复杂度。通常建议将需要事务的方法暴露为公共方法。</li></ul></li><li><p><strong>异常处理不当导致回滚失效：</strong></p><ul><li><strong>原因：</strong> Spring 默认只对 <code>RuntimeException</code> 及其子类和 <code>Error</code> 进行回滚。如果你的方法抛出了一个 <strong>Checked Exception</strong> (如 <code>IOException</code>, <code>SQLException</code> 等非 <code>RuntimeException</code> 的异常)，并且你没有通过 <code>rollbackFor</code> 属性指定回滚，事务就不会回滚。同样，如果在事务方法内部 <code>try-catch</code> 捕获了应该回滚的异常（包括 <code>RuntimeException</code>），但在 <code>catch</code> 块中没有再次抛出或抛出新的 <code>RuntimeException</code>，Spring 事务管理器就不会感知到异常的发生，从而导致事务正常提交。</li><li><strong>场景示例：</strong><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Transactional</span> <span class="token comment">// 默认只回滚 RuntimeException 和 Error</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">saveData</span><span class="token punctuation">(</span><span class="token class-name">Data</span> data<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span> <span class="token comment">// Checked Exception</span>
        <span class="token comment">// ... 保存数据</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span><span class="token string">&quot;File error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Checked Exception，默认不回滚</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Transactional</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processData</span><span class="token punctuation">(</span><span class="token class-name">Data</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// ... 数据操作</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Processing failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// RuntimeException</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 异常被捕获，没有再次抛出</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Caught exception: &quot;</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 事务不会回滚!</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>解决办法：</strong><ul><li>对于 Checked Exception 需要回滚的场景，使用 <code>rollbackFor</code>：<code>@Transactional(rollbackFor = IOException.class)</code>。</li><li>对于捕获了异常但需要回滚的场景：在 <code>catch</code> 块中将异常重新抛出（<code>throw e;</code>），或者包装成一个 <code>RuntimeException</code> 抛出（<code>throw new RuntimeException(e);</code>），或者在 <code>@Transactional</code> 中使用 <code>noRollbackFor</code> 属性来包含这个被捕获但不希望回滚的异常类型（尽管这通常与业务逻辑冲突）。</li></ul></li></ul></li></ol><h3 id="编程式事务管理简介" tabindex="-1"><a class="header-anchor" href="#编程式事务管理简介"><span>编程式事务管理简介</span></a></h3><p>尽管声明式事务更常用，但编程式事务在某些场景下仍有其用武之地，例如事务边界需要根据复杂的业务逻辑动态决定，或者在非 Spring Bean 中需要事务支持。</p><ul><li><strong><code>PlatformTransactionManager</code> 接口：</strong> 你可以直接注入 <code>PlatformTransactionManager</code> 接口的实现类，然后手动调用 <code>getTransaction(TransactionDefinition definition)</code> 获取事务状态，调用 <code>commit(TransactionStatus status)</code> 提交，或调用 <code>rollback(TransactionStatus status)</code> 回滚。这非常底层，样板代码较多。</li><li><strong><code>TransactionTemplate</code> 类：</strong> 推荐的编程式事务方式。它封装了获取事务、执行业务逻辑、处理提交/回滚的样板代码。你只需要提供一个 <code>TransactionCallback</code> 或 <code>TransactionCallbackWithoutResult</code> 实现，将业务逻辑放在其 <code>doInTransaction()</code> 方法中。<div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyProgrammaticService</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">TransactionTemplate</span> transactionTemplate<span class="token punctuation">;</span> <span class="token comment">// 注入 TransactionTemplate</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBusinessWithTx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        transactionTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TransactionCallbackWithoutResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doInTransactionWithoutResult</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 你的业务逻辑，所有数据操作都在这个事务中</span>
                <span class="token comment">// 可以通过 status.setRollbackOnly() 手动标记回滚</span>
                <span class="token comment">// 如果此处抛出 RuntimeException，TransactionTemplate 会自动回滚</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>使用场景：</strong> 事务逻辑非常个性化或复杂，难以用 <code>@Transactional</code> 注解清晰表达；或者在非Spring管理的对象中需要事务（虽然这种场景应尽量避免）。</li></ul></li></ul><h3 id="spring-事务管理器-platformtransactionmanager" tabindex="-1"><a class="header-anchor" href="#spring-事务管理器-platformtransactionmanager"><span>Spring 事务管理器 (PlatformTransactionManager)</span></a></h3><p>它是 Spring 事务抽象的核心接口。不同的数据访问技术需要配置不同的 <code>PlatformTransactionManager</code> 实现：</p><ul><li><code>DataSourceTransactionManager</code>: 管理 JDBC 连接的事务，适用于直接使用 JDBC 或 MyBatis。</li><li><code>JpaTransactionManager</code>: 管理 JPA 事务，适用于使用 JPA 作为 ORM 框架。</li><li><code>HibernateTransactionManager</code>: 管理 Hibernate Session 的事务（在新版本 Hibernate 中推荐使用 JpaTransactionManager）。</li><li><code>JtaTransactionManager</code>: 管理分布式事务，当需要跨多个独立资源（如多个数据库、JMS队列）进行事务操作时使用。它依赖于 JTA 事务管理器（如应用服务器提供的）。</li><li><code>MongoTransactionManager</code>, <code>RedisTransactionManager</code> 等：针对 NoSQL 数据库的事务管理器（如果底层数据库支持事务）。</li></ul><p>Spring 会根据你配置的数据源和 ORM 框架，自动配置或提示你手动配置合适的 <code>PlatformTransactionManager</code> Bean。</p><h3 id="事务同步-transaction-synchronization" tabindex="-1"><a class="header-anchor" href="#事务同步-transaction-synchronization"><span>事务同步 (Transaction Synchronization)</span></a></h3><p>在事务内部，如果需要操作资源（如数据库连接、Hibernate Session），如何确保同一个事务内的所有操作都使用同一个资源实例？Spring 通过 <code>TransactionSynchronizationManager</code> 来实现。它是一个线程安全的、基于 <code>ThreadLocal</code> 的工具类，用于将资源（如 <code>ConnectionHolder</code>）绑定到当前执行事务的线程。事务管理器在开启事务时将资源绑定，在提交/回滚时解绑，确保事务中的所有操作都使用线程绑定的那个资源。</p><h3 id="spring-事务管理为何是面试热点" tabindex="-1"><a class="header-anchor" href="#spring-事务管理为何是面试热点"><span>Spring 事务管理为何是面试热点</span></a></h3><p>Spring 事务管理是考察候选人是否具备扎实企业级应用开发经验的重要维度。面试官喜欢问这个话题，是因为：</p><ol><li><strong>核心企业级功能：</strong> 几乎所有业务系统都离不开事务。</li><li><strong>概念复杂性：</strong> 事务传播行为、隔离级别等概念本身就容易混淆。</li><li><strong>实现机制：</strong> 它结合了 AOP 代理、Bean 生命周期等多个 Spring 核心机制，能够全面考察对 Spring 底层的理解。</li><li><strong>实际问题多：</strong> 事务失效、回滚不符合预期等问题在实际开发中经常遇到，能反映候选人解决问题的能力。</li></ol><h3 id="面试问题示例与深度解析" tabindex="-1"><a class="header-anchor" href="#面试问题示例与深度解析"><span>面试问题示例与深度解析</span></a></h3><p>以下是一些常见的 Spring 事务面试问题，结合我们上面的内容，你可以轻松回答：</p><ol><li><strong>请解释 Spring 的事务传播行为，特别是 REQUIRED 和 REQUIRES_NEW 的区别。</strong><ul><li><strong>要点：</strong> 解释传播行为定义了事务方法之间的事务关系。详细解释 REQUIRED（加入或新建，共享连接，一同回滚）和 REQUIRES_NEW（总是新建，暂停当前，独立提交/回滚，独立连接）。用简单的嵌套调用场景对比两者回滚行为的不同影响。</li></ul></li><li><strong><code>@Transactional</code> 注解是如何工作的？原理是什么？</strong><ul><li><strong>要点：</strong> 回答基于 AOP 代理。解释 <code>@EnableTransactionManagement</code> 注册 BeanPostProcessor，BeanPostProcessor 在 Bean 生命周期中创建事务代理。代理拦截方法调用，<code>TransactionInterceptor</code> 执行事务逻辑，调用 <code>PlatformTransactionManager</code>。</li></ul></li><li><strong><code>@Transactional</code> 注解在什么情况下会失效？为什么？</strong><ul><li><strong>要点：</strong> 1) 内部方法调用（<code>this</code> 调用），原因：绕过代理。 2) 非公共方法，原因：代理无法拦截。 3) 异常被捕获未抛出，原因：事务管理器无法感知异常。 4) 抛出 Checked Exception 但未配置 <code>rollbackFor</code>，原因：默认不回滚 Checked Exception。给出解决方案。</li></ul></li><li><strong>Spring 默认对哪些异常进行事务回滚？</strong><ul><li><strong>要点：</strong> 默认只对 RuntimeException 及其子类和 Error 进行回滚。Checked Exception 默认不回滚。</li></ul></li><li><strong>声明式事务和编程式事务有什么优缺点？何时使用？</strong><ul><li><strong>要点：</strong> 声明式优点（解耦、简洁），缺点（灵活性稍弱）；编程式优点（灵活性高），缺点（代码侵入性）。使用场景：大部分用声明式，复杂或特定场景用编程式（如 <code>TransactionTemplate</code>）。</li></ul></li><li><strong>请解释一下 Spring 事务隔离级别。</strong><ul><li><strong>要点：</strong> 解释隔离级别目的（解决并发问题）。列出标准级别名称并简述各自解决的问题（脏读、不可重复读、幻读）。提及 DEFAULT 使用数据库默认。</li></ul></li><li><strong>Spring 如何管理多数据源的事务？</strong><ul><li><strong>要点：</strong> 如果是同构多数据源（同一个数据库类型），且业务逻辑不跨多个数据源，可以为每个数据源配置独立的 <code>PlatformTransactionManager</code>，并通过 <code>@Transactional</code> 的 <code>value</code> 属性指定使用哪个事务管理器。如果需要跨不同类型的数据源或资源（如数据库+消息队列），需要使用支持分布式事务的 <code>JtaTransactionManager</code>，这依赖于底层的 JTA 实现（如应用服务器）。这是一个更高级的话题，简要提及即可。</li></ul></li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>Spring 事务管理是框架为我们提供的强大且便捷的核心功能之一。通过统一的事务抽象层和声明式事务，Spring 极大地简化了企业级应用的事务控制。</p><p>掌握 <code>@Transactional</code> 注解的各种属性（特别是传播行为、隔离级别和回滚规则），理解声明式事务基于 AOP 代理的实现原理，并能够识别和解决常见的事务陷阱，是每一位中高级 Java 开发者必备的技能。这些知识不仅能帮助你写出更健壮、数据一致性更高的应用。</p>`,54)]))}const r=a(t,[["render",c],["__file","spring-transaction.html.vue"]]),d=JSON.parse('{"path":"/spring/spring-transaction.html","title":"","lang":"zh-CN","frontmatter":{"description":"事务（Transaction）是保障数据一致性的基石。在复杂的业务场景下，一个完整的业务操作往往涉及对多个数据资源的访问和修改。如果这些操作中的任何一步失败，我们希望之前已经成功的步骤能够被撤销，就像这些操作从未发生过一样，从而保证数据的完整性和一致性。 深度解析 Spring 事务管理：保障数据一致性的艺术 引言：事务，保障数据一致性的基石 想象一个...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/spring/spring-transaction.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"事务（Transaction）是保障数据一致性的基石。在复杂的业务场景下，一个完整的业务操作往往涉及对多个数据资源的访问和修改。如果这些操作中的任何一步失败，我们希望之前已经成功的步骤能够被撤销，就像这些操作从未发生过一样，从而保证数据的完整性和一致性。 深度解析 Spring 事务管理：保障数据一致性的艺术 引言：事务，保障数据一致性的基石 想象一个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-01T16:05:51.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-05-01T16:05:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-01T16:05:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"深度解析 Spring 事务管理：保障数据一致性的艺术","slug":"深度解析-spring-事务管理-保障数据一致性的艺术","link":"#深度解析-spring-事务管理-保障数据一致性的艺术","children":[{"level":3,"title":"引言：事务，保障数据一致性的基石","slug":"引言-事务-保障数据一致性的基石","link":"#引言-事务-保障数据一致性的基石","children":[]},{"level":3,"title":"Spring 事务管理概述","slug":"spring-事务管理概述","link":"#spring-事务管理概述","children":[]},{"level":3,"title":"声明式事务管理：@Transactional 的魔力","slug":"声明式事务管理-transactional-的魔力","link":"#声明式事务管理-transactional-的魔力","children":[]},{"level":3,"title":"Spring 事务管理中的常见问题与陷阱","slug":"spring-事务管理中的常见问题与陷阱","link":"#spring-事务管理中的常见问题与陷阱","children":[]},{"level":3,"title":"编程式事务管理简介","slug":"编程式事务管理简介","link":"#编程式事务管理简介","children":[]},{"level":3,"title":"Spring 事务管理器 (PlatformTransactionManager)","slug":"spring-事务管理器-platformtransactionmanager","link":"#spring-事务管理器-platformtransactionmanager","children":[]},{"level":3,"title":"事务同步 (Transaction Synchronization)","slug":"事务同步-transaction-synchronization","link":"#事务同步-transaction-synchronization","children":[]},{"level":3,"title":"Spring 事务管理为何是面试热点","slug":"spring-事务管理为何是面试热点","link":"#spring-事务管理为何是面试热点","children":[]},{"level":3,"title":"面试问题示例与深度解析","slug":"面试问题示例与深度解析","link":"#面试问题示例与深度解析","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1745924024000,"updatedTime":1746115551000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":2}]},"readingTime":{"minutes":20.4,"words":6121},"filePathRelative":"spring/spring-transaction.md","localizedDate":"2025年4月29日","autoDesc":true}');export{r as comp,d as data};
