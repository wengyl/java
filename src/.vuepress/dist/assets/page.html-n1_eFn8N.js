import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e,o as p}from"./app-CzKZ5RuK.js";const t={};function o(l,n){return p(),a("div",null,n[0]||(n[0]=[e(`<p>开发经常遇到分页查询的需求，但是当翻页过多的时候，就会产生深分页，导致查询效率急剧下降。 有没有什么办法，能解决深分页的问题呢？ 本文总结了三种优化方案，查询效率直接提升10倍，一起学习一下。</p><h2 id="_1-准备数据" tabindex="-1"><a class="header-anchor" href="#_1-准备数据"><span>1. 准备数据</span></a></h2><p>先创建一张用户表，只在create_time字段上加索引：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>user<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;主键&#39;</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>name<span class="token punctuation">\`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;姓名&#39;</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>create_time<span class="token punctuation">\`</span></span> <span class="token keyword">timestamp</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;创建时间&#39;</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">\`</span>idx_create_time<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>create_time<span class="token punctuation">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">&#39;用户表&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后往用户表中插入100万条测试数据，这里可以使用存储过程：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">drop</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> insertData<span class="token punctuation">;</span>
<span class="token keyword">DELIMITER</span> $$
<span class="token keyword">create</span> <span class="token keyword">procedure</span> insertData<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">begin</span>
 <span class="token keyword">declare</span> i <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> <span class="token number">100000</span> <span class="token keyword">do</span>
         <span class="token keyword">INSERT</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span>create_time<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>CONCAT<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">set</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> 
   <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span> 
<span class="token keyword">end</span> $$

<span class="token keyword">call</span> insertData<span class="token punctuation">(</span><span class="token punctuation">)</span> $$
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-验证深分页问题" tabindex="-1"><a class="header-anchor" href="#_2-验证深分页问题"><span>2. 验证深分页问题</span></a></h2><p>每页10条，当我们查询第一页的时候，速度很快：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> 
<span class="token keyword">where</span> create_time<span class="token operator">&gt;</span><span class="token string">&#39;2022-07-03&#39;</span> 
<span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://javabaguwen.com/img/深分页1.png" alt="image-20220703181532231.png" loading="lazy"> 在不到0.01秒内直接返回了，所以没显示出执行时间。 当我们翻到第10000页的时候，查询效率急剧下降：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> 
<span class="token keyword">where</span> create_time<span class="token operator">&gt;</span><span class="token string">&#39;2022-07-03&#39;</span> 
<span class="token keyword">limit</span> <span class="token number">100000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://javabaguwen.com/img/深分页2.png" alt="image-20220703181904656.png" loading="lazy"> 执行时间变成了0.16秒，性能至少下降了几十倍。 耗时主要花在哪里了？</p><ol><li>需要扫描前10条数据，数据量较大，比较耗时</li><li>create_time是非聚簇索引，需要先查询出主键ID，再回表查询，通过主键ID查询出所有字段</li></ol><p>画一下回表查询流程： <strong>1. 先通过create_time查询出主键ID</strong></p><p><img src="https://javabaguwen.com/img/深分页3.png" alt="image-20220703204919992.png" loading="lazy"><strong>2. 再通过主键ID查询出表中所有字段</strong></p><p><img src="https://javabaguwen.com/img/深分页4.png" alt="image-20220703205108719.png" loading="lazy"> 别问为什么B+树的结构是这样的？问就是规定。 可以看一下前两篇文章。</p><h2 id="_3-优化查询" tabindex="-1"><a class="header-anchor" href="#_3-优化查询"><span>3. 优化查询</span></a></h2><h3 id="_3-1-使用子查询" tabindex="-1"><a class="header-anchor" href="#_3-1-使用子查询"><span>3.1 使用子查询</span></a></h3><p>先用子查询查出符合条件的主键，再用主键ID做条件查出所有字段。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> 
<span class="token keyword">where</span> id <span class="token operator">in</span> <span class="token punctuation">(</span>
  <span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token keyword">user</span> 
  <span class="token keyword">where</span> create_time<span class="token operator">&gt;</span><span class="token string">&#39;2022-07-03&#39;</span> 
  <span class="token keyword">limit</span> <span class="token number">100000</span><span class="token punctuation">,</span><span class="token number">10</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过这样查询会报错，说是子查询中不支持使用limit。 <img src="https://javabaguwen.com/img/深分页5.png" alt="image-20220703205602830.png" loading="lazy"> 我们加一层子查询嵌套，就可以了：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> 
<span class="token keyword">where</span> id <span class="token operator">in</span> <span class="token punctuation">(</span>
 <span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token punctuation">(</span>
    <span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token keyword">user</span> 
    <span class="token keyword">where</span> create_time<span class="token operator">&gt;</span><span class="token string">&#39;2022-07-03&#39;</span> 
    <span class="token keyword">limit</span> <span class="token number">100000</span><span class="token punctuation">,</span><span class="token number">10</span>
 <span class="token punctuation">)</span> <span class="token keyword">as</span> t
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://javabaguwen.com/img/深分页6.png" alt="image-20220703205912970.png" loading="lazy"> 执行时间缩短到0.05秒，减少了0.12秒，相当于查询性能提升了3倍。 为什么先用子查询查出符合条件的主键ID，就能缩短查询时间呢？ 我们用explain查看一下执行计划就明白了：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> 
<span class="token keyword">where</span> id <span class="token operator">in</span> <span class="token punctuation">(</span>
 <span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token punctuation">(</span>
    <span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token keyword">user</span> 
    <span class="token keyword">where</span> create_time<span class="token operator">&gt;</span><span class="token string">&#39;2022-07-03&#39;</span> 
    <span class="token keyword">limit</span> <span class="token number">100000</span><span class="token punctuation">,</span><span class="token number">10</span>
 <span class="token punctuation">)</span> <span class="token keyword">as</span> t
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://javabaguwen.com/img/深分页7.png" alt="image-20220703215830336.png" loading="lazy"> 可以看到Extra列显示子查询中用到<strong>Using index</strong>，表示用到了<strong>覆盖索引</strong>，所以子查询无需回表查询，加快了查询效率。</p><h3 id="_3-2-使用inner-join关联查询" tabindex="-1"><a class="header-anchor" href="#_3-2-使用inner-join关联查询"><span>3.2 使用inner join关联查询</span></a></h3><p>把子查询的结果当成一张临时表，然后和原表进行关联查询。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> 
<span class="token keyword">inner</span> <span class="token keyword">join</span> <span class="token punctuation">(</span>
   <span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token keyword">user</span> 
    <span class="token keyword">where</span> create_time<span class="token operator">&gt;</span><span class="token string">&#39;2022-07-03&#39;</span> 
    <span class="token keyword">limit</span> <span class="token number">100000</span><span class="token punctuation">,</span><span class="token number">10</span>
<span class="token punctuation">)</span> <span class="token keyword">as</span> t <span class="token keyword">on</span> <span class="token keyword">user</span><span class="token punctuation">.</span>id<span class="token operator">=</span>t<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://javabaguwen.com/img/深分页8.png" alt="image-20220703220449618.png" loading="lazy"> 查询性能跟使用子查询一样。</p><h3 id="_3-3-使用分页游标-推荐" tabindex="-1"><a class="header-anchor" href="#_3-3-使用分页游标-推荐"><span>3.3 使用分页游标（推荐）</span></a></h3><p>实现方式就是：当我们查询第二页的时候，把第一页的查询结果放到第二页的查询条件中。 例如：首先查询第一页</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> 
<span class="token keyword">where</span> create_time<span class="token operator">&gt;</span><span class="token string">&#39;2022-07-03&#39;</span> 
<span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后查询第二页，把第一页的查询结果放到第二页查询条件中：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> 
<span class="token keyword">where</span> create_time<span class="token operator">&gt;</span><span class="token string">&#39;2022-07-03&#39;</span> <span class="token operator">and</span> id<span class="token operator">&gt;</span><span class="token number">10</span> 
<span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样相当于每次都是查询第一页，也就不存在深分页的问题了，推荐使用。 <img src="https://javabaguwen.com/img/深分页9.png" alt="image-20220703222259556.png" loading="lazy"> 执行耗时是0秒，查询性能直接提升了几十倍。 这样的查询方式虽然好用，但是又带来一个问题，就是无法跳转到指定页数，只能一页页向下翻。 所以这种查询只适合特定场景，比如资讯类APP的首页。 互联网APP一般采用瀑布流的形式，比如百度首页、头条首页，都是一直向下滑动翻页，并没有跳转到制定页数的需求。 不信的话，可以看一下，这是头条的瀑布流： <img src="https://javabaguwen.com/img/深分页10.png" alt="image-20220703221836032.png" loading="lazy"></p><p>传参中带了上一页的查询结果。</p><figure><img src="https://javabaguwen.com/img/深分页11.png" alt="image-20220703222026194.png" tabindex="0" loading="lazy"><figcaption>image-20220703222026194.png</figcaption></figure><p>响应数据中，返回了下一页查询条件。 所以这种查询方式的应用场景还是挺广的，赶快用起来吧。</p><h2 id="知识点总结" tabindex="-1"><a class="header-anchor" href="#知识点总结"><span>知识点总结：</span></a></h2><figure><img src="https://javabaguwen.com/img/深分页总结.png" alt="image-20220703223109687.png" tabindex="0" loading="lazy"><figcaption>image-20220703223109687.png</figcaption></figure>`,40)]))}const r=s(t,[["render",o],["__file","page.html.vue"]]),d=JSON.parse('{"path":"/mysql/page.html","title":"","lang":"zh-CN","frontmatter":{"description":"开发经常遇到分页查询的需求，但是当翻页过多的时候，就会产生深分页，导致查询效率急剧下降。 有没有什么办法，能解决深分页的问题呢？ 本文总结了三种优化方案，查询效率直接提升10倍，一起学习一下。 1. 准备数据 先创建一张用户表，只在create_time字段上加索引： 然后往用户表中插入100万条测试数据，这里可以使用存储过程： 2. 验证深分页问题 ...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/mysql/page.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"开发经常遇到分页查询的需求，但是当翻页过多的时候，就会产生深分页，导致查询效率急剧下降。 有没有什么办法，能解决深分页的问题呢？ 本文总结了三种优化方案，查询效率直接提升10倍，一起学习一下。 1. 准备数据 先创建一张用户表，只在create_time字段上加索引： 然后往用户表中插入100万条测试数据，这里可以使用存储过程： 2. 验证深分页问题 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javabaguwen.com/img/%E6%B7%B1%E5%88%86%E9%A1%B51.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-29T06:25:28.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-04-29T06:25:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://javabaguwen.com/img/%E6%B7%B1%E5%88%86%E9%A1%B51.png\\",\\"https://javabaguwen.com/img/%E6%B7%B1%E5%88%86%E9%A1%B52.png\\",\\"https://javabaguwen.com/img/%E6%B7%B1%E5%88%86%E9%A1%B53.png\\",\\"https://javabaguwen.com/img/%E6%B7%B1%E5%88%86%E9%A1%B54.png\\",\\"https://javabaguwen.com/img/%E6%B7%B1%E5%88%86%E9%A1%B55.png\\",\\"https://javabaguwen.com/img/%E6%B7%B1%E5%88%86%E9%A1%B56.png\\",\\"https://javabaguwen.com/img/%E6%B7%B1%E5%88%86%E9%A1%B57.png\\",\\"https://javabaguwen.com/img/%E6%B7%B1%E5%88%86%E9%A1%B58.png\\",\\"https://javabaguwen.com/img/%E6%B7%B1%E5%88%86%E9%A1%B59.png\\",\\"https://javabaguwen.com/img/%E6%B7%B1%E5%88%86%E9%A1%B510.png\\",\\"https://javabaguwen.com/img/%E6%B7%B1%E5%88%86%E9%A1%B511.png\\",\\"https://javabaguwen.com/img/%E6%B7%B1%E5%88%86%E9%A1%B5%E6%80%BB%E7%BB%93.png\\"],\\"dateModified\\":\\"2025-04-29T06:25:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 准备数据","slug":"_1-准备数据","link":"#_1-准备数据","children":[]},{"level":2,"title":"2. 验证深分页问题","slug":"_2-验证深分页问题","link":"#_2-验证深分页问题","children":[]},{"level":2,"title":"3. 优化查询","slug":"_3-优化查询","link":"#_3-优化查询","children":[{"level":3,"title":"3.1 使用子查询","slug":"_3-1-使用子查询","link":"#_3-1-使用子查询","children":[]},{"level":3,"title":"3.2 使用inner join关联查询","slug":"_3-2-使用inner-join关联查询","link":"#_3-2-使用inner-join关联查询","children":[]},{"level":3,"title":"3.3 使用分页游标（推荐）","slug":"_3-3-使用分页游标-推荐","link":"#_3-3-使用分页游标-推荐","children":[]}]},{"level":2,"title":"知识点总结：","slug":"知识点总结","link":"#知识点总结","children":[]}],"git":{"createdTime":1745907928000,"updatedTime":1745907928000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":1}]},"readingTime":{"minutes":4.24,"words":1272},"filePathRelative":"mysql/page.md","localizedDate":"2025年4月29日","autoDesc":true}');export{r as comp,d as data};
