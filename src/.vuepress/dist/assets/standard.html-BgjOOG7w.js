import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e as s,o as t}from"./app-CzKZ5RuK.js";const l={};function i(d,e){return t(),a("div",null,e[0]||(e[0]=[s(`<p>上篇文章介绍了如何创建合适的MySQL索引，今天再一块学一下如何更规范、更合理的使用MySQL？ 合理规范的使用MySQL，可以大大减少开发工作量和线上问题，并提升SQL查询性能。 我精心总结了这16条MySQL规约，分享给大家，欢迎评论指正。</p><h2 id="_1-禁止使用select" tabindex="-1"><a class="header-anchor" href="#_1-禁止使用select"><span>1. 禁止使用select  *</span></a></h2><p>阿里开发规范中，有这么一句话： <img src="https://javabaguwen.com/img/MySQL使用规范1.png" alt="image-20220731221303210.png" loading="lazy"> **select *** 会查询表中所有字段，如果表中的字段有更改，必须修改SQL语句，不然就会执行错误。 查询出非必要的字段，徒增磁盘IO和网络延迟。</p><h2 id="_2-用小表驱动大表" tabindex="-1"><a class="header-anchor" href="#_2-用小表驱动大表"><span>2. 用小表驱动大表</span></a></h2><p>关联查询的时候，先用小表查到结果，再用结果去大表查询，可以大大减少连接次数。 比如我们要查询某个部门下的员工，由于部门数量远远小于员工数量。我们可以把部门表当作驱动表，员工表当作被驱动表。 查询SQL类似这样：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>select * from department
inner join employee
on department.id=employee.department_id
where department_name=&#39;部门1&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-join关联表不宜过多" tabindex="-1"><a class="header-anchor" href="#_3-join关联表不宜过多"><span>3. join关联表不宜过多</span></a></h2><p>join关联表禁止超过3张，join关联过多，不但会增加查询时间，降低查询性能，还会产生临时表缓存结果数据，推荐拆成多条小SQL执行。 另外关联字段的类型一定要保持一致，并且在每张表都要建立关联字段的索引。</p><h2 id="_4-禁止使用左模糊或者全模糊查询" tabindex="-1"><a class="header-anchor" href="#_4-禁止使用左模糊或者全模糊查询"><span>4. 禁止使用左模糊或者全模糊查询</span></a></h2><p>当我们在SQL查询使用左模糊或者全模糊匹配的时候，类似下面这样：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code># 左模糊查询
select * from user where name=&#39;%一灯&#39;;
# 全模糊查询
select * from user where name=&#39;%一灯%&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据B+树的特性，即使我们在name字段上建立了索引，查询的时候也是无法用到索引的。</p><h2 id="_5-索引访问类型至少达到range级别" tabindex="-1"><a class="header-anchor" href="#_5-索引访问类型至少达到range级别"><span>5. 索引访问类型至少达到range级别</span></a></h2><p>索引访问类型常见的有这几个级别，从上到下，性能由好到差。 <img src="https://javabaguwen.com/img/MySQL使用规范2.png" alt="image-20220731223132721.png" loading="lazy"></p><p>要求SQL索引访问类型至少要达到<strong>range</strong>级别，最好到<strong>const</strong>级别。</p><h2 id="_6-更优雅的使用联合索引" tabindex="-1"><a class="header-anchor" href="#_6-更优雅的使用联合索引"><span>6. 更优雅的使用联合索引</span></a></h2><p>由于联合索引有最左匹配原则，所以需要优先把区分度高的字段放在最左边第一列。 比如要统计用户表中生日字段和性别字段区分度，可以这样统计：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>select 
    count(distinct birthday)/count(*), 
    count(distinct gender)/count(*) 
from user;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://javabaguwen.com/img/MySQL使用规范3.png" alt="image-20220730230017044.png" loading="lazy"> 值越大，区分度越高。 出道面试题，下面这条SQL该怎么创建联合索引：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>select a from table_name where b=1 order by c;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>SQL中用到abc三个字段，创建联合索引的顺序是**（b,c,a）**。 这道题还涉及到另一个知识点，SQL执行的顺序：</p><blockquote><p>from &gt; on &gt; join &gt; where &gt; group by &gt; having &gt; select &gt; distinct &gt; order by &gt; limit</p></blockquote><h2 id="_7-注意避免深分页" tabindex="-1"><a class="header-anchor" href="#_7-注意避免深分页"><span>7. 注意避免深分页</span></a></h2><p>MySQL深分页的时候，查询性能较差。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>select * from user where name=&#39;一灯&#39; limit 10000,10;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们可以采用子查询的方式进行优化：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>select * from user 
where id in (
  select id from user 
  where name=&#39;一灯&#39;
  limit 10000,10
);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样可以减少非聚簇索引回表查询的次数。</p><h2 id="_8-单表字段不要超过30个" tabindex="-1"><a class="header-anchor" href="#_8-单表字段不要超过30个"><span>8. 单表字段不要超过30个</span></a></h2><p>当单表字段数量过多的时候，加载大量数据也会拖慢查询性能。 如果字段超过30个，不用看，肯定是表设计的不合理。 这时候，可以拆成多张表，用垂直分表的方式，进行冷热字段分离。</p><h2 id="_9-枚举字段不要使用字符类型" tabindex="-1"><a class="header-anchor" href="#_9-枚举字段不要使用字符类型"><span>9. 枚举字段不要使用字符类型</span></a></h2><p>字符类型会占用更多的存储空间，当我们想要存储枚举值或者表示是否的时候，可以采用<strong>tinyint</strong>数值类型，最好采用无符号整数<strong>unsigned tinyint</strong>。</p><h2 id="_10-小数类型禁止使用float和double" tabindex="-1"><a class="header-anchor" href="#_10-小数类型禁止使用float和double"><span>10. 小数类型禁止使用float和double</span></a></h2><p>在存储和计算的时候，<strong>float</strong> 和 <strong>double</strong> 都存在精度损失的问题，无法得到正确的结果。 所以在涉及到存储小数的时候，必须使用<strong>decimal</strong>类型。</p><h2 id="_11-所有字段必须设置默认值且不允许为null" tabindex="-1"><a class="header-anchor" href="#_11-所有字段必须设置默认值且不允许为null"><span>11. 所有字段必须设置默认值且不允许为null</span></a></h2><p>字段允许为null，会占用额外的存储空间。 索引并不会索引null值，所以查询null值的时候无法用到索引。 当数值类型允许为null，返回给映射实体类的时候还可能会报空指针异常。</p><h2 id="_12-必须创建主键-最好是有序数值类型" tabindex="-1"><a class="header-anchor" href="#_12-必须创建主键-最好是有序数值类型"><span>12. 必须创建主键，最好是有序数值类型</span></a></h2><p>如果我们自己没有给表设置主键，InnoDB会自动增加一列隐藏的主键，我们无法使用到，并且也占用的更多的存储空间，所以建表的时候，必须设置主键。 有序数值更适合做主键，插入数据的时候，由于是有序的，不会频繁调整B+树结构，性能更好。</p><h2 id="_13-快速判断是否存在某条记录" tabindex="-1"><a class="header-anchor" href="#_13-快速判断是否存在某条记录"><span>13. 快速判断是否存在某条记录</span></a></h2><p>一般我们判断表中是否存在某条记录的时候，会使用count函数，然后判断返回值是否大于1。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>select count(*) from user where name=&#39;一灯&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>InnoDB存储引擎并没有像MyIsAm那样缓存表的总行数，每次查询都是实时计算的，耗时较长。 我们可以采用limit加快查询效率：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>select id from user where name=&#39;一灯&#39; limit 1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>limit 1</strong>表示匹配到一条就返回，查询效率更好，结果集只返回id，还可以用到覆盖索引。</p><h2 id="_14-in条件中数量不宜过多" tabindex="-1"><a class="header-anchor" href="#_14-in条件中数量不宜过多"><span>14. in条件中数量不宜过多</span></a></h2><p>in条件中数量不要超过1000个，不然耗时会非常长，可以拆成多批次查询。</p><h2 id="_15-禁止创建预留字段" tabindex="-1"><a class="header-anchor" href="#_15-禁止创建预留字段"><span>15. 禁止创建预留字段</span></a></h2><p>无法通过预留字段的名称判断这个字段是干嘛用的。 预留字段的类型不一定合适。 无法为预留字段创建合适的索引。</p><h2 id="_16-单表索引数不要超过5个" tabindex="-1"><a class="header-anchor" href="#_16-单表索引数不要超过5个"><span>16. 单表索引数不要超过5个</span></a></h2><p>创建适当的索引可以提高查询效率，但是过多的索引，不但占用更多存储空间，还会拖慢更新SQL的性能。 所以，索引好用，适度即可。</p><h2 id="_17-修改操作之前先查询" tabindex="-1"><a class="header-anchor" href="#_17-修改操作之前先查询"><span>17. 修改操作之前先查询</span></a></h2><p>在执行update、delete语句之前需要先执行select操作，查询出主键ID之后，使用主键ID进行update、delete操作。 下面的操作是不推荐的：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 直接更新订单状态（不推荐）</span>
<span class="token keyword">update</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token string">&#39;deleted&#39;</span> <span class="token keyword">from</span> <span class="token keyword">order</span> <span class="token keyword">where</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token string">&#39;canceled&#39;</span><span class="token punctuation">;</span>
<span class="token comment"># 直接删除订单（不推荐）</span>
<span class="token keyword">delete</span> <span class="token keyword">from</span> <span class="token keyword">order</span> <span class="token keyword">where</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token string">&#39;deleted&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>推荐使用下面的操作：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 先查询出主键ID，更新订单状态（推荐）</span>
<span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token keyword">where</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token string">&#39;canceled&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">update</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token string">&#39;deleted&#39;</span> <span class="token keyword">from</span> <span class="token keyword">order</span> <span class="token keyword">where</span> id <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token punctuation">,</span>?<span class="token punctuation">,</span>?<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 先查询出主键ID，再删除订单（推荐）</span>
<span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token keyword">where</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token string">&#39;deleted&#39;</span><span class="token punctuation">;</span> 
<span class="token keyword">delete</span> <span class="token keyword">from</span> <span class="token keyword">order</span> <span class="token keyword">where</span> id <span class="token operator">in</span> <span class="token punctuation">(</span>?<span class="token punctuation">,</span>?<span class="token punctuation">,</span>?<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用第二种操作，锁定的行数更少，使用主键ID执行的操作更快，还能分批操作，审计日志还能记录具体更新了哪些数据。</p><h2 id="知识点总结" tabindex="-1"><a class="header-anchor" href="#知识点总结"><span>知识点总结：</span></a></h2><figure><img src="https://javabaguwen.com/img/MySQL使用规范4.png" alt="image-20220731231221066.png" tabindex="0" loading="lazy"><figcaption>image-20220731231221066.png</figcaption></figure>`,58)]))}const o=n(l,[["render",i],["__file","standard.html.vue"]]),c=JSON.parse('{"path":"/mysql/standard.html","title":"","lang":"zh-CN","frontmatter":{"description":"上篇文章介绍了如何创建合适的MySQL索引，今天再一块学一下如何更规范、更合理的使用MySQL？ 合理规范的使用MySQL，可以大大减少开发工作量和线上问题，并提升SQL查询性能。 我精心总结了这16条MySQL规约，分享给大家，欢迎评论指正。 1. 禁止使用select * 阿里开发规范中，有这么一句话： image-2022073122130321...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/mysql/standard.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"上篇文章介绍了如何创建合适的MySQL索引，今天再一块学一下如何更规范、更合理的使用MySQL？ 合理规范的使用MySQL，可以大大减少开发工作量和线上问题，并提升SQL查询性能。 我精心总结了这16条MySQL规约，分享给大家，欢迎评论指正。 1. 禁止使用select * 阿里开发规范中，有这么一句话： image-2022073122130321..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javabaguwen.com/img/MySQL%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%831.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-29T06:25:28.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-04-29T06:25:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://javabaguwen.com/img/MySQL%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%831.png\\",\\"https://javabaguwen.com/img/MySQL%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%832.png\\",\\"https://javabaguwen.com/img/MySQL%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%833.png\\",\\"https://javabaguwen.com/img/MySQL%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%834.png\\"],\\"dateModified\\":\\"2025-04-29T06:25:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 禁止使用select  *","slug":"_1-禁止使用select","link":"#_1-禁止使用select","children":[]},{"level":2,"title":"2. 用小表驱动大表","slug":"_2-用小表驱动大表","link":"#_2-用小表驱动大表","children":[]},{"level":2,"title":"3. join关联表不宜过多","slug":"_3-join关联表不宜过多","link":"#_3-join关联表不宜过多","children":[]},{"level":2,"title":"4. 禁止使用左模糊或者全模糊查询","slug":"_4-禁止使用左模糊或者全模糊查询","link":"#_4-禁止使用左模糊或者全模糊查询","children":[]},{"level":2,"title":"5. 索引访问类型至少达到range级别","slug":"_5-索引访问类型至少达到range级别","link":"#_5-索引访问类型至少达到range级别","children":[]},{"level":2,"title":"6. 更优雅的使用联合索引","slug":"_6-更优雅的使用联合索引","link":"#_6-更优雅的使用联合索引","children":[]},{"level":2,"title":"7. 注意避免深分页","slug":"_7-注意避免深分页","link":"#_7-注意避免深分页","children":[]},{"level":2,"title":"8. 单表字段不要超过30个","slug":"_8-单表字段不要超过30个","link":"#_8-单表字段不要超过30个","children":[]},{"level":2,"title":"9. 枚举字段不要使用字符类型","slug":"_9-枚举字段不要使用字符类型","link":"#_9-枚举字段不要使用字符类型","children":[]},{"level":2,"title":"10. 小数类型禁止使用float和double","slug":"_10-小数类型禁止使用float和double","link":"#_10-小数类型禁止使用float和double","children":[]},{"level":2,"title":"11. 所有字段必须设置默认值且不允许为null","slug":"_11-所有字段必须设置默认值且不允许为null","link":"#_11-所有字段必须设置默认值且不允许为null","children":[]},{"level":2,"title":"12. 必须创建主键，最好是有序数值类型","slug":"_12-必须创建主键-最好是有序数值类型","link":"#_12-必须创建主键-最好是有序数值类型","children":[]},{"level":2,"title":"13. 快速判断是否存在某条记录","slug":"_13-快速判断是否存在某条记录","link":"#_13-快速判断是否存在某条记录","children":[]},{"level":2,"title":"14. in条件中数量不宜过多","slug":"_14-in条件中数量不宜过多","link":"#_14-in条件中数量不宜过多","children":[]},{"level":2,"title":"15. 禁止创建预留字段","slug":"_15-禁止创建预留字段","link":"#_15-禁止创建预留字段","children":[]},{"level":2,"title":"16. 单表索引数不要超过5个","slug":"_16-单表索引数不要超过5个","link":"#_16-单表索引数不要超过5个","children":[]},{"level":2,"title":"17. 修改操作之前先查询","slug":"_17-修改操作之前先查询","link":"#_17-修改操作之前先查询","children":[]},{"level":2,"title":"知识点总结：","slug":"知识点总结","link":"#知识点总结","children":[]}],"git":{"createdTime":1745907928000,"updatedTime":1745907928000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":1}]},"readingTime":{"minutes":5.97,"words":1792},"filePathRelative":"mysql/standard.md","localizedDate":"2025年4月29日","autoDesc":true}');export{o as comp,c as data};
