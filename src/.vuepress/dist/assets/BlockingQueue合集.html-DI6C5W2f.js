import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,e as l,o as u}from"./app-CzKZ5RuK.js";const c={};function n(t,e){return u(),i("div",null,e[0]||(e[0]=[l('<h2 id="引言" tabindex="-1"><a class="header-anchor" href="#引言"><span>引言</span></a></h2><p>最近一个月一直在更新《解读Java源码专栏》，其中跟大家一起剖析了Java的常见的5种<code>BlockingQueue（阻塞队列）</code>，今天就盘点一下这几种阻塞队列的优缺点、区别，以及应用场景。 常见的<code>BlockingQueue</code>有以下5种，下面会详细介绍。</p><ul><li>ArrayBlockingQueue</li></ul><p>基于数组实现的阻塞队列，创建队列时需指定容量大小，是有界队列。</p><ul><li>LinkedBlockingQueue</li></ul><p>基于链表实现的阻塞队列，默认是无界队列，创建可以指定容量大小</p><ul><li>SynchronousQueue</li></ul><p>一种没有缓冲的阻塞队列，生产出的数据需要立刻被消费</p><ul><li>PriorityBlockingQueue</li></ul><p>实现了优先级的阻塞队列，可以按照元素大小排序，是无界队列</p><ul><li>DelayQueue</li></ul><p>实现了延迟功能的阻塞队列，基于PriorityQueue实现的，是无界队列</p><h2 id="blockingqueue简介" tabindex="-1"><a class="header-anchor" href="#blockingqueue简介"><span>BlockingQueue简介</span></a></h2><p>这几种阻塞队列都是实现了BlockingQueue接口，在日常开发中，我们好像很少用到<code>BlockingQueue（阻塞队列）</code>，<code>BlockingQueue</code>到底有什么作用？应用场景是什么样的？ 如果使用过线程池或者阅读过线程池源码，就会知道线程池的核心功能都是基于<code>BlockingQueue</code>实现的。 大家用过消息队列（MessageQueue），就知道消息队列作用是解耦、异步、削峰。同样<code>BlockingQueue</code>的作用也是这三种，区别是<code>BlockingQueue</code>只作用于本机器，而消息队列相当于分布式<code>BlockingQueue</code>。 <img src="https://javabaguwen.com/img/BlockingQueue1.png" alt="image.png" loading="lazy"><code>BlockingQueue</code>作为阻塞队列，主要应用于生产者-消费者模式的场景，在并发多线程中尤其常用。</p><ol><li>比如像线程池中的任务调度场景，提交任务和拉取并执行任务。</li><li>生产者与消费者解耦的场景，生产者把数据放到队列中，消费者从队列中取数据进行消费。两者进行解耦，不用感知对方的存在。</li><li>应对突发流量的场景，业务高峰期突然来了很多请求，可以放到队列中缓存起来，消费者以正常的频率从队列中拉取并消费数据，起到削峰的作用。</li></ol><p><code>BlockingQueue</code>是个接口，定义了几组放数据和取数据的方法，来满足不同的场景。</p><table><thead><tr><th>操作</th><th>抛出异常</th><th>返回特定值</th><th>阻塞</th><th>阻塞一段时间</th></tr></thead><tbody><tr><td>放数据</td><td>add()</td><td>offer()</td><td>put()</td><td>offer(e, time, unit)</td></tr><tr><td>取数据（同时删除数据）</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>取数据（不删除）</td><td>element()</td><td>peek()</td><td>不支持</td><td>不支持</td></tr></tbody></table><p><strong>这四组方法的区别是：</strong></p><ol><li>当队列满的时候，再次添加数据，add()会抛出异常，offer()会返回false，put()会一直阻塞，offer(e, time, unit)会阻塞指定时间，然后返回false。</li><li>当队列为空的时候，再次取数据，remove()会抛出异常，poll()会返回null，take()会一直阻塞，poll(time, unit)会阻塞指定时间，然后返回null。</li></ol><h2 id="arrayblockingqueue" tabindex="-1"><a class="header-anchor" href="#arrayblockingqueue"><span>ArrayBlockingQueue</span></a></h2><ol><li><code>ArrayBlockingQueue</code>底层基于数组实现，采用循环数组，提升了数组的空间利用率。</li><li><code>ArrayBlockingQueue</code>初始化的时候，必须指定队列长度，是有界的阻塞队列，所以要预估好队列长度，保证生产者和消费者速率相匹配。</li><li><code>ArrayBlockingQueue</code>的方法是线程安全的，使用<code>ReentrantLock</code>在操作前后加锁来保证线程安全。</li></ol><h2 id="linkedblockingqueue" tabindex="-1"><a class="header-anchor" href="#linkedblockingqueue"><span>LinkedBlockingQueue</span></a></h2><ol><li><code>LinkedBlockingQueue</code>底层基于链表实现，支持从头部弹出数据，从尾部添加数据。</li><li><code>LinkedBlockingQueue</code>初始化的时候，如果不指定队列长度，默认长度是Integer最大值，相当于无界队列，有内存溢出风险，建议初始化的时候指定队列长度。</li><li><code>LinkedBlockingQueue</code>的方法是线程安全的，分别使用了读写两把锁，比<code>ArrayBlockingQueue</code>性能更好。</li></ol><p>与<code>ArrayBlockingQueue</code>区别是：</p><ol><li>底层结构不同，<code>ArrayBlockingQueue</code>底层基于数组实现，初始化的时候必须指定数组长度，无法扩容。<code>LinkedBlockingQueue</code>底层基于链表实现，链表最大长度是Integer最大值。</li><li>占用内存大小不同，<code>ArrayBlockingQueue</code>一旦初始化，数组长度就确定了，不会随着元素增加而改变。<code>LinkedBlockingQueue</code>会随着元素越多，链表越长，占用内存越大。</li><li>性能不同，<code>ArrayBlockingQueue</code>的入队和出队共用一把锁，并发较低。<code>LinkedBlockingQueue</code>入队和出队使用两把独立的锁，并发情况下性能更高。</li><li>公平锁选项，<code>ArrayBlockingQueue</code>初始化的时候，可以指定使用公平锁或者非公平锁，公平锁模式下，可以按照线程等待的顺序来操作队列。<code>LinkedBlockingQueue</code>只支持非公平锁。</li><li>适用场景不同，<code>ArrayBlockingQueue</code>适用于明确限制队列大小的场景，防止生产速度大于消费速度的时候，造成内存溢出、资源耗尽。<code>LinkedBlockingQueue</code>适用于业务高峰期可以自动扩展消费速度的场景。</li></ol><h2 id="synchronousqueue" tabindex="-1"><a class="header-anchor" href="#synchronousqueue"><span>SynchronousQueue</span></a></h2><p>无论是<code>ArrayBlockingQueue</code>还是<code>LinkedBlockingQueue</code>都是起到缓冲队列的作用，当消费者的消费速度跟不上时，任务就在队列中堆积，需要等待消费者慢慢消费。 如果我们想要自己的任务快速执行，不要积压在队列中，该怎么办？这时候就可以使用<code>SynchronousQueue</code>了。 <code>SynchronousQueue</code>被称为<code>同步队列</code>，当生产者往队列中放元素的时候，必须等待消费者把这个元素取走，否则一直阻塞。消费者取元素的时候，同理也必须等待生产者放队列中放元素。</p><ol><li><code>SynchronousQueue</code>底层有两种实现方式，分别是基于栈实现非公平策略，以及基于队列实现的公平策略。</li><li><code>SynchronousQueue</code>初始化的时候，可以指定使用公平策略还是非公平策略。</li><li><code>SynchronousQueue</code>不存储元素，不适合作为缓存队列使用。适用于生产者与消费者速度相匹配的场景，可减少任务执行的等待时间。</li></ol><h2 id="priorityblockingqueue" tabindex="-1"><a class="header-anchor" href="#priorityblockingqueue"><span>PriorityBlockingQueue</span></a></h2><p>由于<code>PriorityQueue</code>跟前几个阻塞队列不一样，并没有实现<code>BlockingQueue</code>接口，只是实现了<code>Queue</code>接口，所以<code>PriorityQueue</code>并不算阻塞队列。<code>Queue</code>接口中定义了几组放数据和取数据的方法，来满足不同的场景。</p><ol><li><code>PriorityQueue</code>实现了<code>Queue</code>接口，提供了两组放数据和读数据的方法，来满足不同的场景。</li><li><code>PriorityQueue</code>底层基于数组实现，实现了按照元素值大小排序的功能，内部按照最小堆存储，实现了高效的插入和删除。</li><li><code>PriorityQueue</code>初始化的时候，可以指定数组长度和自定义比较器。</li><li><code>PriorityQueue</code>初始容量是11，当数组容量小于64，采用2倍扩容，否则采用1.5扩容。</li><li><code>PriorityQueue</code>每次都是从数组头节点取元素，取之后需要调整最小堆。</li></ol><h2 id="delayqueue" tabindex="-1"><a class="header-anchor" href="#delayqueue"><span>DelayQueue</span></a></h2><p><code>DelayQueue</code>是一种本地延迟队列，比如希望我们的任务在5秒后执行，就可以使用<code>DelayQueue</code>实现。常见的使用场景有：</p><ul><li>订单10分钟内未支付，就取消。</li><li>缓存过期后，就删除。</li><li>消息的延迟发送等。</li></ul><ol><li><code>DelayQueue</code>底层采用组合的方式，复用<code>PriorityQueue</code>的按照延迟时间排序任务的功能，实现了延迟队列。</li><li><code>DelayQueue</code>是线程安全的，内部使用<code>ReentrantLock</code>加锁。</li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>这5种阻塞队列的特性各不相同，在使用的时候该怎么选择呢？我做了一张图，供大家参考。 <img src="https://javabaguwen.com/img/BlockingQueue2.png" alt="image.png" loading="lazy"> 关注我，咱们一起接着剖析Java源码。</p>',37)]))}const r=o(c,[["render",n],["__file","BlockingQueue合集.html.vue"]]),g=JSON.parse('{"path":"/list/BlockingQueue%E5%90%88%E9%9B%86.html","title":"","lang":"zh-CN","frontmatter":{"description":"引言 最近一个月一直在更新《解读Java源码专栏》，其中跟大家一起剖析了Java的常见的5种BlockingQueue（阻塞队列），今天就盘点一下这几种阻塞队列的优缺点、区别，以及应用场景。 常见的BlockingQueue有以下5种，下面会详细介绍。 ArrayBlockingQueue 基于数组实现的阻塞队列，创建队列时需指定容量大小，是有界队列。...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/list/BlockingQueue%E5%90%88%E9%9B%86.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"引言 最近一个月一直在更新《解读Java源码专栏》，其中跟大家一起剖析了Java的常见的5种BlockingQueue（阻塞队列），今天就盘点一下这几种阻塞队列的优缺点、区别，以及应用场景。 常见的BlockingQueue有以下5种，下面会详细介绍。 ArrayBlockingQueue 基于数组实现的阻塞队列，创建队列时需指定容量大小，是有界队列。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javabaguwen.com/img/BlockingQueue1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-29T06:25:28.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-04-29T06:25:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://javabaguwen.com/img/BlockingQueue1.png\\",\\"https://javabaguwen.com/img/BlockingQueue2.png\\"],\\"dateModified\\":\\"2025-04-29T06:25:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"引言","slug":"引言","link":"#引言","children":[]},{"level":2,"title":"BlockingQueue简介","slug":"blockingqueue简介","link":"#blockingqueue简介","children":[]},{"level":2,"title":"ArrayBlockingQueue","slug":"arrayblockingqueue","link":"#arrayblockingqueue","children":[]},{"level":2,"title":"LinkedBlockingQueue","slug":"linkedblockingqueue","link":"#linkedblockingqueue","children":[]},{"level":2,"title":"SynchronousQueue","slug":"synchronousqueue","link":"#synchronousqueue","children":[]},{"level":2,"title":"PriorityBlockingQueue","slug":"priorityblockingqueue","link":"#priorityblockingqueue","children":[]},{"level":2,"title":"DelayQueue","slug":"delayqueue","link":"#delayqueue","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1745907928000,"updatedTime":1745907928000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":1}]},"readingTime":{"minutes":6.31,"words":1892},"filePathRelative":"list/BlockingQueue合集.md","localizedDate":"2025年4月29日","autoDesc":true}');export{r as comp,g as data};
