import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,e,o}from"./app-CzKZ5RuK.js";const t={};function l(p,s){return o(),n("div",null,s[0]||(s[0]=[e(`<p>MySQL有两个核心的知识点，索引和锁。前几篇文章已经详细讲解了MySQL索引实现机制，今天再一起学习一下MySQL的锁。</p><h2 id="_1-为什么要加锁" tabindex="-1"><a class="header-anchor" href="#_1-为什么要加锁"><span>1 为什么要加锁？</span></a></h2><p>当多个事务并发操作同一批数据的时候，如果不加锁，就无法保证事务的隔离性，最后导致数据错乱。 加锁是为了保证并发操作下数据的正确性。</p><h2 id="_2-锁的分类有哪些" tabindex="-1"><a class="header-anchor" href="#_2-锁的分类有哪些"><span>2 锁的分类有哪些？</span></a></h2><ul><li><strong>按锁的粒度可分为：</strong> 表锁、页面锁、行锁、记录锁、间隙锁、临键锁</li><li><strong>按锁的属性可分为：</strong> 共享锁、排它锁</li><li><strong>按加锁机制可分为：</strong> 乐观锁、悲观锁 下面依次介绍一下这几种锁：</li></ul><h3 id="表锁" tabindex="-1"><a class="header-anchor" href="#表锁"><span>表锁</span></a></h3><p>MyISAM和InnoDB引擎均支持表锁。</p><ul><li><strong>优点：</strong> 开销小，加锁快，不会出现死锁。</li><li><strong>缺点：</strong> 锁定力度大，发生锁冲突概率高，并发度最低。</li></ul><p><strong>加锁方式：</strong></p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 对user表加读锁</span>
<span class="token keyword">lock</span> <span class="token keyword">table</span> <span class="token keyword">user</span> <span class="token keyword">read</span><span class="token punctuation">;</span>
<span class="token comment"># 同时对user表加读锁，对order表加写锁</span>
<span class="token keyword">lock</span> <span class="token keyword">tables</span> <span class="token keyword">user</span> <span class="token keyword">read</span><span class="token punctuation">,</span> <span class="token keyword">order</span> <span class="token keyword">write</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>什么情况下需要用到表锁？</strong></p><ol><li>当需要更新表中的大部分数据</li><li>事务涉及到多张表，业务逻辑复杂，加表锁可以避免死锁。</li></ol><h3 id="页面锁" tabindex="-1"><a class="header-anchor" href="#页面锁"><span>页面锁</span></a></h3><ul><li><strong>优点：</strong> 开销和加锁速度介于表锁和行锁之间。</li><li><strong>缺点：</strong> 会出现死锁，锁定粒度介于表锁和行锁之间，并发度一般。 目前只有BDB引擎支持页面锁，应用场景较少。</li></ul><h3 id="行锁" tabindex="-1"><a class="header-anchor" href="#行锁"><span>行锁</span></a></h3><p>只有InnoDB引擎支持行锁，另外锁是加在索引上面的。</p><ul><li><strong>优点：</strong> 开销大，加锁慢；会出现死锁。</li><li><strong>缺点：</strong> 锁定粒度小，发生锁冲突的概率低，并发度高。 另外记录锁、间隙锁、临键锁均属于行锁。</li></ul><h3 id="记录锁-record-locks" tabindex="-1"><a class="header-anchor" href="#记录锁-record-locks"><span>记录锁（Record Locks）</span></a></h3><p>即对某条记录加锁。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 对id=1的用户加锁</span>
<span class="token keyword">update</span> <span class="token keyword">user</span> <span class="token keyword">set</span> age<span class="token operator">=</span>age<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="间隙锁-gap-locks" tabindex="-1"><a class="header-anchor" href="#间隙锁-gap-locks"><span>间隙锁（Gap Locks）</span></a></h3><p>即对某个范围加锁，但是不包含范围的临界数据。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 对id大于1并且小于10的用户加锁</span>
<span class="token keyword">update</span> <span class="token keyword">user</span> <span class="token keyword">set</span> age<span class="token operator">=</span>age<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> id<span class="token operator">&gt;</span><span class="token number">1</span> <span class="token operator">and</span> id<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面SQL的加锁范围是(1,10)。 <strong>临键锁（Next-Key Locks）</strong> 由记录锁和间隙锁组成，既包含记录本身又包含范围，左开右闭区间。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 对id大于1并且小于等于10的用户加锁</span>
<span class="token keyword">update</span> <span class="token keyword">user</span> <span class="token keyword">set</span> age<span class="token operator">=</span>age<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> id<span class="token operator">&gt;</span><span class="token number">1</span> <span class="token operator">and</span> id<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="共享锁-又称读锁、s锁" tabindex="-1"><a class="header-anchor" href="#共享锁-又称读锁、s锁"><span>共享锁（又称读锁、S锁）</span></a></h3><p><strong>作用：<strong>防止其他事务修改当前数据。 <strong>加锁方式：</strong> 在select语句末尾加上</strong>lock in share mode</strong>关键字。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 对id=1的用户加读锁</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="排他锁-又称写锁、x锁" tabindex="-1"><a class="header-anchor" href="#排他锁-又称写锁、x锁"><span>排他锁（又称写锁、X锁）</span></a></h3><p><strong>作用：<strong>防止其他事务读取或者更新当前数据。 <strong>加锁方式：</strong> 在select语句末尾加上</strong>for update</strong>关键字。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 对id=1的用户加写锁</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="乐观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁"><span>乐观锁</span></a></h3><p>总是假设别人不会修改当前数据，所以每次读取数据的时候都不会加锁，只是在更新数据的时候通过version判断别人是否修改过数据，Java的atomic包下的类就是使用乐观锁（CAS）实现的。 适用于读多写少的场景。 <strong>加锁方式：</strong></p><ol><li>读取version</li></ol><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>version <span class="token keyword">from</span> <span class="token keyword">user</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>更新数据，判断version是否修改过。</li></ol><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">update</span> <span class="token keyword">user</span> <span class="token keyword">set</span> age<span class="token operator">=</span>age<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> version<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="悲观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁"><span>悲观锁</span></a></h3><p>总是假设别人会修改当前数据，所以每次读取的时候，总是加锁。 适用于写多读少的场景。 <strong>加锁方式：</strong></p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 加读锁</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>
<span class="token comment"># 加写锁</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>本文知识点总结：</strong><img src="https://javabaguwen.com/img/MySQL锁总结.png" alt="MySQL锁.png" loading="lazy"></p>`,41)]))}const i=a(t,[["render",l],["__file","lock.html.vue"]]),d=JSON.parse('{"path":"/mysql/lock.html","title":"","lang":"zh-CN","frontmatter":{"description":"MySQL有两个核心的知识点，索引和锁。前几篇文章已经详细讲解了MySQL索引实现机制，今天再一起学习一下MySQL的锁。 1 为什么要加锁？ 当多个事务并发操作同一批数据的时候，如果不加锁，就无法保证事务的隔离性，最后导致数据错乱。 加锁是为了保证并发操作下数据的正确性。 2 锁的分类有哪些？ 按锁的粒度可分为： 表锁、页面锁、行锁、记录锁、间隙锁、...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/mysql/lock.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"MySQL有两个核心的知识点，索引和锁。前几篇文章已经详细讲解了MySQL索引实现机制，今天再一起学习一下MySQL的锁。 1 为什么要加锁？ 当多个事务并发操作同一批数据的时候，如果不加锁，就无法保证事务的隔离性，最后导致数据错乱。 加锁是为了保证并发操作下数据的正确性。 2 锁的分类有哪些？ 按锁的粒度可分为： 表锁、页面锁、行锁、记录锁、间隙锁、..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javabaguwen.com/img/MySQL%E9%94%81%E6%80%BB%E7%BB%93.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-29T06:25:28.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-04-29T06:25:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://javabaguwen.com/img/MySQL%E9%94%81%E6%80%BB%E7%BB%93.png\\"],\\"dateModified\\":\\"2025-04-29T06:25:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1 为什么要加锁？","slug":"_1-为什么要加锁","link":"#_1-为什么要加锁","children":[]},{"level":2,"title":"2 锁的分类有哪些？","slug":"_2-锁的分类有哪些","link":"#_2-锁的分类有哪些","children":[{"level":3,"title":"表锁","slug":"表锁","link":"#表锁","children":[]},{"level":3,"title":"页面锁","slug":"页面锁","link":"#页面锁","children":[]},{"level":3,"title":"行锁","slug":"行锁","link":"#行锁","children":[]},{"level":3,"title":"记录锁（Record Locks）","slug":"记录锁-record-locks","link":"#记录锁-record-locks","children":[]},{"level":3,"title":"间隙锁（Gap Locks）","slug":"间隙锁-gap-locks","link":"#间隙锁-gap-locks","children":[]},{"level":3,"title":"共享锁（又称读锁、S锁）","slug":"共享锁-又称读锁、s锁","link":"#共享锁-又称读锁、s锁","children":[]},{"level":3,"title":"排他锁（又称写锁、X锁）","slug":"排他锁-又称写锁、x锁","link":"#排他锁-又称写锁、x锁","children":[]},{"level":3,"title":"乐观锁","slug":"乐观锁","link":"#乐观锁","children":[]},{"level":3,"title":"悲观锁","slug":"悲观锁","link":"#悲观锁","children":[]}]}],"git":{"createdTime":1745907928000,"updatedTime":1745907928000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":1}]},"readingTime":{"minutes":3.16,"words":949},"filePathRelative":"mysql/lock.md","localizedDate":"2025年4月29日","autoDesc":true}');export{i as comp,d as data};
