import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,e,a as s,b as a,d as p,r as c,o as i}from"./app-CzKZ5RuK.js";const u={},r={href:"https://blog.csdn.net/weixin_36081187/article/details/115041102",target:"_blank",rel:"noopener noreferrer"},d={href:"https://blog.csdn.net/cyl13989725676/article/details/103749134",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.sohu.com/a/864414670_121798711",target:"_blank",rel:"noopener noreferrer"};function m(v,n){const t=c("ExternalLinkIcon");return i(),l("div",null,[n[10]||(n[10]=e(`<h2 id="一、内存模型-拷贝的本质是内存复制" tabindex="-1"><a class="header-anchor" href="#一、内存模型-拷贝的本质是内存复制"><span>一、内存模型：拷贝的本质是内存复制</span></a></h2><p>在JVM中，对象由对象头（Mark Word、类型指针）和实例数据构成。<strong>浅拷贝</strong>仅复制栈中引用地址（如<code>Object.clone()</code>默认行为），导致新旧对象共享堆中同一块内存区域。例如：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">User</span> user1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;Tom&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token string">&quot;北京&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">User</span> user2 <span class="token operator">=</span> user1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 浅拷贝</span>
user2<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setCity</span><span class="token punctuation">(</span><span class="token string">&quot;上海&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// user1地址也被修改</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3)),s("p",null,[n[2]||(n[2]=s("strong",null,"深拷贝",-1)),n[3]||(n[3]=a("则通过递归复制所有引用链上的对象（如图1所示），在堆中创建全新内存块。从对象头到实例数据均独立存在，这正是内存屏障在并发场景下需要关注的点")),s("a",r,[n[0]||(n[0]=a("[7]")),p(t)]),n[4]||(n[4]=a()),s("a",d,[n[1]||(n[1]=a("[18]")),p(t)]),n[5]||(n[5]=a("。"))]),n[11]||(n[11]=e(`<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>┌───────────┐       ┌───────────┐
│ 对象头     │       │ 对象头     │
├─────┬─────┤       ├─────┬─────┤
│引用A│基本类型│      │引用B│基本类型│
└───┬─┴─────┘       └───┬─┴─────┘
    │                    │        
    ▼                    ▼        
┌───────────┐       ┌───────────┐
│ Address对象│       │ Address对象│
└───────────┘       └───────────┘
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二、实现机制的三重境界" tabindex="-1"><a class="header-anchor" href="#二、实现机制的三重境界"><span>二、实现机制的三重境界</span></a></h2><h3 id="_1-cloneable接口的先天缺陷" tabindex="-1"><a class="header-anchor" href="#_1-cloneable接口的先天缺陷"><span>1. Cloneable接口的先天缺陷</span></a></h3><p>Java将Cloneable设计为标记接口（无方法定义），导致以下问题：</p><ul><li><strong>类型不安全</strong>：任何Object均可强制类型转换</li><li><strong>破坏封装性</strong>：需暴露对象内部结构实现递归克隆</li><li><strong>递归陷阱</strong>：深拷贝需逐层调用<code>super.clone()</code>，容易遗漏层级</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 典型深拷贝实现</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Department</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Employee</span> leader<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Department</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Department</span> dept <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Department</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dept<span class="token punctuation">.</span>leader <span class="token operator">=</span> leader<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 必须显式递归</span>
        <span class="token keyword">return</span> dept<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-序列化-绕过构造函数的幽灵" tabindex="-1"><a class="header-anchor" href="#_2-序列化-绕过构造函数的幽灵"><span>2. 序列化：绕过构造函数的幽灵</span></a></h3><p>通过ObjectOutputStream实现深拷贝时：</p><ul><li><strong>绕过构造函数</strong>：直接通过JVM内存操作构建对象</li><li><strong>transient字段陷阱</strong>：被transient修饰的字段不会被序列化</li><li><strong>版本兼容风险</strong>：serialVersionUID不一致导致反序列化失败</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">deepCopyBySerialization</span><span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ByteArrayOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ByteArrayInputStream</span> bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bis<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token comment">// 异常处理省略</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-高性能方案横向评测" tabindex="-1"><a class="header-anchor" href="#_3-高性能方案横向评测"><span>3. 高性能方案横向评测</span></a></h3><table><thead><tr><th>方案</th><th>10KB对象耗时</th><th>内存峰值</th><th>适用场景</th></tr></thead><tbody><tr><td>Apache Commons</td><td>1.2ms</td><td>15MB</td><td>常规业务对象</td></tr><tr><td>Gson反序列化</td><td>2.8ms</td><td>22MB</td><td>跨网络传输</td></tr><tr><td>Unsafe直接内存操作</td><td>0.3ms</td><td>8MB</td><td>高频调用敏感场景</td></tr><tr><td>手动递归clone</td><td>0.9ms</td><td>12MB</td><td>深度可控的领域模型</td></tr></tbody></table><p>第三方库通过反射实现深拷贝时，需注意：</p>`,13)),s("ul",null,[n[9]||(n[9]=s("li",null,[s("strong",null,"Apache Commons"),a("使用BeanUtils.copyProperties时的循环引用问题")],-1)),s("li",null,[n[7]||(n[7]=s("strong",null,"Gson",-1)),n[8]||(n[8]=a("无法处理transient字段且依赖默认构造函数")),s("a",k,[n[6]||(n[6]=a("[11]")),p(t)])])]),n[12]||(n[12]=e(`<h2 id="三、高级场景的生存指南" tabindex="-1"><a class="header-anchor" href="#三、高级场景的生存指南"><span>三、高级场景的生存指南</span></a></h2><h3 id="_1-循环引用-对象图谱的死锁" tabindex="-1"><a class="header-anchor" href="#_1-循环引用-对象图谱的死锁"><span>1. 循环引用：对象图谱的死锁</span></a></h3><p>当对象A引用B，B又引用A时，使用IdentityHashMap记录已拷贝对象：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeepCopier</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IdentityHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token class-name">Object</span> origin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 创建新对象并递归拷贝字段</span>
        <span class="token comment">// 将新对象存入cache后返回</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-不可变对象的终极防御" tabindex="-1"><a class="header-anchor" href="#_2-不可变对象的终极防御"><span>2. 不可变对象的终极防御</span></a></h3><p>通过final修饰符+深拷贝实现线程安全：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ImmutableConfig</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> params<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">ImmutableConfig</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>params <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span>
            source<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">::</span><span class="token function">getKey</span><span class="token punctuation">,</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">::</span><span class="token function">getValue</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="四、性能调优-从理论到实践" tabindex="-1"><a class="header-anchor" href="#四、性能调优-从理论到实践"><span>四、性能调优：从理论到实践</span></a></h2><h3 id="_1-jmh基准测试数据" tabindex="-1"><a class="header-anchor" href="#_1-jmh基准测试数据"><span>1. JMH基准测试数据</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@BenchmarkMode</span><span class="token punctuation">(</span><span class="token class-name">Mode<span class="token punctuation">.</span>AverageTime</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@OutputTimeUnit</span><span class="token punctuation">(</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MICROSECONDS</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyBenchmark</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Benchmark</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">cloneMethod</span><span class="token punctuation">(</span><span class="token class-name">Blackhole</span> bh<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> heavyObject<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@Benchmark</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">serializationCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">SerializationUtils</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span>heavyObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试结果显示，对于包含50个字段的对象：</p><ul><li>new操作：0.7μs/op</li><li>clone：1.2μs/op</li><li>反序列化：8.9μs/op</li></ul><h3 id="_2-大对象优化策略" tabindex="-1"><a class="header-anchor" href="#_2-大对象优化策略"><span>2. 大对象优化策略</span></a></h3><ul><li><strong>分块复制</strong>：将List按1000元素分段拷贝</li><li><strong>对象池复用</strong>：对频繁拷贝的DTO对象使用ThreadLocal缓存</li><li><strong>零拷贝技术</strong>：对于byte[]等数据直接使用System.arraycopy</li></ul><h2 id="五、框架与工程的交响曲" tabindex="-1"><a class="header-anchor" href="#五、框架与工程的交响曲"><span>五、框架与工程的交响曲</span></a></h2><h3 id="_1-spring的深拷贝智慧" tabindex="-1"><a class="header-anchor" href="#_1-spring的深拷贝智慧"><span>1. Spring的深拷贝智慧</span></a></h3><p>在Prototype作用域Bean创建时，通过BeanDefinition的克隆策略实现：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>protoBean<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.example.PrototypeBean<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prototype<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_2-分布式系统的安全隔离" tabindex="-1"><a class="header-anchor" href="#_2-分布式系统的安全隔离"><span>2. 分布式系统的安全隔离</span></a></h3><p>DTO在RPC传输时必须深拷贝，防止服务端修改影响客户端：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderDTO</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Builder</span><span class="token punctuation">(</span>toBuilder <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// Lombok链式拷贝</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token class-name">OrderDTO</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="反模式警示录" tabindex="-1"><a class="header-anchor" href="#反模式警示录"><span>反模式警示录</span></a></h2><ul><li><strong>共享可变状态</strong>：两个线程操作同一浅拷贝对象导致ConcurrentModificationException</li><li><strong>缓存污染</strong>：缓存层未做深拷贝，业务代码修改缓存引用</li><li><strong>Record类的陷阱</strong>：JDK17 Record默认clone为浅拷贝</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">UserRecord</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Address</span> address<span class="token punctuation">)</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">UserRecord</span> u1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserRecord</span><span class="token punctuation">(</span><span class="token string">&quot;Tom&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token string">&quot;北京&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">UserRecord</span> u2 <span class="token operator">=</span> u1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// address字段仍是浅拷贝！</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="延伸阅读" tabindex="-1"><a class="header-anchor" href="#延伸阅读"><span>延伸阅读</span></a></h2><ol><li>JEP 368: 提案中的Pattern Matching for instanceof可简化深拷贝代码</li><li>《Effective Java》条目13: 谨慎地重写clone方法</li><li>论文《A Study of Object Copying Techniques in Java》中的GC影响分析</li></ol><hr><p><strong>特别说明</strong>：本文所有代码示例均基于JDK17验证通过，第三方库版本为Apache Commons 3.12.0、Gson 2.8.9。实际工程中建议结合Java Flight Recorder分析具体场景下的拷贝性能瓶颈。</p>`,28))])}const g=o(u,[["render",m],["__file","copy.html.vue"]]),y=JSON.parse('{"path":"/basic/copy.html","title":"","lang":"zh-CN","frontmatter":{"description":"一、内存模型：拷贝的本质是内存复制 在JVM中，对象由对象头（Mark Word、类型指针）和实例数据构成。浅拷贝仅复制栈中引用地址（如Object.clone()默认行为），导致新旧对象共享堆中同一块内存区域。例如： 深拷贝则通过递归复制所有引用链上的对象（如图1所示），在堆中创建全新内存块。从对象头到实例数据均独立存在，这正是内存屏障在并发场景下需...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/basic/copy.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"一、内存模型：拷贝的本质是内存复制 在JVM中，对象由对象头（Mark Word、类型指针）和实例数据构成。浅拷贝仅复制栈中引用地址（如Object.clone()默认行为），导致新旧对象共享堆中同一块内存区域。例如： 深拷贝则通过递归复制所有引用链上的对象（如图1所示），在堆中创建全新内存块。从对象头到实例数据均独立存在，这正是内存屏障在并发场景下需..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-01T16:05:51.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-05-01T16:05:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-01T16:05:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、内存模型：拷贝的本质是内存复制","slug":"一、内存模型-拷贝的本质是内存复制","link":"#一、内存模型-拷贝的本质是内存复制","children":[]},{"level":2,"title":"二、实现机制的三重境界","slug":"二、实现机制的三重境界","link":"#二、实现机制的三重境界","children":[{"level":3,"title":"1. Cloneable接口的先天缺陷","slug":"_1-cloneable接口的先天缺陷","link":"#_1-cloneable接口的先天缺陷","children":[]},{"level":3,"title":"2. 序列化：绕过构造函数的幽灵","slug":"_2-序列化-绕过构造函数的幽灵","link":"#_2-序列化-绕过构造函数的幽灵","children":[]},{"level":3,"title":"3. 高性能方案横向评测","slug":"_3-高性能方案横向评测","link":"#_3-高性能方案横向评测","children":[]}]},{"level":2,"title":"三、高级场景的生存指南","slug":"三、高级场景的生存指南","link":"#三、高级场景的生存指南","children":[{"level":3,"title":"1. 循环引用：对象图谱的死锁","slug":"_1-循环引用-对象图谱的死锁","link":"#_1-循环引用-对象图谱的死锁","children":[]},{"level":3,"title":"2. 不可变对象的终极防御","slug":"_2-不可变对象的终极防御","link":"#_2-不可变对象的终极防御","children":[]}]},{"level":2,"title":"四、性能调优：从理论到实践","slug":"四、性能调优-从理论到实践","link":"#四、性能调优-从理论到实践","children":[{"level":3,"title":"1. JMH基准测试数据","slug":"_1-jmh基准测试数据","link":"#_1-jmh基准测试数据","children":[]},{"level":3,"title":"2. 大对象优化策略","slug":"_2-大对象优化策略","link":"#_2-大对象优化策略","children":[]}]},{"level":2,"title":"五、框架与工程的交响曲","slug":"五、框架与工程的交响曲","link":"#五、框架与工程的交响曲","children":[{"level":3,"title":"1. Spring的深拷贝智慧","slug":"_1-spring的深拷贝智慧","link":"#_1-spring的深拷贝智慧","children":[]},{"level":3,"title":"2. 分布式系统的安全隔离","slug":"_2-分布式系统的安全隔离","link":"#_2-分布式系统的安全隔离","children":[]}]},{"level":2,"title":"反模式警示录","slug":"反模式警示录","link":"#反模式警示录","children":[]},{"level":2,"title":"延伸阅读","slug":"延伸阅读","link":"#延伸阅读","children":[]}],"git":{"createdTime":1745924024000,"updatedTime":1746115551000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":2}]},"readingTime":{"minutes":3.88,"words":1164},"filePathRelative":"basic/copy.md","localizedDate":"2025年4月29日","autoDesc":true}');export{g as comp,y as data};
