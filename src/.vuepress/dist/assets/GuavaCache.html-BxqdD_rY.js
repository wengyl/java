import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,e,o as t}from"./app-CzKZ5RuK.js";const c={};function p(o,a){return t(),s("div",null,a[0]||(a[0]=[e(`<h2 id="引言" tabindex="-1"><a class="header-anchor" href="#引言"><span>引言</span></a></h2><p>Guava Cache是一个功能强大且易于使用的缓存库，它提供了简单高效的缓存解决方案。本文将介绍Guava Cache的特性、使用方法以及与其他缓存库的比较，帮助读者了解并正确地使用Guava Cache。</p><h2 id="概要" tabindex="-1"><a class="header-anchor" href="#概要"><span>概要</span></a></h2><p>Guava Cache（也称为Guava缓存）是Google开源的一个Java库，用于实现本地缓存。它是Guava项目的一部分，是Google对Java集合框架的扩展和增强。</p><p>Guava Cache提供了一个简单而强大的缓存实现，旨在提高应用程序的性能和响应速度。它支持线程安全，并提供了一些高级特性，例如自动加载缓存、大小限制、过期策略和统计信息收集等。</p><p>Guava Cache的一些主要特性：</p><ol><li>自动加载：Guava Cache允许开发人员定义一个加载方法，当缓存中不存在所需的键时，自动调用该方法加载数据并将其放入缓存中。这样，开发人员无需手动管理缓存的加载过程。</li><li>缓存过期：Guava Cache支持基于时间和基于大小的缓存过期策略。开发人员可以定义缓存项的过期时间，一旦超过指定时间，缓存项将被自动删除。此外，Guava Cache还支持基于缓存容量的过期策略，当缓存项数量达到一定阈值时，会自动删除最旧的缓存项。</li><li>缓存回收：Guava Cache提供了一种基于引用的缓存回收机制，它可以根据缓存项的引用类型来确定缓存项是否应该被回收。例如，开发人员可以选择将缓存项的引用类型设置为弱引用，这样当缓存项没有被其他引用持有时，会自动被回收。</li><li>统计信息收集：Guava Cache可以收集有关缓存性能和使用情况的统计信息，例如命中率、加载时间和缓存项数量等。这些统计信息对于性能分析和调优非常有用。</li><li>显式操作：Guava Cache提供了一组简单而直观的API，用于执行显式的缓存操作，例如放入缓存、获取缓存、移除缓存和清空缓存等。</li></ol><p>总的来说，Guava Cache是一个强大而灵活的本地缓存实现，适用于各种类型的Java应用程序。它提供了许多有用的功能和特性，可以帮助开发人员轻松地实现缓存功能，并改善应用程序的性能和响应速度。</p><h2 id="淘汰策略" tabindex="-1"><a class="header-anchor" href="#淘汰策略"><span>淘汰策略</span></a></h2><p>Guava Cache提供了多种缓存淘汰策略，用于控制缓存中的数据何时被移除。以下是Guava Cache支持的几种常见的缓存淘汰策略：</p><ol><li><strong>基于大小的淘汰策略（Size-based Eviction）：</strong></li></ol><ul><li>maximumSize(int)：通过设置缓存的最大容量来限制缓存的大小。当缓存中的条目数量达到最大容量时，根据LRU（Least Recently Used，最近最少使用）策略移除最近最少使用的条目。</li><li>softValues()：通过将缓存的值设置为软引用来控制缓存的大小。当系统内存不足时，垃圾回收器可能会回收这些被缓存的值。</li></ul><ol start="2"><li><strong>基于时间的淘汰策略（Time-based Eviction）：</strong></li></ol><ul><li>expireAfterAccess(duration, unit)：设置缓存条目在指定时间内没有被访问后被移除。</li><li>expireAfterWrite(duration, unit)：设置缓存条目在被添加到缓存后的指定时间后被移除。</li></ul><ol start="3"><li><strong>弱引用淘汰策略（Weak Reference Eviction）：</strong></li></ol><ul><li>weakKeys()：通过将缓存的键设置为弱引用来控制缓存的大小。当系统内存不足时，垃圾回收器可能会回收这些被缓存的键。</li></ul><ol start="4"><li><strong>基于访问的淘汰策略（Reference-based Eviction）：</strong></li></ol><ul><li>expireAfter(duration, unit)：设置缓存条目在指定时间内没有被访问后被移除，类似于expireAfterAccess()，但是使用引用计数来跟踪访问。</li></ul><p>以上是Guava Cache提供的常见缓存淘汰策略。可以根据具体的需求选择合适的淘汰策略，或者根据需求组合使用多个淘汰策略来控制缓存的行为。在创建缓存时，可以通过CacheBuilder类的方法来设置相应的淘汰策略。例如：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cache <span class="token operator">=</span> <span class="token class-name">CacheBuilder</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">expireAfterAccess</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">HOURS</span><span class="token punctuation">)</span> <span class="token comment">// 设置缓存条目在1小时内没有被访问后被移除</span>
<span class="token punctuation">.</span><span class="token function">maximumSize</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 设置缓存的最大容量为100</span>
<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过合理地设置缓存淘汰策略，可以避免缓存中存储过多的无用数据，提高缓存的效率和性能。</p><h2 id="guava-cache的不足" tabindex="-1"><a class="header-anchor" href="#guava-cache的不足"><span>Guava Cache的不足</span></a></h2><p>尽管Guava Cache是一个功能强大的缓存库，但它也有一些缺点和不足之处：</p><ol><li>单机缓存：Guava Cache是一个本地缓存，只能在单个JVM实例中使用。它不适用于分布式系统或多个应用程序实例之间的缓存共享。</li><li>内存限制：Guava Cache使用内存来存储缓存项，因此它受限于可用的内存大小。如果缓存项过多或占用过多的内存，可能会导致内存耗尽或应用程序性能下降。</li><li>缓存加载期间的阻塞：当缓存中不存在所需的键时，Guava Cache会自动调用加载方法来加载数据。在加载期间，如果有多个线程同时访问同一个键，可能会导致其他线程阻塞等待加载完成。</li><li>缓存项的过期处理：Guava Cache使用了惰性删除策略来处理过期缓存项。这意味着在缓存项过期之前，它仍然存在于缓存中，只有在下次访问时才会被删除。这可能会导致过期缓存项在一段时间内仍然被返回，从而影响应用程序的准确性。</li><li>缺乏持久化支持：Guava Cache不支持将缓存项持久化到磁盘或其他外部存储介质。如果应用程序重启或内存溢出，所有的缓存项将会丢失，需要重新加载。</li></ol><p>尽管Guava Cache存在一些缺点，但它仍然是一个非常有用和强大的缓存库，适用于大多数Java应用程序的本地缓存需求。对于需要分布式缓存或持久化支持的场景，可能需要考虑其他缓存解决方案。</p><h2 id="与caffeine-cache对比" tabindex="-1"><a class="header-anchor" href="#与caffeine-cache对比"><span>与Caffeine Cache对比</span></a></h2><p>Guava Cache和Caffeine Cache都是基于Guava的缓存库，它们具有相似的特性和功能。然而，它们在一些方面还是有一些区别，以下是Guava Cache相对于Caffeine Cache的一些优势和不足：</p><p>优势：</p><ol><li>成熟度：Guava Cache是Guava库的一部分，已经存在了很长时间，并且经过了广泛的测试和使用。它是一个非常成熟和稳定的缓存库。</li><li>易于使用：Guava Cache提供了简单而直观的API，容易上手和使用。它的文档和社区支持也非常丰富，开发人员可以方便地找到解决方案和帮助。</li><li>灵活性：Guava Cache提供了多种缓存回收策略、过期策略和加载策略，可以根据需求进行配置和定制。它支持基于大小、时间、引用和权重的缓存回收，可以满足不同场景的需求。</li></ol><p>不足：</p><ol><li>性能：相对于Caffeine Cache，Guava Cache在性能方面可能稍逊一筹。Caffeine Cache在性能优化上进行了更多的工作，采用了一些高效的数据结构和算法，以提高缓存的响应速度和吞吐量。</li><li>功能扩展：相对于Guava Cache，Caffeine Cache提供了更多的扩展功能和特性。例如，Caffeine Cache支持异步加载缓存、缓存项的刷新操作、缓存项的监听器和事件通知等。</li><li>文档和社区支持：相对于Guava Cache，Caffeine Cache的文档和社区支持可能相对较少。由于Caffeine Cache是Guava的一个分支项目，相对于Guava Cache来说，它的资料和使用案例可能相对较少。</li></ol><p>总的来说，Guava Cache和Caffeine Cache都是优秀的缓存库，它们在不同的方面有一些差异。开发人员可以根据自己的需求和偏好选择适合的缓存库。如果对性能和扩展功能有更高的要求，可以考虑使用Caffeine Cache。如果更注重稳定性和成熟度，则可以选择Guava Cache。</p><h2 id="使用示例" tabindex="-1"><a class="header-anchor" href="#使用示例"><span>使用示例</span></a></h2><p>下面是一个使用Guava Cache的代码示例，包括加载、设置回收策略和获取缓存项的操作：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>common<span class="token punctuation">.</span>cache<span class="token punctuation">.</span></span><span class="token class-name">Cache</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>common<span class="token punctuation">.</span>cache<span class="token punctuation">.</span></span><span class="token class-name">CacheBuilder</span></span><span class="token punctuation">;</span>
 
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GuavaCacheExample</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个Guava Cache实例</span>
        <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cache <span class="token operator">=</span> <span class="token class-name">CacheBuilder</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">maximumSize</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 设置缓存容量</span>
                <span class="token punctuation">.</span><span class="token function">expireAfterWrite</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span> <span class="token comment">// 设置缓存项的过期时间</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">// 加载缓存项</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token string">&quot;key&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> value <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">loadFromDatabase</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">// 获取缓存项</span>
        <span class="token class-name">String</span> cachedValue <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Cached Value: &quot;</span> <span class="token operator">+</span> cachedValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">loadFromDatabase</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Loading value from database for key: &quot;</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 从数据库加载数据的逻辑</span>
        <span class="token comment">// ...</span>
 
        <span class="token keyword">return</span> <span class="token string">&quot;value&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，首先通过使用<code>CacheBuilder.newBuilder()</code>方法创建一个Guava Cache实例。然后可以使用<code>maximumSize()</code>方法设置缓存容量，<code>expireAfterWrite()</code>方法设置缓存项的过期时间。</p><p>在加载缓存项时，可以使用<code>cache.get(key, loader)</code>方法。如果缓存中已经存在该键对应的缓存项，则直接返回缓存值。如果缓存中不存在该键对应的缓存项，则调用<code>loader</code>函数加载数据，并将数据存入缓存中。</p><p>最后，可以使用<code>cache.getIfPresent(key)</code>方法获取缓存项的值。</p><p>请注意，在实际应用中，<code>loadFromDatabase()</code>方法应该根据实际需求从数据库或其他数据源加载数据。此处的示例只是一个简单的演示。</p>`,39)]))}const u=n(c,[["render",p],["__file","GuavaCache.html.vue"]]),r=JSON.parse('{"path":"/tool/GuavaCache.html","title":"","lang":"zh-CN","frontmatter":{"description":"引言 Guava Cache是一个功能强大且易于使用的缓存库，它提供了简单高效的缓存解决方案。本文将介绍Guava Cache的特性、使用方法以及与其他缓存库的比较，帮助读者了解并正确地使用Guava Cache。 概要 Guava Cache（也称为Guava缓存）是Google开源的一个Java库，用于实现本地缓存。它是Guava项目的一部分，是G...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/tool/GuavaCache.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"引言 Guava Cache是一个功能强大且易于使用的缓存库，它提供了简单高效的缓存解决方案。本文将介绍Guava Cache的特性、使用方法以及与其他缓存库的比较，帮助读者了解并正确地使用Guava Cache。 概要 Guava Cache（也称为Guava缓存）是Google开源的一个Java库，用于实现本地缓存。它是Guava项目的一部分，是G..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-29T06:25:28.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-04-29T06:25:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-29T06:25:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"引言","slug":"引言","link":"#引言","children":[]},{"level":2,"title":"概要","slug":"概要","link":"#概要","children":[]},{"level":2,"title":"淘汰策略","slug":"淘汰策略","link":"#淘汰策略","children":[]},{"level":2,"title":"Guava Cache的不足","slug":"guava-cache的不足","link":"#guava-cache的不足","children":[]},{"level":2,"title":"与Caffeine Cache对比","slug":"与caffeine-cache对比","link":"#与caffeine-cache对比","children":[]},{"level":2,"title":"使用示例","slug":"使用示例","link":"#使用示例","children":[]}],"git":{"createdTime":1745907928000,"updatedTime":1745907928000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":1}]},"readingTime":{"minutes":8.38,"words":2514},"filePathRelative":"tool/GuavaCache.md","localizedDate":"2025年4月29日","autoDesc":true}');export{u as comp,r as data};
