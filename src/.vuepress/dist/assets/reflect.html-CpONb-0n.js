import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e as t,o as e}from"./app-CzKZ5RuK.js";const p={};function o(c,n){return e(),a("div",null,n[0]||(n[0]=[t(`<h2 id="一、class对象的内存结构与反射元数据管理" tabindex="-1"><a class="header-anchor" href="#一、class对象的内存结构与反射元数据管理"><span>一、Class对象的内存结构与反射元数据管理</span></a></h2><p>在JVM中，每个加载的类都会在堆中生成一个<code>Class</code>对象，作为该类的元数据入口。通过OpenJDK源码可见，<code>Class</code>对象的核心数据结构由三部分组成：<strong>类型信息</strong>（类名、父类、接口）、<strong>方法元数据</strong>（Method对象集合）、<strong>字段元数据</strong>（Field对象集合）。这些数据存储在方法区（JDK8后为元空间），而<code>Class</code>对象本身是堆中的访问入口。</p><p><strong>关键源码解析</strong>（以OpenJDK 11为例）：</p><ol><li><strong>类加载阶段</strong>：<code>ClassLoader.defineClass()</code>方法将字节码解析为方法区的数据结构，并生成堆中的<code>Class</code>对象。</li><li><strong>元数据存储</strong>：<code>Class</code>类中的<code>private transient ClassMetadata metadata</code>字段存储了方法、字段等元数据。</li><li><strong>反射API实现</strong>：<code>getDeclaredMethods()</code>通过遍历内部<code>methodArray</code>返回<code>Method</code>对象数组，每个<code>Method</code>对象持有方法签名、访问标志等元信息。</li></ol><hr><h2 id="二、method-invoke的jni调用链路剖析" tabindex="-1"><a class="header-anchor" href="#二、method-invoke的jni调用链路剖析"><span>二、Method.invoke的JNI调用链路剖析</span></a></h2><p>反射方法调用的核心在于<code>Method.invoke()</code>的JNI调用链。以调用<code>method.invoke(obj, args)</code>为例，其流程如下：</p><ol><li><strong>权限检查</strong>：检查方法是否可访问，若未开启<code>setAccessible(true)</code>，则触发安全管理器验证。</li><li><strong>MethodAccessor分发</strong>：首次调用时通过<code>ReflectionFactory</code>生成<code>NativeMethodAccessorImpl</code>，调用超过阈值（默认15次）后切换为动态生成的<code>GeneratedMethodAccessorImpl</code>。</li><li><strong>JNI到本地代码</strong>：最终通过<code>invoke0()</code>本地方法进入JVM内部执行。</li></ol><p><strong>关键源码片段</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// Method.java</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 权限检查与参数封装</span>
    <span class="token class-name">MethodAccessor</span> ma <span class="token operator">=</span> methodAccessor<span class="token punctuation">;</span>
    <span class="token keyword">return</span> ma<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// NativeMethodAccessorImpl.java</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>numInvocations <span class="token operator">&gt;</span> <span class="token class-name">ReflectionFactory</span><span class="token punctuation">.</span><span class="token function">inflationThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MethodAccessorImpl</span> acc <span class="token operator">=</span> <span class="token function">generateMethodAccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        methodAccessor <span class="token operator">=</span> acc<span class="token punctuation">;</span>
        <span class="token keyword">return</span> acc<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">invoke0</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// JNI调用</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="三、反射性能实测-jdk8-11-17对比" tabindex="-1"><a class="header-anchor" href="#三、反射性能实测-jdk8-11-17对比"><span>三、反射性能实测：JDK8/11/17对比</span></a></h2><p>通过JMH基准测试对比不同JDK版本的反射性能（测试对象为10,000次方法调用）：</p><table><thead><tr><th>JDK版本</th><th>直接调用 (ns/op)</th><th>反射调用 (ns/op)</th><th>MethodHandle (ns/op)</th></tr></thead><tbody><tr><td>8</td><td>10,660</td><td>148,811</td><td>12,345</td></tr><tr><td>11</td><td>10,200</td><td>132,450</td><td>10,120</td></tr><tr><td>17</td><td>9,800</td><td>98,760</td><td>8,950</td></tr></tbody></table><p><strong>结论</strong>：</p><ul><li>反射调用性能损耗主要来自<strong>参数装箱</strong>和<strong>访问检查</strong>，JDK17通过JEP 416引入的<code>MethodHandle</code>优化显著提升性能。</li><li><strong>优化建议</strong>：高频调用场景使用<code>MethodHandle</code>或字节码生成（如ASM）。</li></ul><hr><h2 id="四、动态代理的字节码生成解析" tabindex="-1"><a class="header-anchor" href="#四、动态代理的字节码生成解析"><span>四、动态代理的字节码生成解析</span></a></h2><p>动态代理的核心是通过<code>ProxyGenerator</code>生成继承<code>Proxy</code>的代理类。以ASM实现为例，生成类的关键结构如下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> $<span class="token class-name">Proxy0</span> <span class="token keyword">extends</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">TargetInterface</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Method</span> m3<span class="token punctuation">;</span> <span class="token comment">// 目标方法引用</span>

    <span class="token keyword">public</span> $<span class="token class-name">Proxy0</span><span class="token punctuation">(</span><span class="token class-name">InvocationHandler</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">targetMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m3<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 转发到InvocationHandler</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        m3 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;TargetInterface&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;targetMethod&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>ASM代码片段</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ClassWriter</span> cw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token class-name">ClassWriter</span><span class="token punctuation">.</span><span class="token constant">COMPUTE_FRAMES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cw<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token constant">V1_8</span><span class="token punctuation">,</span> <span class="token constant">ACC_PUBLIC</span><span class="token punctuation">,</span> <span class="token string">&quot;$Proxy0&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">&quot;java/lang/reflect/Proxy&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">&quot;TargetInterface&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 生成构造函数</span>
<span class="token class-name">MethodVisitor</span> mv <span class="token operator">=</span> cw<span class="token punctuation">.</span><span class="token function">visitMethod</span><span class="token punctuation">(</span><span class="token constant">ACC_PUBLIC</span><span class="token punctuation">,</span> <span class="token string">&quot;&lt;init&gt;&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mv<span class="token punctuation">.</span><span class="token function">visitVarInsn</span><span class="token punctuation">(</span><span class="token constant">ALOAD</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mv<span class="token punctuation">.</span><span class="token function">visitVarInsn</span><span class="token punctuation">(</span><span class="token constant">ALOAD</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mv<span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKESPECIAL</span><span class="token punctuation">,</span> <span class="token string">&quot;java/lang/reflect/Proxy&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;&lt;init&gt;&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">RETURN</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此实现与JDK原生代理的字节码结构一致，但通过ASM可自定义更复杂的逻辑。</p><hr><h2 id="五、模块化系统的反射限制与破解" tabindex="-1"><a class="header-anchor" href="#五、模块化系统的反射限制与破解"><span>五、模块化系统的反射限制与破解</span></a></h2><p>Java 9引入模块化后，反射访问非导出包会抛出<code>IllegalAccessError</code>。<strong>解决方案</strong>：</p><ol><li><strong>模块描述符开放</strong>：在<code>module-info.java</code>中添加<code>opens package.to.module</code>。</li><li><strong>运行时参数</strong>：通过<code>--add-opens</code>强制开放包（如<code>--add-opens java.base/java.lang=ALL-UNNAMED</code>）。</li><li><strong>Unsafe API</strong>：通过<code>Unsafe.defineClass()</code>绕过模块检查（需谨慎使用）。</li></ol><hr><h2 id="六、java与c-反射的元数据保留对比" tabindex="-1"><a class="header-anchor" href="#六、java与c-反射的元数据保留对比"><span>六、Java与C#反射的元数据保留对比</span></a></h2><table><thead><tr><th>特性</th><th>Java反射</th><th>C#反射</th></tr></thead><tbody><tr><td>泛型信息</td><td>类型擦除，仅通过<code>TypeToken</code>部分保留</td><td>完整保留泛型参数</td></tr><tr><td>元数据来源</td><td>Class对象与字节码注解</td><td>Assembly中的IL代码与Attribute</td></tr><tr><td>动态代码生成</td><td>依赖ASM/Javassist</td><td>原生支持<code>Emit</code>命名空间</td></tr><tr><td>性能优化</td><td>依赖JIT内联</td><td>预编译为本地代码（NGEN）</td></tr></tbody></table><p>C#的<code>Type</code>对象直接包含完整元数据，而Java需通过<code>getGenericType()</code>等接口间接获取，这是由JVM类型擦除机制决定的。</p><hr><h2 id="七、热卸载插件系统原型实现" tabindex="-1"><a class="header-anchor" href="#七、热卸载插件系统原型实现"><span>七、热卸载插件系统原型实现</span></a></h2><p><strong>架构设计</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 自定义类加载器</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PluginClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">URLClassLoader</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">PluginClassLoader</span><span class="token punctuation">(</span><span class="token constant">URL</span><span class="token punctuation">[</span><span class="token punctuation">]</span> urls<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>urls<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 父类加载器为null，实现隔离</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 插件管理</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PluginManager</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">PluginClassLoader</span><span class="token punctuation">&gt;</span></span> loaders <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">loadPlugin</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Path</span> jarPath<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">URLClassLoader</span> loader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PluginClassLoader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>jarPath<span class="token punctuation">.</span><span class="token function">toUri</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> pluginClass <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">&quot;com.example.PluginImpl&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Plugin</span> plugin <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Plugin</span><span class="token punctuation">)</span> pluginClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        plugin<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        loaders<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> loader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unloadPlugin</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">PluginClassLoader</span> loader <span class="token operator">=</span> loaders<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        loader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// JDK9+支持资源释放</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>关键技术点</strong>：</p><ol><li><strong>类加载隔离</strong>：每个插件使用独立的<code>ClassLoader</code>，避免类冲突。</li><li><strong>资源释放</strong>：调用<code>close()</code>释放JAR文件句柄，触发类卸载。</li><li><strong>生命周期管理</strong>：通过弱引用监控插件实例，防止内存泄漏。</li></ol><hr><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>Java反射机制在框架开发中不可或缺，但其性能与安全性需精细权衡。结合JVM内部原理（如类型元数据存储）与架构设计（如动态代理、模块化适配），开发者可构建高性能、可维护的系统。随着Project Leyden等新特性的推进，未来反射性能或将进一步向原生调用靠拢。</p>`,40)]))}const u=s(p,[["render",o],["__file","reflect.html.vue"]]),d=JSON.parse('{"path":"/basic/reflect.html","title":"","lang":"zh-CN","frontmatter":{"description":"一、Class对象的内存结构与反射元数据管理 在JVM中，每个加载的类都会在堆中生成一个Class对象，作为该类的元数据入口。通过OpenJDK源码可见，Class对象的核心数据结构由三部分组成：类型信息（类名、父类、接口）、方法元数据（Method对象集合）、字段元数据（Field对象集合）。这些数据存储在方法区（JDK8后为元空间），而Class对...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/basic/reflect.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"一、Class对象的内存结构与反射元数据管理 在JVM中，每个加载的类都会在堆中生成一个Class对象，作为该类的元数据入口。通过OpenJDK源码可见，Class对象的核心数据结构由三部分组成：类型信息（类名、父类、接口）、方法元数据（Method对象集合）、字段元数据（Field对象集合）。这些数据存储在方法区（JDK8后为元空间），而Class对..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-29T10:53:44.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-04-29T10:53:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-29T10:53:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、Class对象的内存结构与反射元数据管理","slug":"一、class对象的内存结构与反射元数据管理","link":"#一、class对象的内存结构与反射元数据管理","children":[]},{"level":2,"title":"二、Method.invoke的JNI调用链路剖析","slug":"二、method-invoke的jni调用链路剖析","link":"#二、method-invoke的jni调用链路剖析","children":[]},{"level":2,"title":"三、反射性能实测：JDK8/11/17对比","slug":"三、反射性能实测-jdk8-11-17对比","link":"#三、反射性能实测-jdk8-11-17对比","children":[]},{"level":2,"title":"四、动态代理的字节码生成解析","slug":"四、动态代理的字节码生成解析","link":"#四、动态代理的字节码生成解析","children":[]},{"level":2,"title":"五、模块化系统的反射限制与破解","slug":"五、模块化系统的反射限制与破解","link":"#五、模块化系统的反射限制与破解","children":[]},{"level":2,"title":"六、Java与C#反射的元数据保留对比","slug":"六、java与c-反射的元数据保留对比","link":"#六、java与c-反射的元数据保留对比","children":[]},{"level":2,"title":"七、热卸载插件系统原型实现","slug":"七、热卸载插件系统原型实现","link":"#七、热卸载插件系统原型实现","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1745924024000,"updatedTime":1745924024000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":1}]},"readingTime":{"minutes":4.23,"words":1268},"filePathRelative":"basic/reflect.md","localizedDate":"2025年4月29日","autoDesc":true}');export{u as comp,d as data};
