import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e as n,o as r}from"./app-CzKZ5RuK.js";const d={};function i(o,t){return r(),a("div",null,t[0]||(t[0]=[n(`<h2 id="_1-什么是mvcc" tabindex="-1"><a class="header-anchor" href="#_1-什么是mvcc"><span>1. 什么是MVCC</span></a></h2><p><strong>MVCC</strong>全称是<strong>Multi-Version Concurrency Control</strong>（多版本并发控制），是一种并发控制的方法，通过维护一个数据的多个版本，减少读写操作的冲突。 如果没有<strong>MVCC</strong>，想要实现同一条数据的并发读写，还要保证数据的安全性，就需要操作数据的时候加读锁和写锁，这样就降低了数据库的并发性能。 有了<strong>MVCC</strong>，就相当于把同一份数据生成了多个版本，在操作的开始各生成一个快照，读写操作互不影响。无需加锁，也实现数据的安全性和事务的隔离性。 事务的四大特性中隔离性就是基于<strong>MVCC</strong>实现的。 说MVCC的实现原理之前，先说一下事务的隔离级别。</p><h2 id="_2-事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#_2-事务的隔离级别"><span>2. 事务的隔离级别</span></a></h2><p>说隔离级别之前，先说一下<strong>并发事务产生的问题</strong>： <strong>脏读：</strong> 一个事务读到其他事务未提交的数据。 <strong>不可重复读：</strong> 相同的查询条件，多次查询到的结果不一致，即读到其他事务提交后的数据。 <strong>幻读：</strong> 相同的查询条件，多次查询到的结果不一致，即读到其他事务提交后的数据。 <strong>不可重复读与幻读的区别是：</strong> 不可重复读是读到了其他事务执行update、delete后的数据，而幻读是读到其他事务执行insert后的数据。</p><p><strong>再说一下事务的四大隔离级别：</strong><strong>Read UnCommitted（读未提交）：</strong> 读到其他事务未提交的数据，会出现脏读、不可重复读、幻读。 <strong>Read Committed（读已提交）：</strong> 读到其他事务已提交的数据，解决了脏读，会出现不可重复读、幻读。 <strong>Repeatable Read（可重复读）：</strong> 相同的条件，多次读取到的结果一致。解决了脏读、不可重复读，会出现幻读。 <strong>Serializable（串行化）：</strong> 所有事务串行执行，解决了脏读、不可重复读、幻读。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>会</td><td>会</td><td>会</td></tr><tr><td>读已提交</td><td>不会</td><td>会</td><td>会</td></tr><tr><td>可重复读</td><td>不会</td><td>不会</td><td>会</td></tr><tr><td>串行化</td><td>不会</td><td>不会</td><td>不会</td></tr></tbody></table><p>MVCC只在<strong>Read Committed</strong>和<strong>Repeatable Read</strong>两个隔离级别下起作用，因为<strong>Read UnCommitted</strong>隔离级别下，读写都不加锁，<strong>Serializable</strong>隔离级别下，读写都加锁，也就不需要<strong>MVCC</strong>了。 再谈一下<strong>Undo log</strong>日志。</p><h2 id="_3-undo-log-回滚日志" tabindex="-1"><a class="header-anchor" href="#_3-undo-log-回滚日志"><span>3. Undo Log（回滚日志）</span></a></h2><p><strong>Undo Log</strong>记录的是逻辑日志，也就是SQL语句。 比如：当我们执行一条insert语句时，<strong>Undo Log</strong>就记录一条相反的delete语句。</p><p><strong>作用：</strong></p><ol><li>回滚事务时，恢复到修改前的数据。</li><li>实现 <strong>MVCC</strong> 。</li></ol><p>事务四大特性中原子性也是基于<strong>Undo Log</strong>实现的。 下面开始谈一下<strong>MVCC</strong>的实现原理。</p><h2 id="_4-mvcc的实现原理" tabindex="-1"><a class="header-anchor" href="#_4-mvcc的实现原理"><span>4. MVCC的实现原理</span></a></h2><h3 id="_4-1-当前读和快照读" tabindex="-1"><a class="header-anchor" href="#_4-1-当前读和快照读"><span>4.1 当前读和快照读</span></a></h3><p>先普及一下什么是当前读和快照读。 <strong>当前读：</strong> 读取数据的最新版本，并对数据进行加锁。 例如：insert、update、delete、select for update、 select lock in share mode。</p><p><strong>快照读：</strong> 读取数据的历史版本，不对数据加锁。 例如：select</p><p>MVCC是基于Undo Log、隐藏字段、Read View（读视图）实现的。</p><h3 id="_4-2-隐藏字段" tabindex="-1"><a class="header-anchor" href="#_4-2-隐藏字段"><span>4.2 隐藏字段</span></a></h3><p>先说一下MySQL的隐藏字段，当我们创建一张表时，InnoDB引擎会增加2个隐藏字段。 <strong>DB_TRX_ID（最近一次提交事务的ID）</strong>：修改表数据时，都会提交事务，每个事务都有一个唯一的ID，这个字段就记录了最近一次提交事务的ID。 <strong>DB_ROLL_PTR（上个版本的地址）</strong>：修改表数据时，旧版本的数据都会被记录到Undo Log日志中，每个版本的数据都有一个版本地址，这个字段记录的就是上个版本的地址。</p><h3 id="_4-3-版本链" tabindex="-1"><a class="header-anchor" href="#_4-3-版本链"><span>4.3 版本链</span></a></h3><p>当我们第一次往用户表插入一条记录时，表数据和隐藏字段的值是下面这样的：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>insert into user (name,age) values (&#39;一灯&#39;,1);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>事务ID（DB_TRX_ID）是1，上个版本地址（DB_ROLL_PTR）是null。 <img src="https://javabaguwen.com/img/MVCC1.png" alt="" loading="lazy"> 第二次提交事务，把用户年龄加1。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>update user set age=age+1 where id=1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>事务ID变成2，上个版本地址指向Undo Log中的记录。 <img src="https://javabaguwen.com/img/MVCC2.png" alt="" loading="lazy"> 第三次提交事务，再把用户年龄加1。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>update user set age=age+1 where id=1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>事务ID变成3，上个版本地址指向Undo Log中事务ID为2的记录。 <img src="https://javabaguwen.com/img/MVCC3.png" alt="" loading="lazy"> 这样表记录和<strong>Undo Log</strong>历史数据就组成了一个版本链。</p><h3 id="_4-4-read-view-读视图" tabindex="-1"><a class="header-anchor" href="#_4-4-read-view-读视图"><span>4.4 Read View（读视图）</span></a></h3><p>在事务中，执行SQL查询，就会生成一个读视图，是用来保证数据的可见性，即读到Undo Log中哪个版本的数据。 <strong>快照读</strong>一般是读取的历史版本的读视图，<strong>当前图</strong>会生成一个最新版本的读视图。 读视图是基于下面几个字段实现的： <strong>m_ids</strong> ：当前系统中活跃的事务ID集合，即未提交的事务。 <strong>min_trx_id</strong> ：m_ids中最小的ID <strong>max_trx_id</strong> ：下一个要分配的事务ID <strong>creator_trx_id</strong>: 当前事务ID 读视图决定当前事务能读到哪个版本的数据，从表记录到<strong>Undo Log</strong>历史数据的版本链，依次匹配，满足哪个版本的匹配规则，就能读到哪个版本的数据，一旦匹配成功就不再往下匹配。</p><p><strong>数据可见性规则：</strong></p><ol><li><strong>DB_TRX_ID = creator_trx_id</strong> 如果这个版本数据的事务ID等于当前事务ID，表示数据记录的最后一次操作的事务就是当前事务，当前读视图可以读到这个版本的数据。</li><li><strong>DB_TRX_ID &lt; min_trx_id</strong> 如果这个版本数据的事务ID小于所有活跃事务ID，表示这个版本的数据不再被事务使用，即事务已提交，当前读视图可以读到这个版本的数据。</li><li><strong>DB_TRX_ID &gt;= max_trx_id</strong> 如果这个版本数据的事务ID大于等于下一个要分配的事务ID，表示有新事务更新了这个版本的数据，这种情况下，当前读视图不可以读到这个版本的数据。</li><li><strong>min_trx_id &lt;= DB_TRX_ID &lt; max_trx_id</strong> 如果这个版本数据的事务ID在当前系统中活跃的事务ID集合（m_ids）里面，表示这个版本的数据被其他事务更新过，当前读视图不可以读到这个版本的数据。 如果这个版本数据的事务ID不在当前系统中活跃的事务ID集合（m_ids）里面，表示是在其他事务提交后创建的读视图，当前读视图可以读到这个版本的数据。</li></ol><h2 id="_5-不同隔离级别下可见性分析" tabindex="-1"><a class="header-anchor" href="#_5-不同隔离级别下可见性分析"><span>5. 不同隔离级别下可见性分析</span></a></h2><p>在不同的事务隔离级别下，生成读视图的规则不同：</p><ul><li><strong>READ COMMITTED（读已提交）</strong> ：在事务中每一次执行快照读时都生成一个读视图，每个读视图中四个字段的值都是不同的。</li><li><strong>REPEATABLE READ（可重复读）</strong>：仅在事务中第一次执行快照读时生成读视图，后续复用这个读视图。</li></ul><h3 id="_5-1-read-committed-读已提交" tabindex="-1"><a class="header-anchor" href="#_5-1-read-committed-读已提交"><span>5.1 READ COMMITTED（读已提交）</span></a></h3><p>设置MySQL隔离级别为读已提交：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>SET session TRANSACTION ISOLATION LEVEL READ COMMITTED;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://javabaguwen.com/img/MVCC12.png" alt="" loading="lazy"> 执行两个事务，验证一下： <img src="https://javabaguwen.com/img/MVCC4.png" alt="" loading="lazy"> 事务1第一次查询时，会生成一个读视图，读视图的各个属性如下：</p><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>m_ids</td><td>1,2</td></tr><tr><td>min_limit_id</td><td>1</td></tr><tr><td>max_limit_id</td><td>3</td></tr><tr><td>creator_trx_id</td><td>1</td></tr></tbody></table><p>可见的版本链数据是：</p><p><img src="https://javabaguwen.com/img/MVCC5.png" alt="" loading="lazy"> 符号规则 <code>DB_TRX_ID = creator_trx_id = 1</code>，可以看到当前版本的数据。 事务1第二次查询时，会生成一个新的读视图，读视图的各个属性如下：</p><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>m_ids</td><td>1</td></tr><tr><td>min_limit_id</td><td>1</td></tr><tr><td>max_limit_id</td><td>3</td></tr><tr><td>creator_trx_id</td><td>1</td></tr></tbody></table><p>可见的版本链数据是： <img src="https://javabaguwen.com/img/MVCC6.png" alt="" loading="lazy"> 符号规则 <code>min_trx_id &lt;= DB_TRX_ID &lt; max_trx_id（1&lt;=2&lt;3）</code>，并且当前数据版本的事务ID不在当前系统中活跃的事务ID集合，可以看到当前版本的数据。 <img src="https://javabaguwen.com/img/MVCC7.png" alt="" loading="lazy"> 同一个事务内，相同的查询条件，查询到的数据不一致，查到了其他事务更新过的数据，也就是出现了不可重复读的情况。 再看一下，在可重复读隔离级别下，是怎么解决这个问题的。</p><h3 id="_5-2-repeatable-read-可重复读" tabindex="-1"><a class="header-anchor" href="#_5-2-repeatable-read-可重复读"><span>5.2 REPEATABLE READ（可重复读）</span></a></h3><p>设置MySQL隔离级别为可重复读：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>SET session TRANSACTION ISOLATION LEVEL REPEATABLE READ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://javabaguwen.com/img/MVCC13.png" alt="" loading="lazy"> 执行两个事务，验证一下： <img src="https://javabaguwen.com/img/MVCC8.png" alt="" loading="lazy"> 事务1第一次查询时，会生成一个读视图，读视图的各个属性如下：</p><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>m_ids</td><td>1,2</td></tr><tr><td>min_limit_id</td><td>1</td></tr><tr><td>max_limit_id</td><td>3</td></tr><tr><td>creator_trx_id</td><td>1</td></tr></tbody></table><p>可见的版本链数据是： <img src="https://javabaguwen.com/img/MVCC9.png" alt="" loading="lazy"></p><p>符号规则 <code>DB_TRX_ID = creator_trx_id = 1</code>，可以看到当前版本的数据。 事务1第二次查询时，会复用原有的读视图，读视图的各个属性如下：</p><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>m_ids</td><td>1，2</td></tr><tr><td>min_limit_id</td><td>1</td></tr><tr><td>max_limit_id</td><td>3</td></tr><tr><td>creator_trx_id</td><td>1</td></tr></tbody></table><p>可见的版本链数据是：</p><p><img src="https://javabaguwen.com/img/MVCC10.png" alt="" loading="lazy"> 符号规则 <code>min_trx_id &lt;= DB_TRX_ID &lt; max_trx_id（1&lt;=2&lt;3）</code>，并且当前数据版本的事务ID在当前系统中活跃的事务ID集合，所以是不可以看到当前版本的数据。 <img src="https://javabaguwen.com/img/MVCC11.png" alt="" loading="lazy"> 由此得知，可重复读隔离级别下，相同的查询条件，两次查询到的结果相同，也就是解决了可重复读的问题，是通过复用原有的读视图的方式解决的。</p>`,53)]))}const g=e(d,[["render",i],["__file","MVCC.html.vue"]]),p=JSON.parse('{"path":"/mysql/mvcc.html","title":"","lang":"zh-CN","frontmatter":{"description":"1. 什么是MVCC MVCC全称是Multi-Version Concurrency Control（多版本并发控制），是一种并发控制的方法，通过维护一个数据的多个版本，减少读写操作的冲突。 如果没有MVCC，想要实现同一条数据的并发读写，还要保证数据的安全性，就需要操作数据的时候加读锁和写锁，这样就降低了数据库的并发性能。 有了MVCC，就相当于把...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/mysql/mvcc.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"1. 什么是MVCC MVCC全称是Multi-Version Concurrency Control（多版本并发控制），是一种并发控制的方法，通过维护一个数据的多个版本，减少读写操作的冲突。 如果没有MVCC，想要实现同一条数据的并发读写，还要保证数据的安全性，就需要操作数据的时候加读锁和写锁，这样就降低了数据库的并发性能。 有了MVCC，就相当于把..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javabaguwen.com/img/MVCC1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-29T06:25:28.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-04-29T06:25:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://javabaguwen.com/img/MVCC1.png\\",\\"https://javabaguwen.com/img/MVCC2.png\\",\\"https://javabaguwen.com/img/MVCC3.png\\",\\"https://javabaguwen.com/img/MVCC12.png\\",\\"https://javabaguwen.com/img/MVCC4.png\\",\\"https://javabaguwen.com/img/MVCC5.png\\",\\"https://javabaguwen.com/img/MVCC6.png\\",\\"https://javabaguwen.com/img/MVCC7.png\\",\\"https://javabaguwen.com/img/MVCC13.png\\",\\"https://javabaguwen.com/img/MVCC8.png\\",\\"https://javabaguwen.com/img/MVCC9.png\\",\\"https://javabaguwen.com/img/MVCC10.png\\",\\"https://javabaguwen.com/img/MVCC11.png\\"],\\"dateModified\\":\\"2025-04-29T06:25:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 什么是MVCC","slug":"_1-什么是mvcc","link":"#_1-什么是mvcc","children":[]},{"level":2,"title":"2. 事务的隔离级别","slug":"_2-事务的隔离级别","link":"#_2-事务的隔离级别","children":[]},{"level":2,"title":"3. Undo Log（回滚日志）","slug":"_3-undo-log-回滚日志","link":"#_3-undo-log-回滚日志","children":[]},{"level":2,"title":"4. MVCC的实现原理","slug":"_4-mvcc的实现原理","link":"#_4-mvcc的实现原理","children":[{"level":3,"title":"4.1 当前读和快照读","slug":"_4-1-当前读和快照读","link":"#_4-1-当前读和快照读","children":[]},{"level":3,"title":"4.2 隐藏字段","slug":"_4-2-隐藏字段","link":"#_4-2-隐藏字段","children":[]},{"level":3,"title":"4.3 版本链","slug":"_4-3-版本链","link":"#_4-3-版本链","children":[]},{"level":3,"title":"4.4 Read View（读视图）","slug":"_4-4-read-view-读视图","link":"#_4-4-read-view-读视图","children":[]}]},{"level":2,"title":"5. 不同隔离级别下可见性分析","slug":"_5-不同隔离级别下可见性分析","link":"#_5-不同隔离级别下可见性分析","children":[{"level":3,"title":"5.1 READ COMMITTED（读已提交）","slug":"_5-1-read-committed-读已提交","link":"#_5-1-read-committed-读已提交","children":[]},{"level":3,"title":"5.2 REPEATABLE READ（可重复读）","slug":"_5-2-repeatable-read-可重复读","link":"#_5-2-repeatable-read-可重复读","children":[]}]}],"git":{"createdTime":1745907928000,"updatedTime":1745907928000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":1}]},"readingTime":{"minutes":7.86,"words":2358},"filePathRelative":"mysql/mvcc.md","localizedDate":"2025年4月29日","autoDesc":true}');export{g as comp,p as data};
