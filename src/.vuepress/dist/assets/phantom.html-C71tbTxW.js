import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e as n,o as s}from"./app-CzKZ5RuK.js";const o={};function r(i,t){return s(),a("div",null,t[0]||(t[0]=[n('<p>MySQL InnoDB引擎在Repeatable Read（可重复读）隔离级别下，到底有没有解决幻读的问题？ 网上众说纷纭，有的说解决了，有的说没解决，甚至有些大v的意见都无法达成统一。 今天就深入剖析一下，彻底解决这个幻读的问题。 解决幻读问题之前，先普及几个知识点。</p><h2 id="_1-并发事务产生的问题" tabindex="-1"><a class="header-anchor" href="#_1-并发事务产生的问题"><span>1. 并发事务产生的问题</span></a></h2><p>先创建一张用户表，用作数据验证：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>CREATE TABLE `user` (\n  `id` int NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  `name` varchar(100) DEFAULT NULL COMMENT &#39;姓名&#39;,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB COMMENT=&#39;用户表&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>并发事务会产生下面三个问题：</p><h3 id="脏读" tabindex="-1"><a class="header-anchor" href="#脏读"><span>脏读</span></a></h3><p><strong>定义：</strong> 一个事务读到其他事务未提交的数据。 <img src="https://javabaguwen.com/img/幻读1.png" alt="" loading="lazy"> 从上面的示例图中，可以看出，在事务2修改完数据，没有提交的情况。事务1已经读到事务2最新修改的数据，这种情况就属于脏读。</p><h3 id="不可重复读" tabindex="-1"><a class="header-anchor" href="#不可重复读"><span>不可重复读</span></a></h3><p><strong>定义：</strong> 一个事务读取到其他事务修改过的数据。 <img src="https://javabaguwen.com/img/幻读2.png" alt="" loading="lazy"> 从上面的示例图中，可以看出，在事务2修改完数据，并提交事务后。事务1第二次查询已经读到事务2最新修改的数据，这种情况就属于不可重复读。</p><h3 id="幻读" tabindex="-1"><a class="header-anchor" href="#幻读"><span>幻读</span></a></h3><p><strong>定义：</strong> 一个事务读取到其他事务最新插入的数据。 <img src="https://javabaguwen.com/img/幻读3.png" alt="" loading="lazy"> 从上面的示例图中，可以看出，在事务2插入完数据，并提交事务后。事务1第二次查询已经读到事务2最新插入的数据，这种情况就属于幻读。</p><h2 id="_2-快照读和当前读" tabindex="-1"><a class="header-anchor" href="#_2-快照读和当前读"><span>2. 快照读和当前读</span></a></h2><p>再普及一下快照读和当前读。 <strong>快照读：</strong> 读取数据的历史版本，不对数据加锁。 例如：select</p><p><strong>当前读：</strong> 读取数据的最新版本，并对数据进行加锁。 例如：insert、update、delete、select for update、select lock in share mode。</p><h2 id="_3-再谈幻读问题" tabindex="-1"><a class="header-anchor" href="#_3-再谈幻读问题"><span>3. 再谈幻读问题</span></a></h2><p>MySQL在<strong>Repeatable Read（可重复读）<strong>隔离级别下，到底有没有解决</strong>幻读</strong>的问题？ 只能说是部分解决了<strong>幻读</strong>问题。 首先，在快照读的情况下，是通过<strong>MVCC（复用读视图）<strong>解决了幻读问题。 想详细了解MVCC和读视图，可以翻一下上篇文章。 先手动设置一下MySQL的隔离级别为</strong>可重复读</strong>：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://javabaguwen.com/img/幻读4.png" alt="" loading="lazy"> 执行测试用例，验证一下： <img src="https://javabaguwen.com/img/幻读5.png" alt="" loading="lazy"> 从上面的示例图中，可以看出，事务1的两次查询，得到的结果一致，并没有查到事务2最新插入的数据。 原因是，在可重复读隔离级别下，第一次快照读的时候，生成了一个读视图。第二次快照读的时候，复用了第一次生成的读视图，所以两次查询得到的结果一致。 所以，在快照读的情况下，<strong>可重复读</strong>隔离级别是解决了<strong>幻读</strong>的问题。 再测试一下，在<strong>当前读</strong>的情况下，<strong>可重复读</strong>隔离级别是否解决<strong>幻读</strong>问题：</p><p><img src="https://javabaguwen.com/img/幻读6.png" alt="" loading="lazy"> 从上面的示例图中，可以看出，事务1的两次查询，得到的结果不一致。在事务2插入数据，并提交事务后。事务1的第二次执行<strong>当前读（加了for update）<strong>的时候，读到了事务2最新插入的数据。 原因是，在可重复读隔离级别下，每次执行当前读会生成一个新的</strong>读视图</strong>，所以能读到其他事务最新插入的数据。 所以，在<strong>当前读</strong>的情况下，<strong>可重复读</strong>隔离级别是没有解决了<strong>幻读</strong>的问题。</p><p>在执行上面的测试用例的时候，我忽然想到一个问题，既然select for update的当前读，出现了幻读问题，是不是其他的当前读也会复现幻读问题，比如insert。 再执行测试用例，验证一下：</p><p><img src="https://javabaguwen.com/img/幻读7.png" alt="" loading="lazy"> 跟预想的一样，在insert当前读的情况下，也出现了幻读的问题（主键冲突）。 那有没有什么办法？在<strong>可重复读</strong>隔离级别下，执行<strong>当前读</strong>的时候，也能解<strong>决幻读</strong>的问题？ 当然有的，唯一的办法就是<strong>加锁</strong>。 <img src="https://javabaguwen.com/img/幻读8.png" alt="" loading="lazy"> 事务1在执行第一次查询的时候，就对数据进行加锁（使用for update），防止其他事务修改数据，这样也就彻底解决了<strong>幻读</strong>问题。 你觉得有什么好办法吗？</p>',21)]))}const l=e(o,[["render",r],["__file","phantom.html.vue"]]),d=JSON.parse('{"path":"/mysql/phantom.html","title":"","lang":"zh-CN","frontmatter":{"description":"MySQL InnoDB引擎在Repeatable Read（可重复读）隔离级别下，到底有没有解决幻读的问题？ 网上众说纷纭，有的说解决了，有的说没解决，甚至有些大v的意见都无法达成统一。 今天就深入剖析一下，彻底解决这个幻读的问题。 解决幻读问题之前，先普及几个知识点。 1. 并发事务产生的问题 先创建一张用户表，用作数据验证： 并发事务会产生下面三...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/mysql/phantom.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"MySQL InnoDB引擎在Repeatable Read（可重复读）隔离级别下，到底有没有解决幻读的问题？ 网上众说纷纭，有的说解决了，有的说没解决，甚至有些大v的意见都无法达成统一。 今天就深入剖析一下，彻底解决这个幻读的问题。 解决幻读问题之前，先普及几个知识点。 1. 并发事务产生的问题 先创建一张用户表，用作数据验证： 并发事务会产生下面三..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javabaguwen.com/img/%E5%B9%BB%E8%AF%BB1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-29T06:25:28.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-04-29T06:25:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://javabaguwen.com/img/%E5%B9%BB%E8%AF%BB1.png\\",\\"https://javabaguwen.com/img/%E5%B9%BB%E8%AF%BB2.png\\",\\"https://javabaguwen.com/img/%E5%B9%BB%E8%AF%BB3.png\\",\\"https://javabaguwen.com/img/%E5%B9%BB%E8%AF%BB4.png\\",\\"https://javabaguwen.com/img/%E5%B9%BB%E8%AF%BB5.png\\",\\"https://javabaguwen.com/img/%E5%B9%BB%E8%AF%BB6.png\\",\\"https://javabaguwen.com/img/%E5%B9%BB%E8%AF%BB7.png\\",\\"https://javabaguwen.com/img/%E5%B9%BB%E8%AF%BB8.png\\"],\\"dateModified\\":\\"2025-04-29T06:25:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 并发事务产生的问题","slug":"_1-并发事务产生的问题","link":"#_1-并发事务产生的问题","children":[{"level":3,"title":"脏读","slug":"脏读","link":"#脏读","children":[]},{"level":3,"title":"不可重复读","slug":"不可重复读","link":"#不可重复读","children":[]},{"level":3,"title":"幻读","slug":"幻读","link":"#幻读","children":[]}]},{"level":2,"title":"2. 快照读和当前读","slug":"_2-快照读和当前读","link":"#_2-快照读和当前读","children":[]},{"level":2,"title":"3. 再谈幻读问题","slug":"_3-再谈幻读问题","link":"#_3-再谈幻读问题","children":[]}],"git":{"createdTime":1745907928000,"updatedTime":1745907928000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":1}]},"readingTime":{"minutes":3.93,"words":1180},"filePathRelative":"mysql/phantom.md","localizedDate":"2025年4月29日","autoDesc":true}');export{l as comp,d as data};
