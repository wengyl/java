import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,e as t,o as i}from"./app-CzKZ5RuK.js";const p={};function l(s,a){return i(),n("div",null,a[0]||(a[0]=[t('<p>上篇文章讲了MySQL架构体系，了解到MySQL Server端的优化器可以生成Explain执行计划，而执行计划可以帮助我们分析SQL语句性能瓶颈，优化SQL查询逻辑，今天就一块学习Explain执行计划的具体用法。</p><h2 id="_1-explain的使用" tabindex="-1"><a class="header-anchor" href="#_1-explain的使用"><span>1. explain的使用</span></a></h2><p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈。 在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，并不会执行这条SQL。 就比如下面这个： <img src="https://javabaguwen.com/img/explain使用.png" alt="" loading="lazy"> 输出这么多列都是干嘛用的？ 其实大都是SQL语句的性能统计指标，先简单总结一下每一列的大致作用，下面详细讲一下：</p><figure><img src="https://javabaguwen.com/img/explain计划.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_2-explain字段详解" tabindex="-1"><a class="header-anchor" href="#_2-explain字段详解"><span>2. explain字段详解</span></a></h2><p>下面就详细讲一下每一列的具体作用。</p><h3 id="_1-id列" tabindex="-1"><a class="header-anchor" href="#_1-id列"><span>1. id列</span></a></h3><p>id表示查询语句的序号，自动分配，顺序递增，值越大，执行优先级越高。 <img src="https://javabaguwen.com/img/explain—id.png" alt="" loading="lazy"> id相同时，优先级由上而下。 <img src="https://javabaguwen.com/img/explain-id优先级.png" alt="" loading="lazy"></p><h3 id="_2-select-type列" tabindex="-1"><a class="header-anchor" href="#_2-select-type列"><span>2. select_type列</span></a></h3><p>select_type表示查询类型，常见的有SIMPLE简单查询、PRIMARY主查询、SUBQUERY子查询、UNION联合查询、UNION RESULT联合临时表结果等。 <img src="https://javabaguwen.com/img/explain-select-type.png" alt="" loading="lazy"></p><h3 id="_3-table列" tabindex="-1"><a class="header-anchor" href="#_3-table列"><span>3. table列</span></a></h3><p>table表示SQL语句查询的表名、表别名、临时表名。 <img src="https://javabaguwen.com/img/explain-table.png" alt="" loading="lazy"></p><h3 id="_4-partitions列" tabindex="-1"><a class="header-anchor" href="#_4-partitions列"><span>4. partitions列</span></a></h3><p>partitions表示SQL查询匹配到的分区，没有分区的话显示NULL。 <img src="https://javabaguwen.com/img/explain-partition.png" alt="" loading="lazy"></p><h3 id="_5-type列" tabindex="-1"><a class="header-anchor" href="#_5-type列"><span>5. type列</span></a></h3><p>type表示表连接类型或者数据访问类型，就是表之间通过什么方式建立连接的，或者通过什么方式访问到数据的。 具体有以下值，性能由好到差依次是：</p><blockquote><p>system &gt; const &gt; eq_ref &gt; ref  &gt; ref_or_null &gt; index_merge &gt; range &gt; index &gt; ALL</p></blockquote><h4 id="system" tabindex="-1"><a class="header-anchor" href="#system"><span><strong>system</strong></span></a></h4><p>当表中只有一行记录，也就是系统表，是 const 类型的特列。 <img src="https://javabaguwen.com/img/explain-type.png" alt="" loading="lazy"></p><h4 id="const" tabindex="-1"><a class="header-anchor" href="#const"><span><strong>const</strong></span></a></h4><p>表示使用主键或者唯一性索引进行等值查询，最多返回一条记录。性能较好，推荐使用。 <img src="https://javabaguwen.com/img/explain-type-const.png" alt="" loading="lazy"></p><h4 id="eq-ref" tabindex="-1"><a class="header-anchor" href="#eq-ref"><span><strong>eq_ref</strong></span></a></h4><p>表示<strong>表连接</strong>使用到了主键或者唯一性索引，下面的SQL就用到了user表主键id。 <img src="https://javabaguwen.com/img/explain-type-eq_ref.png" alt="" loading="lazy"></p><h4 id="ref" tabindex="-1"><a class="header-anchor" href="#ref"><span><strong>ref</strong></span></a></h4><p>表示使用非唯一性索引进行等值查询。 <img src="https://javabaguwen.com/img/explain-type-ref.png" alt="" loading="lazy"></p><h4 id="ref-or-null" tabindex="-1"><a class="header-anchor" href="#ref-or-null"><span><strong>ref_or_null</strong></span></a></h4><p>表示使用非唯一性索引进行等值查询，并且包含了null值的行。 <img src="https://javabaguwen.com/img/explain-ref_or_null.png" alt="" loading="lazy"></p><h4 id="index-merge" tabindex="-1"><a class="header-anchor" href="#index-merge"><span><strong>index_merge</strong></span></a></h4><p>表示用到索引合并的优化逻辑，即用到的多个索引。 <img src="https://javabaguwen.com/img/explain-index_merge.png" alt="" loading="lazy"></p><h4 id="range" tabindex="-1"><a class="header-anchor" href="#range"><span><strong>range</strong></span></a></h4><p>表示用到了索引范围查询。 <img src="https://javabaguwen.com/img/explain-type-range.png" alt="" loading="lazy"></p><h4 id="index" tabindex="-1"><a class="header-anchor" href="#index"><span><strong>index</strong></span></a></h4><p>表示使用索引进行全表扫描。 <img src="https://javabaguwen.com/img/explain-type-index.png" alt="" loading="lazy"></p><h4 id="all" tabindex="-1"><a class="header-anchor" href="#all"><span><strong>ALL</strong></span></a></h4><p>表示全表扫描，性能最差。 <img src="https://javabaguwen.com/img/explain-type-all.png" alt="" loading="lazy"></p><h3 id="_6-possible-keys列" tabindex="-1"><a class="header-anchor" href="#_6-possible-keys列"><span>6. possible_keys列</span></a></h3><p>表示可能用到的索引列，实际查询并不一定能用到。 <img src="https://javabaguwen.com/img/explain-possible_keys.png" alt="" loading="lazy"></p><h3 id="_7-key列" tabindex="-1"><a class="header-anchor" href="#_7-key列"><span>7. key列</span></a></h3><p>表示实际查询用到索引列。 <img src="https://javabaguwen.com/img/explain-key.png" alt="" loading="lazy"></p><h3 id="_8-key-len列" tabindex="-1"><a class="header-anchor" href="#_8-key-len列"><span>8. key_len列</span></a></h3><p>表示索引所占的字节数。 <img src="https://javabaguwen.com/img/explain-key_len.png" alt="" loading="lazy"> 每种类型所占的字节数如下：</p><table><thead><tr><th>类型</th><th>占用空间</th></tr></thead><tbody><tr><td>char(n)</td><td>n个字节</td></tr><tr><td>varchar(n)</td><td>2个字节存储变长字符串，如果是utf-8，则长度 3n + 2</td></tr><tr><td>tinyint</td><td>1个字节</td></tr><tr><td>smallint</td><td>2个字节</td></tr><tr><td>int</td><td>4个字节</td></tr><tr><td>bigint</td><td>8个字节</td></tr><tr><td>date</td><td>3个字节</td></tr><tr><td>timestamp</td><td>4个字节</td></tr><tr><td>datetime</td><td>8个字节</td></tr><tr><td>字段允许为NULL</td><td>额外增加1个字节</td></tr></tbody></table><h3 id="_9-ref列" tabindex="-1"><a class="header-anchor" href="#_9-ref列"><span>9. ref列</span></a></h3><p>表示where语句或者表连接中与索引比较的参数，常见的有const（常量）、func（函数）、字段名。 如果没用到索引，则显示为NULL。 <img src="https://javabaguwen.com/img/explain-ref1.png" alt="" loading="lazy"><img src="https://javabaguwen.com/img/explain-ref2.png" alt="" loading="lazy"><img src="https://javabaguwen.com/img/explain-ref3.png" alt="" loading="lazy"></p><h3 id="_10-rows列" tabindex="-1"><a class="header-anchor" href="#_10-rows列"><span>10. rows列</span></a></h3><p>表示执行SQL语句所扫描的行数。 <img src="https://javabaguwen.com/img/explain-rows.png" alt="" loading="lazy"></p><h3 id="_11-filtered列" tabindex="-1"><a class="header-anchor" href="#_11-filtered列"><span>11. filtered列</span></a></h3><p>表示按条件过滤的表行的百分比。 <img src="https://javabaguwen.com/img/explain-filtered.png" alt="" loading="lazy"> 用来估算与其他表连接时扫描的行数，row x filtered = 252004 x 10% = 25万行</p><h3 id="_12-extra列" tabindex="-1"><a class="header-anchor" href="#_12-extra列"><span>12. Extra列</span></a></h3><p>表示一些额外的扩展信息，不适合在其他列展示，却又十分重要。</p><h4 id="using-where" tabindex="-1"><a class="header-anchor" href="#using-where"><span><strong>Using where</strong></span></a></h4><p>表示使用了where条件搜索，但没有使用索引。 <img src="https://javabaguwen.com/img/explain-Using where.png" alt="" loading="lazy"></p><h4 id="using-index" tabindex="-1"><a class="header-anchor" href="#using-index"><span><strong>Using index</strong></span></a></h4><p>表示用到了覆盖索引，即在索引上就查到了所需数据，无需二次回表查询，性能较好。 <img src="https://javabaguwen.com/img/explain-Using index.png" alt="" loading="lazy"></p><h4 id="using-filesort" tabindex="-1"><a class="header-anchor" href="#using-filesort"><span><strong>Using filesort</strong></span></a></h4><p>表示使用了外部排序，即排序字段没有用到索引。 <img src="https://javabaguwen.com/img/explain-Using filesort.png" alt="" loading="lazy"></p><h4 id="using-temporary" tabindex="-1"><a class="header-anchor" href="#using-temporary"><span><strong>Using temporary</strong></span></a></h4><p>表示用到了临时表，下面的示例中就是用到临时表来存储查询结果。 <img src="https://javabaguwen.com/img/explain-Using temporary.png" alt="" loading="lazy"></p><h4 id="using-join-buffer" tabindex="-1"><a class="header-anchor" href="#using-join-buffer"><span><strong>Using join buffer</strong></span></a></h4><p>表示在进行表关联的时候，没有用到索引，使用了连接缓存区存储临时结果。 下面的示例中<strong>user_id</strong>在两张表中都没有建索引。 <img src="https://javabaguwen.com/img/explain-Using join buffer.png" alt="" loading="lazy"></p><h4 id="using-index-condition" tabindex="-1"><a class="header-anchor" href="#using-index-condition"><span><strong>Using index condition</strong></span></a></h4><p>表示用到<strong>索引下推</strong>的优化特性。 <img src="https://javabaguwen.com/img/explain-Using index condition.png" alt="" loading="lazy"></p><h2 id="知识点总结" tabindex="-1"><a class="header-anchor" href="#知识点总结"><span>知识点总结：</span></a></h2><p>本文详细介绍了Explain使用方式，以及每种参数所代表的含义。无论是工作还是面试，使用Explain优化SQL查询，都是必备的技能，一定要牢记。 下篇再一块学习一下SQL查询的其他优化方式，敬请期待。</p><figure><img src="https://javabaguwen.com/img/explain总结.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',65)]))}const o=e(p,[["render",l],["__file","explain.html.vue"]]),d=JSON.parse('{"path":"/mysql/explain.html","title":"","lang":"zh-CN","frontmatter":{"description":"上篇文章讲了MySQL架构体系，了解到MySQL Server端的优化器可以生成Explain执行计划，而执行计划可以帮助我们分析SQL语句性能瓶颈，优化SQL查询逻辑，今天就一块学习Explain执行计划的具体用法。 1. explain的使用 使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈。 在 selec...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/javabaguwen/mysql/explain.html"}],["meta",{"property":"og:site_name","content":"Java八股文网"}],["meta",{"property":"og:description","content":"上篇文章讲了MySQL架构体系，了解到MySQL Server端的优化器可以生成Explain执行计划，而执行计划可以帮助我们分析SQL语句性能瓶颈，优化SQL查询逻辑，今天就一块学习Explain执行计划的具体用法。 1. explain的使用 使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈。 在 selec..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javabaguwen.com/img/explain%E4%BD%BF%E7%94%A8.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-29T06:25:28.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2025-04-29T06:25:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://javabaguwen.com/img/explain%E4%BD%BF%E7%94%A8.png\\",\\"https://javabaguwen.com/img/explain%E8%AE%A1%E5%88%92.png\\",\\"https://javabaguwen.com/img/explain%E2%80%94id.png\\",\\"https://javabaguwen.com/img/explain-id%E4%BC%98%E5%85%88%E7%BA%A7.png\\",\\"https://javabaguwen.com/img/explain-select-type.png\\",\\"https://javabaguwen.com/img/explain-table.png\\",\\"https://javabaguwen.com/img/explain-partition.png\\",\\"https://javabaguwen.com/img/explain-type.png\\",\\"https://javabaguwen.com/img/explain-type-const.png\\",\\"https://javabaguwen.com/img/explain-type-eq_ref.png\\",\\"https://javabaguwen.com/img/explain-type-ref.png\\",\\"https://javabaguwen.com/img/explain-ref_or_null.png\\",\\"https://javabaguwen.com/img/explain-index_merge.png\\",\\"https://javabaguwen.com/img/explain-type-range.png\\",\\"https://javabaguwen.com/img/explain-type-index.png\\",\\"https://javabaguwen.com/img/explain-type-all.png\\",\\"https://javabaguwen.com/img/explain-possible_keys.png\\",\\"https://javabaguwen.com/img/explain-key.png\\",\\"https://javabaguwen.com/img/explain-key_len.png\\",\\"https://javabaguwen.com/img/explain-ref1.png\\",\\"https://javabaguwen.com/img/explain-ref2.png\\",\\"https://javabaguwen.com/img/explain-ref3.png\\",\\"https://javabaguwen.com/img/explain-rows.png\\",\\"https://javabaguwen.com/img/explain-filtered.png\\",\\"https://javabaguwen.com/img/explain-Using%20where.png\\",\\"https://javabaguwen.com/img/explain-Using%20index.png\\",\\"https://javabaguwen.com/img/explain-Using%20filesort.png\\",\\"https://javabaguwen.com/img/explain-Using%20temporary.png\\",\\"https://javabaguwen.com/img/explain-Using%20join%20buffer.png\\",\\"https://javabaguwen.com/img/explain-Using%20index%20condition.png\\",\\"https://javabaguwen.com/img/explain%E6%80%BB%E7%BB%93.png\\"],\\"dateModified\\":\\"2025-04-29T06:25:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1. explain的使用","slug":"_1-explain的使用","link":"#_1-explain的使用","children":[]},{"level":2,"title":"2. explain字段详解","slug":"_2-explain字段详解","link":"#_2-explain字段详解","children":[{"level":3,"title":"1. id列","slug":"_1-id列","link":"#_1-id列","children":[]},{"level":3,"title":"2. select_type列","slug":"_2-select-type列","link":"#_2-select-type列","children":[]},{"level":3,"title":"3. table列","slug":"_3-table列","link":"#_3-table列","children":[]},{"level":3,"title":"4. partitions列","slug":"_4-partitions列","link":"#_4-partitions列","children":[]},{"level":3,"title":"5. type列","slug":"_5-type列","link":"#_5-type列","children":[]},{"level":3,"title":"6. possible_keys列","slug":"_6-possible-keys列","link":"#_6-possible-keys列","children":[]},{"level":3,"title":"7. key列","slug":"_7-key列","link":"#_7-key列","children":[]},{"level":3,"title":"8. key_len列","slug":"_8-key-len列","link":"#_8-key-len列","children":[]},{"level":3,"title":"9. ref列","slug":"_9-ref列","link":"#_9-ref列","children":[]},{"level":3,"title":"10. rows列","slug":"_10-rows列","link":"#_10-rows列","children":[]},{"level":3,"title":"11. filtered列","slug":"_11-filtered列","link":"#_11-filtered列","children":[]},{"level":3,"title":"12. Extra列","slug":"_12-extra列","link":"#_12-extra列","children":[]}]},{"level":2,"title":"知识点总结：","slug":"知识点总结","link":"#知识点总结","children":[]}],"git":{"createdTime":1745907928000,"updatedTime":1745907928000,"contributors":[{"name":"Yideng","email":"oointer@163.com","commits":1}]},"readingTime":{"minutes":4.34,"words":1303},"filePathRelative":"mysql/explain.md","localizedDate":"2025年4月29日","autoDesc":true}');export{o as comp,d as data};
